<!DOCTYPE html><html lang="en"><head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    <meta name="description" content="AFL_fuzz源码分析 自己动手调试并在此记录了一下，在学习的过程中参考了sakura大佬的文章 https://eternalsakura13.com/2020/08/23/afl/  afl-gcc程序调试的参数是：/usr/local/bin/afl-gcc /path/test.c -o /path/test ，先从主函数开始看第一部分 1234567891011121314151617">
<meta property="og:type" content="article">
<meta property="og:title" content="AFL_fuzz源码分析">
<meta property="og:url" content="http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="z1r0's blog">
<meta property="og:description" content="AFL_fuzz源码分析 自己动手调试并在此记录了一下，在学习的过程中参考了sakura大佬的文章 https://eternalsakura13.com/2020/08/23/afl/  afl-gcc程序调试的参数是：/usr/local/bin/afl-gcc /path/test.c -o /path/test ，先从主函数开始看第一部分 1234567891011121314151617">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-03-23T13:31:33.000Z">
<meta property="article:modified_time" content="2023-08-17T06:28:19.669Z">
<meta property="article:author" content="z1r0">
<meta property="article:tag" content="fuzz">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>AFL_fuzz源码分析</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="z1r0's blog" type="application/atom+xml">
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.1.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/z1r00?tab=repositories">Projects</a></li><!--
     --><!--
       --><li><a href="/links/">links</a></li><!--
     -->
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/03/30/CH341A%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/02/22/win-pwn%E5%88%9D%E6%8E%A2%EF%BC%88%E5%9B%9B%EF%BC%89/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;text=AFL_fuzz源码分析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=AFL_fuzz源码分析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;is_video=false&amp;description=AFL_fuzz源码分析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=AFL_fuzz源码分析&amp;body=Check out this article: http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=AFL_fuzz源码分析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=AFL_fuzz源码分析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=AFL_fuzz源码分析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=AFL_fuzz源码分析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;name=AFL_fuzz源码分析&amp;description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;t=AFL_fuzz源码分析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">AFL_fuzz源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-gcc"><span class="toc-number">1.1.</span> <span class="toc-text">afl-gcc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#find-as"><span class="toc-number">1.1.1.</span> <span class="toc-text">find_as</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#edit-params"><span class="toc-number">1.1.2.</span> <span class="toc-text">edit_params</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">1.1.3.</span> <span class="toc-text">final</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-as"><span class="toc-number">1.2.</span> <span class="toc-text">afl-as</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#edit-params-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">edit_params</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add-instrumentation"><span class="toc-number">1.2.2.</span> <span class="toc-text">add_instrumentation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-fuzz"><span class="toc-number">1.3.</span> <span class="toc-text">afl-fuzz</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.1.</span> <span class="toc-text">初始配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#setup-signal-handlers"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">setup_signal_handlers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#check-asan-opts"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">check_asan_opts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fix-up-sync"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">fix_up_sync</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#save-cmdline"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">save_cmdline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fix-up-banner"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">fix_up_banner</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#check-if-tty"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">check_if_tty</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-core-count"><span class="toc-number">1.3.1.7.</span> <span class="toc-text">get_core_count</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bind-to-free-cpu"><span class="toc-number">1.3.1.8.</span> <span class="toc-text">bind_to_free_cpu</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#check-crash-handling"><span class="toc-number">1.3.1.9.</span> <span class="toc-text">check_crash_handling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#check-cpu-governor"><span class="toc-number">1.3.1.10.</span> <span class="toc-text">check_cpu_governor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setup-post"><span class="toc-number">1.3.1.11.</span> <span class="toc-text">setup_post</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setup-shm"><span class="toc-number">1.3.1.12.</span> <span class="toc-text">setup_shm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init-count-class16"><span class="toc-number">1.3.1.13.</span> <span class="toc-text">init_count_class16</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setup-dirs-fds"><span class="toc-number">1.3.1.14.</span> <span class="toc-text">setup_dirs_fds</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#read-testcases"><span class="toc-number">1.3.1.15.</span> <span class="toc-text">read_testcases</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#add-to-queue"><span class="toc-number">1.3.1.16.</span> <span class="toc-text">add_to_queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#load-auto"><span class="toc-number">1.3.1.17.</span> <span class="toc-text">load_auto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pivot-inputs"><span class="toc-number">1.3.1.18.</span> <span class="toc-text">pivot_inputs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#load-extras"><span class="toc-number">1.3.1.19.</span> <span class="toc-text">load_extras</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find-timeout"><span class="toc-number">1.3.1.20.</span> <span class="toc-text">find_timeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#detect-file-args"><span class="toc-number">1.3.1.21.</span> <span class="toc-text">detect_file_args</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setup-stdio-file"><span class="toc-number">1.3.1.22.</span> <span class="toc-text">setup_stdio_file</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#check-binary"><span class="toc-number">1.3.1.23.</span> <span class="toc-text">check_binary</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-cur-time"><span class="toc-number">1.3.1.24.</span> <span class="toc-text">get_cur_time</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#perform-dry-run"><span class="toc-number">1.3.1.25.</span> <span class="toc-text">perform_dry_run</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#calibrate-case"><span class="toc-number">1.3.1.26.</span> <span class="toc-text">calibrate_case</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init-forkserver"><span class="toc-number">1.3.1.27.</span> <span class="toc-text">init_forkserver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#has-new-bits"><span class="toc-number">1.3.1.28.</span> <span class="toc-text">has_new_bits</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#run-target"><span class="toc-number">1.3.1.29.</span> <span class="toc-text">run_target</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#classify-counts"><span class="toc-number">1.3.1.30.</span> <span class="toc-text">classify_counts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#count-bytes"><span class="toc-number">1.3.1.31.</span> <span class="toc-text">count_bytes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update-bitmap-score"><span class="toc-number">1.3.1.32.</span> <span class="toc-text">update_bitmap_score</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#minimize-bits"><span class="toc-number">1.3.1.33.</span> <span class="toc-text">minimize_bits</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cull-queue"><span class="toc-number">1.3.1.34.</span> <span class="toc-text">cull_queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mark-as-redundant"><span class="toc-number">1.3.1.35.</span> <span class="toc-text">mark_as_redundant</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#show-init-stats"><span class="toc-number">1.3.1.36.</span> <span class="toc-text">show_init_stats</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find-start-position"><span class="toc-number">1.3.1.37.</span> <span class="toc-text">find_start_position</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#write-stats-file"><span class="toc-number">1.3.1.38.</span> <span class="toc-text">write_stats_file</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#save-auto"><span class="toc-number">1.3.1.39.</span> <span class="toc-text">save_auto</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fuzz%E4%B8%BB%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.2.</span> <span class="toc-text">Fuzz主循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-fuzzers"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">sync_fuzzers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#save-if-interesting"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">save_if_interesting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#simplify-trace"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">simplify_trace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fuzz-one"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">fuzz_one</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#trim-case"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">trim_case</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#calculate-score"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">calculate_score</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#common-fuzz-stuff"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">common_fuzz_stuff</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">1.5.</span> <span class="toc-text">Reference</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope="" itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        AFL_fuzz源码分析
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <span itemprop="name">z1r0</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-03-23T13:31:33.000Z" itemprop="datePublished">2023-03-23</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/study/">study</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/fuzz/" rel="tag">fuzz</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="AFL-fuzz源码分析"><a href="#AFL-fuzz源码分析" class="headerlink" title="AFL_fuzz源码分析"></a>AFL_fuzz源码分析</h1><blockquote>
<p>自己动手调试并在此记录了一下，在学习的过程中参考了sakura大佬的文章</p>
<p><a target="_blank" rel="noopener" href="https://eternalsakura13.com/2020/08/23/afl/">https://eternalsakura13.com/2020/08/23/afl/</a></p>
</blockquote>
<h2 id="afl-gcc"><a href="#afl-gcc" class="headerlink" title="afl-gcc"></a>afl-gcc</h2><p>程序调试的参数是：<code>/usr/local/bin/afl-gcc /path/test.c -o /path/test</code> ，先从主函数开始看第一部分</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> {</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">"AFL_QUIET"</span>)) {</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">"afl-cc "</span> cBRI VERSION cRST <span class="string">" by &lt;lcamtuf@google.com&gt;\n"</span>);</span><br><span class="line"></span><br><span class="line">  } <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) {</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">"\n"</span></span><br><span class="line">         <span class="string">"This is a helper application for afl-fuzz. It serves as a drop-in replacement\n"</span></span><br><span class="line">         <span class="string">"for gcc or clang, letting you recompile third-party code with the required\n"</span></span><br><span class="line">         <span class="string">"runtime instrumentation. A common use pattern would be one of the following:\n\n"</span></span><br><span class="line"></span><br><span class="line">         <span class="string">"  CC=%s/afl-gcc ./configure\n"</span></span><br><span class="line">         <span class="string">"  CXX=%s/afl-g++ ./configure\n\n"</span></span><br><span class="line"></span><br><span class="line">         <span class="string">"You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n"</span></span><br><span class="line">         <span class="string">"Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n"</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>如果没有设置<code>AFL_QUIET</code>这个环境变量，在屏幕上显示信息，argc是4，所以并不会退出，继续</p>
<h3 id="find-as"><a href="#find-as" class="headerlink" title="find_as"></a>find_as</h3><blockquote>
<p>接下来是find_as函数，这个函数用来寻找<code>afl-as</code>的位置</p>
</blockquote>
<p>首先会检查是否存在<code>AFL_PATH</code>这个环境变量，如果存在就给<code>afl_path</code>并且<code>afl_path/as</code>可以访问的话，则将<code>afl_path</code>给到<code>as_path</code></p>
<p>如果没有<code>afl_path</code>，检查argv0是否存在/，然后找到最后的/这个位置，并将最后的/+后面的东西赋值给slash，也就是上面的<code>/usr/local/bin/afl-gcc</code>，最后<code>slash = /afl-gcc</code>，然后会把前面的<code>/usr/local/bin</code>赋值给dir，然后检查<code>dir/afl-as</code>是否可以访问，如果可以访问，则<code>as_path = dir</code></p>
<p>再下面会检查<code>AFL_PATH/as</code>可不可以访问，如果可以访问则<code>as_path = AFL_PATH</code>，这里应该是没有意义的，因为一开始就会检查是否存在<code>AFL_PATH</code>这个环境变量，但是笔者在调试的时候发现第一步检查环境变量是NULL，重要的是最后一个检查<code>AFL_PATH/as</code>可不可以访问竟然有值了，是<code>/usr/local/lib/afl</code>，最终<code>as_path = /usr/local/lib/afl</code></p>
<h3 id="edit-params"><a href="#edit-params" class="headerlink" title="edit_params"></a>edit_params</h3><blockquote>
<p>处理afl-gcc后面的参数，处理后放入cc_params[]数组</p>
</blockquote>
<p>首先会给cc_params开一个内存空间，空间大小是<code>(argc + 128) * sizeof(u8*)</code>，在这个例子中argc是4</p>
<p>检查第一个参数也就是<code>/usr/local/bin/afl-gcc</code>这里有没有/，如果有则<code>name = afl-gcc</code>，如果没有那name就直接等于第一个参数</p>
<p>接着会判断是否是<code>afl-clang</code></p>
<ul>
<li><p>如果是则设置<code>clang_name=1</code>，环境变量<code>CLANG_ENV_VAR</code>设置为1</p>
<ul>
<li>又继续和<code>afl-clang++</code>比较，如果相等并且<code>AFL_CXX</code>环境变量存在，把<code>cc_params[0]</code>设置成这个环境变量的值，如果不存在则设置成clang++</li>
<li>如果不是<code>afl-clang++</code>，并且<code>AFL_CC</code>环境变量存在，把<code>cc_params[0]</code>设置成这个环境变量的值，如果不存在则设置成clang</li>
</ul>
</li>
<li><p>如果不是<code>afl-clang</code>，则判断是否是<code>afl-g++</code></p>
<ul>
<li>是<code>afl-g++</code>的话，并且<code>AFL_CXX</code>环境变量存在，把<code>cc_params[0]</code>设置成这个环境变量的值，如果不存在则设置成g++</li>
<li>是<code>afl-gcj</code>的话，并且<code>AFL_GCJ</code>环境变量存在，把<code>cc_params[0]</code>设置成这个环境变量的值，如果不存在则设置成gcj</li>
<li>是其他的话，并且<code>AFL_CC</code>环境变量存在，把<code>cc_params[0]</code>设置成这个环境变量的值，如果不存在则设置成gcc</li>
</ul>
</li>
</ul>
<p>在这个例子里<code>cc_params[0]</code>就等于<code>gcc</code>，中间还有一个<code>#ifdef __APPLE__</code>，这个意思是苹果平台需要进行的操作，这里是在linux下的，所以不需要太关注</p>
<p>接着会从argv[1]开始遍历，跳过<code>-B/integrated-as/-pipe</code>，如果有<code>-fsanitize=address</code>和<code>-fsanitize=memory</code>这个参数，则设置<code>asan_set = 1</code>，如果有<code>FORTIFY_SOURCE</code>，则<code>fortify_set = 1</code>，把参数都依次保存在ccparams这里<code>cc_params[cc_par_cnt++] = cur</code></p>
<p>在后面会加上<code>-B as_path</code>这两个参数，判断是否是clang_mode，如果是则再加<code>-no-integrated-as</code>这个参数，如果存在<code>AFL_HARDEN</code>环境变量，则参数加上<code>-fstack-protector-all</code>，在环境变量存在的前提下如果<code>fortify_set = 1</code>，则再加上<code>-D_FORTIFY_SOURCE=2</code></p>
<p>如果<code>asan_set</code>被设置了，则设置<code>AFL_USE_ASAN</code>这个环境变量为1，在<code>asan_set</code>没有被设置的前提下，如果设置了<code>AFL_USE_ASAN</code>，则不能再同时指定<code>AFL_USE_MASN, AFL_HARDEN</code>这两个，设置<code>-U_FORTIFY_SOURCE,-fsanitize=memory</code>，如果前面都没设置，则看是否设置了<code>AFL_USE_MASN</code>，和第二个差不多</p>
<p>如果不存在<code>AFL_DONT_OPTIMIZE</code>这个环境变量则设置<code>-g -O3 -funroll-loops -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</code>，如果存在<code>AFL_NO_BUILTIN</code>这个变量，则设置<code>-fno-builtin-strcmp/-fno-builtin-strncmp</code>等</p>
<p>最终结尾给一个NULL结束</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  find_as(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(cc_params); ++i){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"id[%d] = %s\n"</span>, i, cc_params[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="type">char</span>**)cc_params);</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">"Oops, failed to execute '%s' - check your PATH"</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后会通过execvp来执行命令，最终的命令可以借助printf打印出来看一下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">id[<span class="number">0</span>] = gcc</span><br><span class="line">id[<span class="number">1</span>] = /home/z1r0/fuzz_test/test.c</span><br><span class="line">id[<span class="number">2</span>] = -o</span><br><span class="line">id[<span class="number">3</span>] = /home/z1r0/fuzz_test/test</span><br><span class="line">id[<span class="number">4</span>] = -B</span><br><span class="line">id[<span class="number">5</span>] = /usr/local/lib/afl</span><br><span class="line">id[<span class="number">6</span>] = -g</span><br><span class="line">id[<span class="number">7</span>] = -O3</span><br></pre></td></tr></tbody></table></figure>

<p>会把<code>/usr/local/lib/afl</code>加到编译器的搜索路径，在这个例子里实际会调用<code>afl-as</code>来作为汇编器</p>
<h2 id="afl-as"><a href="#afl-as" class="headerlink" title="afl-as"></a>afl-as</h2><p>从上面得到最终会调用as这个东西来进行插桩，对其进行调试，在调试之前打印一下参数，然后调试的时候传入参数即可</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(pid = fork())) {</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(as_params); ++i){</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"as[%d] = %s\n"</span>, i, as_params[i]);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">    execvp(as_params[<span class="number">0</span>], (<span class="type">char</span>**)as_params);</span><br><span class="line">    FATAL(<span class="string">"Oops, failed to execute '%s' - check your PATH"</span>, as_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">as[<span class="number">0</span>] = as</span><br><span class="line">as[<span class="number">1</span>] = -<span class="number">-64</span></span><br><span class="line">as[<span class="number">2</span>] = -o</span><br><span class="line">as[<span class="number">3</span>] = /tmp/ccuXPXsJ.o</span><br><span class="line">as[<span class="number">4</span>] = /tmp/.afl<span class="number">-3164329</span><span class="number">-1677932048.</span>s</span><br><span class="line">as[<span class="number">5</span>] = (null)</span><br><span class="line">as[<span class="number">6</span>] = (null)</span><br><span class="line">as[<span class="number">7</span>] = (null)</span><br></pre></td></tr></tbody></table></figure>

<p>主函数前面的逻辑和afl-gcc都差不多，会获取<code>AFL_INST_RATIO</code>这个环境变量的值，设置为<code>inst_ratio_str</code>，<code>gettimeofday</code>这个是获取时间，然后设置随机数种子<code>rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();</code>，接着把参数传入<code>edit_params</code>函数</p>
<h3 id="edit-params-1"><a href="#edit-params-1" class="headerlink" title="edit_params"></a>edit_params</h3><blockquote>
<p>给<code>tmp_dir</code>赋值，获得<code>AFL_AS</code>环境变量如果存在则设置<code>afl_as</code>的值，还会对apple平台进行额外的设置</p>
</blockquote>
<ul>
<li>先判断<code>TMPDIR/TEMP/TMP</code>这三个环境变量是否有值，如果哪个有值则把那个值给到tmp_dir</li>
<li>如果都没有则tmp_dir为/tmp</li>
</ul>
<p>给as_params开一个空间，空间大小是<code>(argc + 32) * sizeof(u8*)</code></p>
<p>如果<code>afl_as</code>为空则<code>as_params[0] = as</code>，否则<code>as_params[0] = afl_as</code>，<code>as_params[argc] = 0</code></p>
<p>遍历传入的参数，如果有–64则<code>use_64bit = 1</code>，如果有<code>--32则use_64bit = 0</code>，还会对apple平台进行判断，如果是<code>-arch x86_64</code>，则<code>use_64bit = 1</code>，并且会跳过-q和-Q，如果是32的话就不支持</p>
<p><code>as_params[as_par_cnt++] = argv[i]</code>把参数都一一放到<code>as_params</code>这里，apple平台的话进行额外的设置</p>
<p>把最后一个参数传给<code>input_file</code></p>
<ul>
<li><p>如果<code>input_file</code>的首字符是-</p>
<ul>
<li>后面是-version的话，<code>just_version = 1</code>，<code>modified_file = input_file</code></li>
<li>如果不是-version的话，则报错</li>
<li>如果后面没有的话则<code>input_file=NULL</code></li>
</ul>
</li>
<li><p>如果首字符不是-</p>
<ul>
<li>比较<code>tmp_dir</code>、<code>/var/tmp</code>、<code>/tmp/</code>，的前<code>strlen(tmp_dir)/9/5</code>个字节是否相等，不相等就设置<code>pass_thru=1</code></li>
</ul>
</li>
</ul>
<p>设置<code>modified_file</code>为<code>tmp_dir/.afl-getpid()-time(NULL).s</code></p>
<p>设置<code>as_params[as_par_cnt++] = modified_file;</code>和<code>as_params[as_par_cnt]   = NULL;</code></p>
<h3 id="add-instrumentation"><a href="#add-instrumentation" class="headerlink" title="add_instrumentation"></a>add_instrumentation</h3><blockquote>
<p>插桩函数</p>
</blockquote>
<p>如果<code>input_file</code>不为空，利用fopen打开这个文件，如果为空则<code>inf = stdin</code>，最终都会给到<code>inf</code>这个FILE*指针</p>
<p>打开<code>modified_file</code>获取outfd，再通过outfd利用fdopen得到outf这个FILE*指针</p>
<p>通过fgets把inf里的内容读取到line这个数组中，每行最多读取<code>MAX_LINE</code>也就是8192</p>
<ul>
<li><p>判断<code>instr_ok &amp;&amp; instrument_next &amp;&amp; line[0] == '\t' &amp;&amp; isalpha(line[1])</code>，<code>instr_ok和instrument_next</code>是否都为1，<code>line</code>是否是<code>\t</code>，<code>line[1]</code>是否是字母</p>
<ul>
<li>如果都满足，向outf中写入对应的<code>trampoline_fmt</code>，设置<code>instrument_next = 0</code>，插桩计数器<code>ins_lines++</code></li>
<li>这些都是想要插入instrumentation trampoline到所有的标签，宏，注释之后</li>
</ul>
</li>
<li><p>instr_ok为1的话就代表在.text部分，如果是0的话就代表不在，如果在的话就会执行插桩逻辑，不在就不执行插桩逻辑</p>
<ul>
<li>line为<code>\t.text\n, \t.section\t.text, \t.section\t__TEXT,__text, \t.section __TEXT, __text</code>之中的一个，设置instr_ok为1，然后continue，回到while继续从inf读数据到line这个数组中</li>
<li>line为<code>\t.section\t, \t.section, \t.bss\n, \t.data\n</code>之中的一个，设置instr_ok = 0，然后continue，回到while继续从inf读数据到line这个数组中</li>
<li>如果<code>clang_mode = 0, instr_ok = 1</code>，并且line为<code>\t.p2align</code>，则<code>skip_next_label = 1</code></li>
</ul>
</li>
<li><p>判断一些信息，是att汇编还是intel汇编，是32位还是64位，接着设置相应的flag</p>
</li>
<li><p>插桩<code>^\tjnz foo</code>条件跳转指令，插桩重点是<code>^main ^.L0 ^.LBB0_0 ^\tjnz foo</code></p>
<ul>
<li>如果line的值是<code>\tj[!m].</code>，并且<code>R(100) &lt; inst_ratio</code>，<code>R(100)</code>是一个100以内的随机数，inst_ratio默认是100，则会进行插桩，如果<code>inst_ratio</code>设置为0就代表不会对该分支进行插桩，<code>R()</code>这个相当于是区分每个桩的，看成一个flag</li>
<li>判断是否对应的位数然后向outf里写入<code>trampoline_fmt_64</code>或者<code>trampoline_fmt_32</code></li>
</ul>
</li>
<li><p><code>ins_lines</code>插桩计数器+1</p>
</li>
<li><p>检查line是否有<code>:</code>，然后检查第一个是不是<code>.</code></p>
<ul>
<li><p>如果第一个是<code>.</code>，则就是想插桩<code>^.L0:</code>或者<code>^.LBB0_0</code>这样的branch label，即style jump destination</p>
<ul>
<li>检查<code>line[2]</code>是否是数字，或者在<code>clang_mode</code>下比较<code>line[1]</code>开始的3个字节是否是<code>LBB</code></li>
<li>上面的结果和<code>R(100) &lt; inst_ratio</code>相与<ul>
<li>如果满足条件，并且<code>skip_next_label</code>不为0，则<code>instrument_next</code>为1，反之为0</li>
</ul>
</li>
</ul>
</li>
<li><p>否则是一个function，插桩<code>^func</code>，把<code>instrument_next</code>设置成1</p>
</li>
</ul>
</li>
<li><p>上面执行完之后满足第一个条件，那就真正的插桩了</p>
</li>
</ul>
<p>如果插桩计数器不为0，那么就在上面操作之后把对应的<code>main_payload</code>写入outf，然后关闭这两个文件</p>
<p>上面就是afl-as的主要逻辑，afl的插桩相当简单粗暴，就是通过汇编的前导命令来判断这是否是一个分支或者函数，然后插入instrumentation trampoline</p>
<p>最后就是afl-as的main结尾，fork出一个子进程，让子进程来执行<code>execvp(as_params[0], (char **) as_params);</code>，如果没有设置环境变量<code>AFL_KEEP_ASSEMBLY</code>的值，就unlink掉modified_file</p>
<h2 id="afl-fuzz"><a href="#afl-fuzz" class="headerlink" title="afl-fuzz"></a>afl-fuzz</h2><h3 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h3><p><code>gettimeofday</code>获取时间，然后设置随机数种子<code>rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();</code>这个和afl-as前面一样</p>
<h4 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h4><blockquote>
<p>注册必要的信号处理函数</p>
</blockquote>
<ul>
<li>SIGHUP，由一个处于非连接状态的终端发送给控制进程，或者由控制进程在自身结束时发送给每个前台进程</li>
<li>SIGINT，一般由从终端敲入的Crl+C组合键或预先设置好的中断字符产生</li>
<li>SIGTERM，作为一个请求被发送，要求进程结束运行。UNIX在关机时用这个信号要求系统服务停止运行。它是kill命今默认发送的信号</li>
<li>SIGALRM，由alarm函数设置的定时器产生</li>
<li>SIGWINCH，处理窗口大小的变化信号</li>
<li>SIGPIPE，如果在向管道写数据时没有与之对应的读进程，就会产生这个信号</li>
<li>SIGUSR1，进程之问可以用这个信号进行通信，例如让进程报告状态信息等</li>
</ul>
<h4 id="check-asan-opts"><a href="#check-asan-opts" class="headerlink" title="check_asan_opts"></a>check_asan_opts</h4><p>读取<code>ASAN_OPTIONS</code>和<code>MSAN_OPTIONS</code>，进行一些检查</p>
<h4 id="fix-up-sync"><a href="#fix-up-sync" class="headerlink" title="fix_up_sync"></a>fix_up_sync</h4><p>如果通过-M或者-S指定了sync_id，设置sync_dir值为<code>out_dir</code>，设置out_dir的值为<code>out_dir/sync_id</code></p>
<h4 id="save-cmdline"><a href="#save-cmdline" class="headerlink" title="save_cmdline"></a>save_cmdline</h4><p>将当前输入参数拷贝进buf空间中</p>
<h4 id="fix-up-banner"><a href="#fix-up-banner" class="headerlink" title="fix_up_banner"></a>fix_up_banner</h4><blockquote>
<p>如果没有设置<code>use_banner</code></p>
</blockquote>
<ul>
<li>如果设置了sync_id，则<code>use_banner = sync_id</code></li>
<li>如果没有设置sync_id，trim为最后一个包含/的参数的后面部分（/目标测试文件）<ul>
<li>如果trim存在，则<code>use_banner = trime + 1</code>就是目标测试文件，否则<code>use_banner = name</code></li>
</ul>
</li>
</ul>
<p>如果use_banner长度大于40则只保留40个长度</p>
<h4 id="check-if-tty"><a href="#check-if-tty" class="headerlink" title="check_if_tty"></a>check_if_tty</h4><p>检查是否在tty终端上运行，如果不是tty的话<code>not_on_tty=1</code></p>
<h4 id="get-core-count"><a href="#get-core-count" class="headerlink" title="get_core_count"></a>get_core_count</h4><p>这个其实就是获取cpu的核心数量</p>
<h4 id="bind-to-free-cpu"><a href="#bind-to-free-cpu" class="headerlink" title="bind_to_free_cpu"></a>bind_to_free_cpu</h4><p>检查是否有空闲的核心了，如果有的话就绑定到空闲cpu</p>
<h4 id="check-crash-handling"><a href="#check-crash-handling" class="headerlink" title="check_crash_handling"></a>check_crash_handling</h4><p>确保核心转储不会进入程序</p>
<h4 id="check-cpu-governor"><a href="#check-cpu-governor" class="headerlink" title="check_cpu_governor"></a>check_cpu_governor</h4><p>检查CPU调节器</p>
<h4 id="setup-post"><a href="#setup-post" class="headerlink" title="setup_post"></a>setup_post</h4><p>如果没有设置<code>AFL_POST_LIBRARY</code>这个环境变量则直接返回，设置了这个变量会加载<code>afl_postprocess</code>函数</p>
<h4 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup_shm"></a>setup_shm</h4><p>如果<code>in_bitmap</code>为空，则通过memset初始化virgin_bits数组里的每个元素为<code>255(\xff)</code></p>
<p>通过memset初始化<code>virgin_tmout和virgin_crash</code>数组里的每个元素为<code>255(\xff)</code></p>
<p>shmget分配了一个共享内存，将返回的共享内存标识符保存到shm_id里</p>
<ul>
<li><code>shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600); </code></li>
<li>一参与信号量的semget函数一样，程序需要提供一个参数key（非0整数），它有效地为共享内存段命名，shmget()函数成功时返回一个与key相关的共享内存标识符（非负整数），用于后续的共享内存函数。调用失败返回-1</li>
<li><code>IPC_PRIVATE</code>为0所以创建一块新的共享内存，大小是MAP_SIZE</li>
<li>第三个参数它的作用与open函数的mode参数一样<ul>
<li><code>IPC_CREAT</code>如果共享内存不存在，则创建一个共享内存，否则打开操作</li>
<li><code>IPC_EXC</code>L只有在共享内存不存在的时候，新的共享内存才创建，否则产生错误</li>
<li><code>0600</code>代表拥有者具有读写权限</li>
</ul>
</li>
</ul>
<p>注册程序正常终止时调用<code>remove_shm</code>函数</p>
<ul>
<li><code>shmctl(shm_id, IPC_RMID, NULL);</code>用来控制共享内存<ul>
<li>第一个参数，shm_id是shmget()函数返回的共享内存标识符</li>
<li>第二个参数，command是要采取的操作，它可以取下面的三个值 ：<ul>
<li><code>IPC_STAT</code>：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值</li>
<li><code>IPC_SET</code>：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值</li>
<li><code>IPC_RMID</code>：删除共享内存段</li>
</ul>
</li>
<li>所以第二个参数意思就是删除共享内存段</li>
<li>第三个参数，buf是一个结构指针，它指向共享内存模式和访问权限的结构</li>
</ul>
</li>
</ul>
<p>创建shm_str，这个里面存放的还是shm_id</p>
<p>如果不是dumb_mode，则设置环境变量<code>SHM_ENV_VAR</code>的值为shm_str</p>
<p>释放shm_str指针，并<code>trace_bits = shmat(shm_id, NULL, 0);  </code></p>
<ul>
<li><code>shmat(shm_id, NULL, 0);</code><ul>
<li>第一次创建完共享内存时，它还不能被任何进程访问，shmat()函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间</li>
<li>第一个参数，shm_id是由shmget()函数返回的共享内存标识</li>
<li>第二个参数，指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址</li>
<li>第三个参数，shm_flg是一组标志位，通常为0</li>
<li>调用成功时返回一个指向共享内存第一个字节的指针，失败返回-1</li>
</ul>
</li>
</ul>
<p>trace_bits指向共享内存第一个字节的指针，如果失败则报错</p>
<h4 id="init-count-class16"><a href="#init-count-class16" class="headerlink" title="init_count_class16"></a>init_count_class16</h4><blockquote>
<p>这个用来初始化<code>count_class_lookup16</code>数组，将<code>count_class_lookup16</code>数组分成256段，每段256份</p>
</blockquote>
<ul>
<li><p><code>count_class_lookup8</code>，把这个路径命中数进行规整</p>
<ul>
<li>执行了4-7次的其计数为8，比如32次到127次都会认为是64</li>
<li>变量 <code>trace_bits</code> 来记录分支执行次数，而count_class_lookup8实际就是对于<code>trace_bits</code>的规整。</li>
</ul>
</li>
<li><p>而初始化<code>count_class_lookup16</code>实际是因为 AFL 中对于一条分支径的表示是由一个二元组来表示的</p>
<ul>
<li>比如A-&gt;B-&gt;C-&gt;D，可用<code>[A, B], [B, C], [C, D]</code>来表示，基于效率考虑，使用了<code>count_class_lookup16</code>这个数组</li>
</ul>
</li>
</ul>
<h4 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds"></a>setup_dirs_fds</h4><blockquote>
<p>准备输出文件夹和fd</p>
</blockquote>
<p>如果sync_id存在，并且创建sync_dir文件夹，权限是0700，并且<code>errno != EEXIST</code>则异常</p>
<p>创建out_dir文件夹，权限是0700，创建成功返回0，创建错误返回-1，并且错误保存在errno中</p>
<ul>
<li>创建失败<ul>
<li>如果errno不是EEXIST则异常<ul>
<li>maybe_delete_out_dir，这个函数会删除out_dir里面的旧东西</li>
</ul>
</li>
</ul>
</li>
<li>创建成功<ul>
<li>如果设置了<code>in_place_resume</code>则异常</li>
<li>以只读打开<code>out_dir</code>，返回文件句柄到<code>out_dir_fd</code></li>
<li>如果没有定义宏<code>__sun</code><ul>
<li>打开失败或者通过flock建立互斥锁定失败，异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>创建<code>out_dir/queue</code>文件夹，权限为0700</p>
<ul>
<li>创建<code>out_dir/queue/.state/</code>，设置权限为0700，该文件夹主要<strong>保存用于session resume和related tasks的queue metadata</strong><ul>
<li>创建<code>out_dir/queue/.state/deterministic_done/</code>，设置权限为0700，该文件夹<strong>标记过去经历过deterministic fuzzing的queue entries</strong></li>
<li>创建<code>out_dir/queue/.state/auto_extras/</code>，设置权限为0700，<strong>Directory with the auto-selected dictionary entries</strong></li>
<li>创建<code>out_dir/queue/.state/redundant_edges/</code>，设置权限为0700，<strong>保存当前被认为是多余的路径集合</strong></li>
<li>创建<code>out_dir/queue/.state/variable_behavior/</code>，设置权限为0700，<strong>The set of paths showing variable behavior</strong></li>
</ul>
</li>
</ul>
<p>如果sync_id存在</p>
<ul>
<li>创建<code>out_dir/.synced</code>文件夹</li>
</ul>
<p>创建<code>out_dir/crashes</code>文件夹，用于记录crashes</p>
<p>创建<code>out_dir/hangs</code>文件夹，用于记录hangs</p>
<p>以读写模式打开<code>/dev/null</code>，以只读的模式打开<code>/dev/urandom</code></p>
<p>以只写方式打开<code>out_dir/plot_data</code>文件，如果没有则创建一个，获取句柄，根据句柄得到<code>FILE* plot_file</code>，并向里写入<code># unix_time, cycles_done, cur_path, paths_total, pending_total, pending_favs, map_size, unique_crashes, unique_hangs, max_depth, execs_per_sec</code></p>
<h4 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases"></a>read_testcases</h4><blockquote>
<p>从输入文件夹中读取所有文件，然后将它们排队进行测试</p>
</blockquote>
<p>判断<code>in_dir/queue</code>文件是否存在，成功0，失败-1</p>
<ul>
<li>如果存在这个文件，<code>in_dir = fn = in_dir/queue</code></li>
<li>不存在则释放fn</li>
</ul>
<p>扫描in_dir，并将结果保存在<code>struct dirent **nl</code>里（. ..也会被算进去），不使用readdir，因为测试用例的顺序将随机地有些变化，并且将难以控制</p>
<p>如果<code>shuffle_queue</code>的值为真，且nl_cnt大于1，则<code>shuffle_ptrs((void **) nl, nl_cnt)</code>，重排nl里的指针的位置</p>
<p>遍历nl</p>
<ul>
<li><p><code>u8* fn = alloc_printf("%s/%s", in_dir, nl[i]-&gt;d_name);</code>，<code>fn = in_dir/nl[i]-&gt;d_name</code>，<code>nl[i]-&gt;d_name</code>的值为input文件夹下的文件名字符串</p>
</li>
<li><p><code>u8 *dfn = alloc_printf("%s/.state/deterministic_done/%s", in_dir, nl[i]-&gt;d_name);</code></p>
</li>
<li><p>通过文件属性过滤掉<code>.</code>和<code>..</code>这样的regular文件，并检查文件大小，如果文件大小大于MAX_FILE则异常，默认是1024*1024字节，即1M</p>
</li>
<li><p>通过access检查<code>in_dir/.state/deterministic_done/nl[i]-&gt;d_name</code>是否存在，这应该是为了用在resume恢复扫描使用</p>
<ul>
<li>如果存在则设置<code>passwd_det = 1</code></li>
<li>此检查用来判断是否这个入口已经完成deterministic fuzzing。在恢复异常终止的扫描时不想重复进行deterministic fuzzing</li>
</ul>
</li>
<li><p><code>add_to_queue(fn, st.st_size, passed_det);</code></p>
</li>
<li><p>如果queued_paths为0，则代表输入文件夹为0，抛出异常</p>
</li>
<li><p>设置last_path_time为0</p>
</li>
<li><p>queued_at_start的值设置为queued_paths</p>
</li>
</ul>
<h4 id="add-to-queue"><a href="#add-to-queue" class="headerlink" title="add_to_queue"></a>add_to_queue</h4><p>queue_entry是一个链表数据结构，先通过calloc动态分配一个queue_entry结构体，并初始化其fname为文件名fn，len为文件大小，depth为cur_depth + 1，passed_det为传递进来的passed_det，具体代码如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q-&gt;fname        = fname;</span><br><span class="line">q-&gt;len          = len;</span><br><span class="line">q-&gt;depth        = cur_depth + <span class="number">1</span>;</span><br><span class="line">q-&gt;passed_det   = passed_det;</span><br></pre></td></tr></tbody></table></figure>

<p>如果<code>q-&gt;depth &gt; max_depth</code>，则设置max_depth为q-&gt;depth</p>
<p>如果queue_top不为空，则设置<code>queue_top-&gt;next为q，queue_top = q;</code>，否则<code>q_prev100 = queue = queue_top = q;</code></p>
<p>queue计数器queued_paths和待fuzz的样例计数器pending_not_fuzzed加一</p>
<p>cycles_wo_finds设置为0</p>
<p>如果<code>queued_paths % 100 = 0</code>，则<code>q_prev100-&gt;next_100 = q; q_prev100 = q;</code></p>
<p>设置<code>last_path_time = get_cur_time()</code></p>
<h4 id="load-auto"><a href="#load-auto" class="headerlink" title="load_auto"></a>load_auto</h4><blockquote>
<p>load自动生成的提取出来的词典token</p>
</blockquote>
<p>遍历50次</p>
<ul>
<li>以只读的方式打开<code>in_dir/.state/auto_extras/auto_%6u</code></li>
<li>如果打开失败，结束</li>
<li>如果打开成功，读取<code>MAX_AUTO_EXTRA+1</code>个字节到tmp里，长度保存到len中</li>
<li>调用<code>maybe_add_auto</code>按规则加入字典</li>
</ul>
<h4 id="pivot-inputs"><a href="#pivot-inputs" class="headerlink" title="pivot_inputs"></a>pivot_inputs</h4><blockquote>
<p>在<code>out_put</code>目录中为<code>input</code>测试用例创建硬链接</p>
</blockquote>
<p>遍历queue里的queue_entry</p>
<ul>
<li>找到q-&gt;fname最后一个/的位置，然后连带测试用例文件名称赋值给rsl</li>
<li>如果没有获取到上面的东西那么<code>rsl = q-&gt;fname</code>，如果获取到那么rsl就等于testcase的文件名（把前面的/给去了）</li>
<li>rsl前三个字节和<code>id:</code>比较，如果相等则把后面的部分化成%06u这种格式放入orig_id中，并且判断orig_id是否与id相等<ul>
<li>如果相等则设置<code>resuming_fuzz = 1</code></li>
<li>如果不相等，在rsl里寻找<code>,orig:</code><ul>
<li>如果找到了use_name指向后面</li>
<li>如果没有找到则use_name = rsl</li>
</ul>
</li>
<li><code>nfn = out_dir/queue/id:%06u,orig:use_name</code></li>
<li>创建硬链接，<code>q-&gt;fname</code>到nfn，<code>q-&gt;fname</code>指向这个nfn</li>
<li>如果<code>q-&gt;passed_detf</code>为1，则调用<code>mark_as_det_done(q)</code>，代表queue这一项已经fuzz过了</li>
<li>如果设置了<code>in_place_resume</code>，则调用<code>nuke_resume_dir</code>函数<ul>
<li>nuke_resume_dir这个函数删除了很多<code>out_dir/_resume/.stat/</code>目录下的东西</li>
<li>如果删除成功则正常返回，如果删除失败则异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="load-extras"><a href="#load-extras" class="headerlink" title="load_extras"></a>load_extras</h4><p>如果定义了extras_dir，那到加载extras_dir下的文件放入extra数组并排序</p>
<h4 id="find-timeout"><a href="#find-timeout" class="headerlink" title="find_timeout"></a>find_timeout</h4><p>如果<code>timeout_given</code>没有被设置则进入<code>find_timeout</code>函数，在不指定-t的情况下，防止不停的调整超时时间</p>
<p>如果resuming_fuzz为0，则直接return</p>
<p>如果<code>in_place_resume</code>为1，则<code>fn = alloc_printf("%s/fuzzer_stats", out_dir);</code>，否则<code>fn = alloc_printf("%s/../fuzzer_stats", in_dir);</code></p>
<p>只读方式打开fn，读取<code>sizeof(tmp) - 1)</code>大小的数据到tmp中，如果里面有<code>exec_timeout	: </code>就读取这个值并且大于四<code>exec_tmout</code>就设置这个值，如果没有则直接返回，<code>timeout_given = 3</code></p>
<h4 id="detect-file-args"><a href="#detect-file-args" class="headerlink" title="detect_file_args"></a>detect_file_args</h4><p>检查输入argv中是否存在@@，有的话替换成out_dir/.cur_input</p>
<h4 id="setup-stdio-file"><a href="#setup-stdio-file" class="headerlink" title="setup_stdio_file"></a>setup_stdio_file</h4><p>如果out_file没有值（没有使用-f），则调用此函数，会删除原本的<code>out_dir/.cur_input</code>，创建一个新的<code>out_dir/.cur_input</code>，保存其文件描述符在out_fd中</p>
<h4 id="check-binary"><a href="#check-binary" class="headerlink" title="check_binary"></a>check_binary</h4><p>指定路径处要执行的程序是否存在，且它不能是一个shell script，同时检查elf文件头是否合法及程序是否被插桩</p>
<h4 id="get-cur-time"><a href="#get-cur-time" class="headerlink" title="get_cur_time"></a>get_cur_time</h4><p>获取时间</p>
<h4 id="perform-dry-run"><a href="#perform-dry-run" class="headerlink" title="perform_dry_run"></a>perform_dry_run</h4><blockquote>
<p>执行所有的测试用例，以检查是否按预期工作</p>
</blockquote>
<p>设置<code>cal_failures = 0</code>，读取<code>AFL_SKIP_CRASHES</code>环境变量到<code>skip_crashes</code>变量里</p>
<p>遍历queue</p>
<ul>
<li><p>打开q-&gt;fname，这里的q-&gt;fname就是在queue里面的id:000xxx这些文件，然后读取到use_mem中</p>
</li>
<li><p><code>res = calibrate_case(argv, q, use_mem, 0, 1);</code>，校准该测试用例，评估input文件夹下的case</p>
</li>
<li><p>如果stop_soon为1，则直接return</p>
</li>
<li><p>如果res的结果为crash_mode或者为<code>FAULT_NOBITS</code>，打印相关的信息</p>
</li>
<li><p>依据res的结果查看是哪种错误并进行判断。一共有以下几种错误类型</p>
<ul>
<li>FAULT_NONE<ul>
<li>如果q是第一个测试用例，调用<code>check_map_coverage()</code>函数，评估覆盖率</li>
<li>如果是crash_mode则，则异常，代表该测试用例不产生crash</li>
</ul>
</li>
<li>FAULT_TMOUT<ul>
<li>如果指定了-t参数，该测试用例产生超时错误。当<code>timeout_given</code>为2时跳过该文件</li>
</ul>
</li>
<li>FAULT_CRASH<ul>
<li>如果设置了crash_mod，直接break</li>
<li>如果设置了skip_crashes<ul>
<li>设置q-&gt;cal_failed为CAL_CHANCES</li>
<li>cal_fialures计数器+1</li>
</ul>
</li>
<li>如果设置了<code>mem_limit</code>，提示内存不够，抛出异常</li>
</ul>
</li>
<li>FAULT_ERROR<ul>
<li>目标程序无法执行，抛出异常</li>
</ul>
</li>
<li>FAULT_NOINST<ul>
<li>样例没有出现任何路径信息，抛出异常</li>
</ul>
</li>
<li>FAULT_NOBITS<ul>
<li>有路径信息但没新路径，认为这是无用路径，useless_at_start计数器加一</li>
</ul>
</li>
</ul>
</li>
<li><p>如果样例的var_behavior为真，则代表它多次运行，同样的输入条件下，却出现不同的覆盖信息，抛出警告信息</p>
</li>
<li><p>继续读取下面一个样例，直到所以样例读完为止</p>
</li>
<li><p>如果设置了<code>cal_failures</code></p>
<ul>
<li><code>cal_failures = queued_paths</code>代表所有用例均超时</li>
<li>计算<code>cal_failures \* 5</code>是否大于<code>queued_paths</code>，如果大于说明测试用例的问题比例很高，可能需要重新检查设置</li>
</ul>
</li>
</ul>
<p>输出所有testcase运行完成</p>
<h4 id="calibrate-case"><a href="#calibrate-case" class="headerlink" title="calibrate_case"></a>calibrate_case</h4><blockquote>
<p>校准input文件夹下的测试用例，判断该用例是否异常，以及发现新路径时，评估新发现的testcase行为是否可变（这里的可变是指多次执行这个case，发现的路径不同）</p>
</blockquote>
<p>如果<code>q-&gt;exec_cksum</code>为0，代表这是这个case第一次运行，即来自input文件夹下，所以将first_run置为1</p>
<p>保存原有的stage_cur、stage_max、stage_name</p>
<p>设置<code>use_tmout</code>为<code>exec_tmout</code>，如果<code>from_queue</code>是0或者<code>resuming_fuzz</code>被置为1，即代表不来自于queue中或者在<code>resuming sessions</code>的时候，则use_tmout的值被设置的更大，q-&gt;cal_failed++</p>
<p>设置<code>stage_name</code>为<code>calibration</code>，根据fast_cal是否为1来设置<code>stage_max</code>为3还是<code>CAL_CYCLES</code>（默认为8），含义是每个新测试用例（以及显示出可变行为的测试用例）的校准周期数，也就是说这个stage要执行几次的意思</p>
<p>如果不是dumb_mode模式，并且no_forkserver为0，forksrv_pid为0，则<code>init_forkserver(argv)</code>启动<code>fork server</code>（后面说）</p>
<p>如果这个queue不是来自input文件夹，而是评估新case，则此时<code>q-&gt;exec_cksum</code>不为空，拷贝trace_bits到first_trace里，然后计算<code>has_new_bits</code>的值，赋值给new_bits</p>
<p>获取时间</p>
<p>循环stage_max次</p>
<ul>
<li>如果这个queue不是来自input文件夹下，并且第一轮<code>calibration stage</code>执行结束时，刷新一次展示界面<code>show_stats</code>，用来展示这次执行的结果，此后不再展示</li>
<li><code>write_to_testcase</code>将从<code>q-&gt;fname</code>中读取的内容写入到<code>.cur_input</code>中</li>
<li><code>u8 run_target(argv, use_tmout)</code>，结果保存在fault中</li>
<li>如果出现终止或者fault结果不为crash_mode，跳转到abort_calibration</li>
<li>如果不是dumb_mode，并且是<code>calibration stage</code>为第一次运行，且共享内存里没有任何路径（即没有任何byte被置位）设置fault为<code>FAULT_NOINST</code>，然后<code>goto abort_calibration</code></li>
<li>计算<code>hash32(trace_bits, MAP_SIZE, HASH_CONST)</code>的结果，结果保存到cksum中</li>
<li>如果<code>q-&gt;exec_cksum</code>不等于cksum，即代表<strong>这是第一次运行，或者在相同的参数下，每次执行，cksum却不同，是一个路径可变的queue</strong><ul>
<li>如果hnb大于new_bits，设置new_bits的值为hnb</li>
<li>判断<code>q-&gt;exec_cksum</code>是否是可变queue，如果为1，则说明不是第一次执行queue<ul>
<li>遍历<code>MAP_SIZE</code>次，如果first_trace[i]不等于trace_bits[i]，<strong>代表发现了可变queue</strong>，且var_bytes为空，则将该字节设置为1，并将stage_max设置为<code>CAL_CYCLES_LONG</code>，即需要执行40次</li>
<li><code>var_detected=1</code></li>
</ul>
</li>
<li><code>q-&gt;exec_cksum</code>为0的话就代表是第一次执行这个queue<ul>
<li>设置<code>q-&gt;exec_cksum</code>的值为之前计算出来的本次执行的cksum</li>
<li>把<code>trace_bits</code>拷贝到<code>first_trace</code>中</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>保存所有轮次总的执行时间，加到total_cal_us里，总的执行轮次，加到total_cal_cycles里</p>
<p>计算一些信息</p>
<ul>
<li>计算出单次执行时间的平均值保存到q-&gt;exec_us里</li>
<li>将最后一次执行所覆盖到的路径数保存到q-&gt;bitmap_size里</li>
<li><code>q-&gt;handicap = handicap;</code></li>
<li><code>q-&gt;cal_failed = 0;</code></li>
<li>total_bitmap_size里加上这个queue所覆盖到的路径数</li>
<li>total_bitmap_entries++</li>
<li><code>update_bitmap_score(struct queue_entry *q)</code></li>
</ul>
<p>如果不是dumb_mode，并且是第一次运行，并且fault里有值，并且new_bits为0，代表在这个样例所有轮次的执行里，都没有发现任何新路径和出现异常，设置fault为<code>FAULT_NOBITS</code></p>
<p>如果new_bits为2并且<code>q-&gt;has_new_cov</code>为0，则设置<code>q-&gt;has_new_cov</code>为1，并将<code>queued_with_cov</code>加一，代表有一个queue发现了新路径</p>
<p>如果这个queue是可变路径，即<code>var_detected</code>为1，则计算var_bytes里被置位的tuple个数，保存到<code>var_byte_count</code>里，代表这些tuple具有可变的行为</p>
<p>queue标记为一个variable</p>
<ul>
<li><p>创建符号连接<code>out_dir/queue/.state/variable_behavior/fname</code>，设置queue的var_behavior为1</p>
</li>
<li><p>设置queue的var_behavior为1</p>
</li>
<li><p>计数variable behavior的计数器<code>queued_variable</code>的值加一</p>
</li>
</ul>
<p>恢复之前的stage值</p>
<p>如果不是第一次运行这个queue，则<code>show_stats</code></p>
<p>返回fault值</p>
<h4 id="init-forkserver"><a href="#init-forkserver" class="headerlink" title="init_forkserver"></a>init_forkserver</h4><p>建立管道st_pipe和ctl_pipe</p>
<p>fork一个子进程，成功之后会出现两个进程，一个是父进程，一个是子进程，在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID</p>
<p>子进程和父进程都会向下执行，此时可以通过pid来使它们执行不同的代码<code>if(!forksrv_pid)</code></p>
<ul>
<li><p>首先是子进程</p>
<ul>
<li>重定向文件描述符1和2到<code>dev_null_fd</code>，相当于关闭了子进程的全部输出</li>
<li>如果指定了out_file则把文件描述符0重定向到<code>dev_null_fd</code>，否则重定向到out_fd</li>
<li>重定向<code>FORKSRV_FD</code>到ctl_pipe[0],重定向<code>FORKSRV_FD + 1</code>到st_pipe[1]<ul>
<li>子进程只能读取命令</li>
<li>子进程只能发送写出状态</li>
</ul>
</li>
<li>关闭子进程里的一些文件描述符</li>
<li>读取环境变量<code>LD_BIND_LAZY</code>，如果没有设置，则设置环境变量<code>LD_BIND_NOW</code>为1</li>
<li>设置环境变量<code>ASAN_OPTIONS</code>为<code>"abort_on_error=1:" "detect_leaks=0:" "symbolize=0:", "allocator_may_return_null=1"</code></li>
<li><code>MSAN_OPTIONS</code>也做相应的设置</li>
<li><code>execv(target_path, argv)</code><ul>
<li>execv会替换掉原有的进程空间为target_path代表的程序，所以相当于后续就是去执行target_path，这个程序结束的话，子进程就结束</li>
<li>而在这里非常特殊，第一个target会进入<code>__afl_maybe_log</code>里的<code>__afl_fork_wait_loop</code>，并充当fork server，在整个Fuzz的过程中，它都不会结束，每次要Fuzz一次target，都会从这个fork server fork出来一个子进程去fuzz</li>
</ul>
</li>
<li>使用一个独特的<code>bitmaps EXEC_FAIL_SIG(0xfee1dead)</code>写入trace_bits，来告诉父进程执行失败，并结束子进程。</li>
</ul>
</li>
<li><p>然后是父进程</p>
<ul>
<li>关闭ctl_pipe[0]和st_pipe[1]</li>
<li><code>fsrv_ctl_fd = ctl_pipe[1]</code>父进程只能发送(“写出”)命令</li>
<li><code>fsrv_st_fd = st_pipe[0]</code>父进程只能读取状态</li>
<li>等待fork server启动，但是不能等太久</li>
<li>从管道中读取4个字节放在status中，如果成功则代表fork server成功启动</li>
<li>如果超时则抛出异常</li>
</ul>
</li>
</ul>
<h4 id="has-new-bits"><a href="#has-new-bits" class="headerlink" title="has_new_bits"></a>has_new_bits</h4><blockquote>
<p>检查有没有新路径或者某个路径的执行次数有所不同</p>
</blockquote>
<p>初始化current和virgin为trace_bits和virgin_map的u64首元素地址，设置ret的值为0</p>
<p>8字节一组，每次从trace_bits，也就是共享内存里取出8个字节</p>
<ul>
<li><p>如果current不为0，并且<code>current &amp; virgin</code>不为0，代表current发现了新路径或者某条路径的执行次数和之前有所不同</p>
<ul>
<li><p>如果ret小于2</p>
<ul>
<li><p>cur指向current第一个字节，vir指向virgin的第一个字节</p>
</li>
<li><p>判断cur[i] &amp;&amp; vir[i]==0xff</p>
<ul>
<li><p>如果有一个为真则设置ret为2，代表发现了之前没有出现过的tuple（产生了新的路径覆盖）</p>
</li>
<li><p>如果没有则设置ret为1，代表只是命中次数更新</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>*virgin &amp;= ~*current</code></p>
</li>
</ul>
</li>
<li><p>current和virgin移动到下一组8个字节，直到MAPSIZE全被遍历完</p>
</li>
</ul>
<p>如果传入参数virgin_map的值为virgin_bits，且ret不为0，则设置bitmap_changed为1</p>
<h4 id="run-target"><a href="#run-target" class="headerlink" title="run_target"></a>run_target</h4><blockquote>
<p>通过子进程的方式执行目标应用，和前面的init_forkserver很像，但是这个函数处理了在设置了no_forkserver的情况的下的处理过程</p>
</blockquote>
<p>清空<code>trace_bits</code></p>
<p>如果设置了<code>dumb_mode</code>并且<code>no_forkserver</code>，则直接fork一个子进程，然后让子进程execv去执行target，如果execv执行失败，则向trace_bits写入<code>EXEC_FAIL_SIG</code></p>
<p>否则向控制管道中写入4个字节的prev_timed_out，命令fork server开始fork出一个子进程进行fuzz，然后从状态管道读取fork server返回的fork出的子进程的ID到<code>child_pid</code></p>
<p>上面两个都会设置计数器为timeout，如果超时，就杀死正在执行的子进程，并设置child_timed_out为1</p>
<p>计算执行时间，然后<code>total_execs++ </code>（执行次数计数器加一）</p>
<p>如果是dumb_mode，执行结束的状态码直接保存到status中，如果不是dumb_mode，则直接从状态管道中读取结束状态码</p>
<p>设置prev_timed_out的值为child_timed_out</p>
<p>接着依据status的值，向调用者返回结果</p>
<ul>
<li><code>WIFSIGNALED(status)</code>若为异常结束子进程返回的状态，则为真</li>
<li>如果是设置了uses_asan，必须使用特殊的退出代码</li>
<li>如果是dumb_mode，并且是no_forkserver，且trace_bits为<code>EXEC_FAIL_SIG</code>，就返回<code>FAULT_ERROR</code></li>
<li>如果最慢执行时间小于当前执行时间，并且<code>time_out</code>小于等于<code>exec_tmout</code>则更新<code>slowest_exec_ms</code>为<code>exec_ms</code></li>
</ul>
<p>返回<code>FAULT_NONE</code></p>
<h4 id="classify-counts"><a href="#classify-counts" class="headerlink" title="classify_counts"></a>classify_counts</h4><p>八字节一组循环去读，直到遍历完mem</p>
<ul>
<li>每次取两个字节</li>
<li>i从0到3，计算mem[i]的值，在<code>count_class_lookup16[mem16[i]]</code>中找到对应的取值付给<code>mem16[i]</code></li>
</ul>
<p>这样处理之后，对分支执行次数就会有一个简单的归类。例如，如果对某个测试用例处理时，分支A执行了32次；对另外一个测试用例，分支A执行了33次，那么AFL就会认为这两次的代码覆盖是相同的。当然，这样的简单分类肯定不能区分所有的情况，不过在某种程度上，处理了一些因为循环次数的微小区别，而误判为不同执行结果的情况</p>
<h4 id="count-bytes"><a href="#count-bytes" class="headerlink" title="count_bytes"></a>count_bytes</h4><p>初始化ret为0，循环读取mem里的值，每次读取4个字节到u32变量v中</p>
<ul>
<li>如果v是0，则代表这四个字节都是0，则继续</li>
<li>如果v不是0，则依次计算<code>v &amp; FF(0),v &amp; FF(1),v &amp; FF(2),v&amp;FF(3)</code>的结果，如果不为0，则计数器ret加一<ul>
<li><code>#define FF(_b) (0xff &lt;&lt; ((_b) &lt;&lt; 3))</code></li>
<li>也就是<code>0x000000ff</code>左移<code>(_b * 8)</code>位</li>
<li>最终结果可以是<code>0x000000ff</code>,<code>0x0000ff00</code>,<code>0x00ff0000</code>,<code>0xff000000</code>其中之一</li>
</ul>
</li>
</ul>
<h4 id="update-bitmap-score"><a href="#update-bitmap-score" class="headerlink" title="update_bitmap_score"></a>update_bitmap_score</h4><blockquote>
<p>每当发现新的路径，就调用这个函数来判断其是不是更加地favorable，这个favorable的意思是说是否包含最小的路径集合来遍历到所有bitmap中的位</p>
</blockquote>
<p>首先计算出这个case的fav_factor，计算方法是<code>q-&gt;exec_us * q-&gt;len</code>即执行时间和样例大小的乘积，以这两个指标来衡量权重</p>
<p>遍历trace_bits数组，如果该字节的值不为0，则代表这是已经被覆盖到的path</p>
<ul>
<li>然后检查对应于这个path的top_rated是否存在<ul>
<li>如果存在，则比较<code>fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len</code>，即比较执行时间和样例大小的乘积，哪个更小<ul>
<li>如果<code>top_rated[i]</code>的更小，则代表<code>top_rated[i]</code>的更优，不做任何处理，继续遍历下一个path</li>
<li>如果该path长度top_rated乘积更大，则将top_rated对应的tc_ref字段-1，并将其trace_mini字段置为空</li>
</ul>
</li>
<li>设置<code>top_rated[i]</code>为q，即当前case，也就是替换成最优，然后将其tc_ref的值加一</li>
<li>如果<code>q-&gt;trace_mini</code>为空，则将trace_bits经过<code>minimize_bits</code>压缩，然后存到trace_mini字段里</li>
<li>设置score_changed为1</li>
</ul>
</li>
</ul>
<h4 id="minimize-bits"><a href="#minimize-bits" class="headerlink" title="minimize_bits"></a>minimize_bits</h4><blockquote>
<p>压缩数据大小，将数据本身转换成位置记录下来（是否覆盖到和覆盖了多少次的byte，压缩成是否覆盖到的bit）</p>
</blockquote>
<p>这个就是个算法，算法意思就是如果15这里有值，正常存放到数组中，这样子就需要[14]，如果上亿个数的话，内存吃不消</p>
<p>所以就有了bitmap这个东西，运用bitmap的话，一个二进制数就代表对应的num是否有值，也就是上面的15，<code>0000000000000001</code>这样子就代表15有值</p>
<p>分8字节一组，byte[0]和byte[1]，15在byte[1]里，相对byte[1]里offset为7，设index为字节数组的下标，position为字节内部偏移</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">	<span class="type">int</span> index = num &gt;&gt; <span class="number">3</span>;<span class="comment">// num/8得到byte[]的index</span></span><br><span class="line">	<span class="type">int</span> position = num &amp; <span class="number">0x07</span>; <span class="comment">// num%8得到在byte[index]的位置</span></span><br><span class="line">	<span class="type">int</span> val = <span class="number">1</span> &lt;&lt; position;<span class="comment">//将1左移position后，那个位置自然就是1</span></span><br><span class="line">    byte[index] = byte[index] | val; <span class="comment">//，然后和以前的数据做|，这样，那个位置就替换成1了。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样子算下来就能精确的把二进制数据的15那个位置从0变成1</p>
<h4 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue"></a>cull_queue</h4><blockquote>
<p>精简队列</p>
</blockquote>
<p>如果设置了dumb_mode或没有设置scor_changed，直接返回</p>
<p>设置score_changed的值为0</p>
<p>将temp_v的值初始化成0xff，每位如果为1代表还没有被覆盖到，如果为0就代表已经被覆盖到了</p>
<p>设置queued_favored为0，pending_favored为0</p>
<p>遍历queue队列，设置其favored的值都为0</p>
<p>循环<code>MAP_SIZE</code>次</p>
<ul>
<li><p>判断该path对应的bit有没有被置位</p>
<ul>
<li><p>如果<code>top_rated[i]</code>有值，且该path在temp_v里被置位</p>
<ul>
<li>从temp_v中清除掉所有top_rated[i]覆盖到的path，将对应的bit设置为0</li>
</ul>
</li>
<li><p>设置<code>top_rated[i]-&gt;favored</code>为1，queued_favored计数器加一</p>
</li>
<li><p>如果<code>top_rated[i]</code>的was_fuzzed字段是0，代表其还没有fuzz过，则将pending_favored计数器加一</p>
</li>
</ul>
</li>
</ul>
<p>遍历queue</p>
<ul>
<li><p><code>mark_as_redundant</code></p>
</li>
<li><p>如果不是favored的case，就被标记成redundant_edges</p>
</li>
</ul>
<h4 id="mark-as-redundant"><a href="#mark-as-redundant" class="headerlink" title="mark_as_redundant"></a>mark_as_redundant</h4><p>如果<code>state和q-&gt;fs_redundant</code>相等，就直接返回</p>
<p>设置<code>q-&gt;fs_redundant</code>的值为state</p>
<p>如果state的值为1</p>
<ul>
<li>创建<code>out_dir/queue/.state/redundant_edges/fname</code></li>
</ul>
<p>如果state的值不为1</p>
<ul>
<li>尝试删除路径<code>out_dir/queue/.state/redundant_edges/fname</code></li>
</ul>
<h4 id="show-init-stats"><a href="#show-init-stats" class="headerlink" title="show_init_stats"></a>show_init_stats</h4><blockquote>
<p>在处理输入目录的末尾显示统计信息，以及一堆警告,以及几个硬编码的常量</p>
</blockquote>
<p>total_cal_us总轮次执行时间、total_cal_cycles总执行轮次，<code>avg_us = total_cal_us / total_cal_cycles</code>，计算出平均单轮执行时间avg_us</p>
<p>遍历queue</p>
<ul>
<li>更新<code>min_us、max_us、min_bits、max_bits、max_len</code></li>
</ul>
<p>如果avg_us大于10000就警告</p>
<p>如果avg_us大于50000，设置havoc_div为10</p>
<p>大于20000，设置havoc_div为5</p>
<p>如果大于10000，设置havoc_div为2</p>
<p>如果不是<code>resuming session</code>，则对queue的大小和个数超限提出警告，且如果<code>useless_at_start</code>不为0，就警告有可以精简的样本。</p>
<p>如果<code>timeout_given</code>为0</p>
<ul>
<li>根据<code>avg_us</code>来计算出<code>exec_tmout</code></li>
<li>avg_us的单位是微秒，而exec_tmout单位是毫秒，所以需要除以1000</li>
<li>在上面计算出来的<code>exec_tmout</code>和所有样例中执行时间最长的样例进行比较，取最大值赋给<code>exec_tmout</code></li>
<li>如果<code>exec_tmout</code>大于<code>EXEC_TIMEOUT</code>，就设置<code>exec_tmout = EXEC_TIMEOUT</code></li>
<li>设置<code>timeout_given</code>为1</li>
</ul>
<p>如果<code>timeout_give</code>不为0，且为3，代表这是<code>resuming session</code></p>
<p>如果是<code>dumb_mode</code>且没有设置环境变量<code>AFL_HANG_TMOUT</code></p>
<ul>
<li>设置<code>hang_tmout</code>为<code>EXEC_TIMEOUT</code>和<code>exec_tmout * 2 + 100</code>中的最小值</li>
</ul>
<h4 id="find-start-position"><a href="#find-start-position" class="headerlink" title="find_start_position"></a>find_start_position</h4><blockquote>
<p>主要作用为在resume时，尝试查找要开始的队列的位置</p>
</blockquote>
<p>如果不是<code>resuming_fuzz</code>，则直接返回</p>
<p>如果是in_place_resume,就打开<code>out_dir/fuzzer_stats</code>文件，否则打开<code>in_dir/../fuzzer_stats</code>文件</p>
<p>读文件内容到tmp中，找到<code>cur_path</code>，并设置为ret的值，如果大于<code>queued_paths</code>就设置ret为0，返回ret</p>
<h4 id="write-stats-file"><a href="#write-stats-file" class="headerlink" title="write_stats_file"></a>write_stats_file</h4><blockquote>
<p>更新统计信息文件以进行无人值守的监视</p>
</blockquote>
<p>创建<code>out_dir/fuzzer_stats</code>文件</p>
<p>打开并写入统计信息</p>
<ul>
<li>start_time<ul>
<li>fuzz运行的开始时间，start_time / 1000</li>
</ul>
</li>
<li>last_update<ul>
<li>当前时间</li>
</ul>
</li>
<li>fuzzer_pid<ul>
<li>获取当前pid</li>
</ul>
</li>
<li>cycles_done<ul>
<li><code>queue_cycle</code>在<code>queue_cur</code>为空，即执行到当前队列尾的时候才增加1，所以这代表queue队列被完全变异一次的次数。</li>
</ul>
</li>
<li>execs_done<ul>
<li>total_execs，target的总的执行次数，每次<code>run_target</code>的时候会增加1</li>
</ul>
</li>
<li>execs_per_sec<ul>
<li>每秒执行的次数</li>
</ul>
</li>
<li>paths_total<ul>
<li>queued_paths在每次<code>add_to_queue</code>的时候会增加1，代表queue里的样例总数</li>
</ul>
</li>
<li>paths_favored<ul>
<li>queued_favored，有价值的路径总数</li>
</ul>
</li>
<li>paths_found<ul>
<li>queued_discovered在每次<code>common_fuzz_stuff</code>去执行一次fuzz时，发现新的interesting case的时候会增加1，代表在fuzz运行期间发现的新queue entry。</li>
</ul>
</li>
<li>paths_imported<ul>
<li>queued_imported是master-slave模式下，如果sync过来的case是interesting的，就增加1</li>
</ul>
</li>
<li>max_depth<ul>
<li>最大路径深度</li>
</ul>
</li>
<li>cur_path<ul>
<li>current_entry一般情况下代表的是正在执行的queue entry的整数ID,queue首节点的ID是0</li>
</ul>
</li>
<li>pending_favs<ul>
<li>pending_favored 等待fuzz的favored paths数</li>
</ul>
</li>
<li>pending_total<ul>
<li>pending_not_fuzzed 在queue中等待fuzz的case数</li>
</ul>
</li>
<li>variable_paths<ul>
<li>queued_variable在<code>calibrate_case</code>去评估一个新的test case的时候，如果发现这个case的路径是可变的，则将这个计数器加一，代表发现了一个可变case</li>
</ul>
</li>
<li>stability</li>
<li>bitmap_cvg</li>
<li>unique_crashes<ul>
<li>unique_crashes这是在<code>save_if_interesting</code>时，如果fault是FAULT_CRASH，就将unique_crashes计数器加一</li>
</ul>
</li>
<li>unique_hangs<ul>
<li>unique_hangs这是在<code>save_if_interesting</code>时，如果fault是FAULT_TMOUT，且exec_tmout小于hang_tmout，就以hang_tmout为超时时间再执行一次，如果还超时，就让hang计数器加一。</li>
</ul>
</li>
<li>last_path<ul>
<li>在<code>add_to_queue</code>里将一个新case加入queue时，就设置一次last_path_time为当前时间，<code>last_path_time / 1000</code></li>
</ul>
</li>
<li>last_crash<ul>
<li>同上，在unique_crashes加一的时候，last_crash也更新时间，<code>last_crash_time / 1000</code></li>
</ul>
</li>
<li>last_hang<ul>
<li>同上，在unique_hangs加一的时候，last_hang也更新时间，<code>last_hang_time / 1000</code></li>
</ul>
</li>
<li>execs_since_crash<ul>
<li>total_execs - last_crash_execs,这里last_crash_execs是在上一次crash的时候的总计执行了多少次</li>
</ul>
</li>
<li>exec_tmout<ul>
<li>配置好的超时时间，有三种可能的配置方式，见上文</li>
</ul>
</li>
</ul>
<p>写入文件之后关闭文件</p>
<h4 id="save-auto"><a href="#save-auto" class="headerlink" title="save_auto"></a>save_auto</h4><blockquote>
<p>保存自动生成的extras</p>
</blockquote>
<p>如果<code>auto_changed</code>为0，则直接返回</p>
<p>如果不为0，就设置为0，然后创建名为<code>alloc_printf("%s/queue/.state/auto_extras/auto_%06u", out_dir, i);</code>的文件，并写入a_extras的内容</p>
<p>上面的前置结束之后，如果是终端环境，会睡4秒，开始时间会加上4秒</p>
<h3 id="Fuzz主循环"><a href="#Fuzz主循环" class="headerlink" title="Fuzz主循环"></a>Fuzz主循环</h3><p>在进行第一轮fuzz之后进入fuzz主循环</p>
<p>首先精简队列</p>
<p>如果<code>queue_cur</code>为空，代表所有queue都被执行完一轮</p>
<ul>
<li><p>设置<code>queue_cycle</code>计数器加一，即代表所有queue被完整执行了多少轮</p>
</li>
<li><p>设置<code>current_entry</code>为0，和<code>queue_cur</code>为queue首元素，开始新一轮fuzz</p>
</li>
<li><p>如果是<code>resume fuzz</code>情况，则先检查seek_to是否为空，如果不为空，就从seek_to指定的queue项开始执行</p>
</li>
<li><p>刷新展示界面<code>show_stats</code></p>
</li>
<li><p>如果执行一次完整的扫描之后，新发现的路径数与执行之前的一样，这代表没有发现任何新的路径</p>
<ul>
<li>如果<code>use_splicing</code>为1，就设置<code>cycles_wo_finds</code>计数器加1，本次扫描无新路径</li>
<li>否则<code>use_splicing</code>为1，代表我们接下来要通过splice重组queue里的case</li>
</ul>
</li>
<li><p>如果执行后和执行前路径数不一样，那么设置<code>cycles_wo_finds</code>为0</p>
</li>
<li><p>更新<code>prev_queued</code></p>
</li>
<li><p>如果设置了<code>sync_id</code>并且<code>queue_cycle==1</code>并且能过获取<code>AFL_IMPORT_FIRS</code>T环境变量</p>
<ul>
<li>利用<code>sync_fuzzers</code>读取其他sync文件夹下的queue文件，然后保存到自己的queue里</li>
</ul>
</li>
<li><p>执行<code>skipped_fuzz = fuzz_one(use_argv)</code>来对queue_cur进行一次测试，如果不执行返回1，否则返回0</p>
</li>
<li><p>如果skipped_fuzz为0，且存在sync_id</p>
<ul>
<li><code>sync_interval_cnt</code>计数器+1，对<code>SYNC_INTERVAL</code>(默认为5)求余，即如果是5的倍数</li>
<li>调用sync_fuzzers，同步其他fuzzers</li>
</ul>
</li>
<li><p><code>queue_cur = queue_cur-&gt;next;current_entry++;</code>，开始测试下一个queue</p>
</li>
</ul>
<h4 id="sync-fuzzers"><a href="#sync-fuzzers" class="headerlink" title="sync_fuzzers"></a>sync_fuzzers</h4><blockquote>
<p>读取其他sync文件夹下的queue文件，然后保存到自己的queue里</p>
</blockquote>
<p>打开<code>sync_dir</code>文件夹</p>
<p>循环读取文件夹下的目录和文件</p>
<ul>
<li>跳过<code>.</code>开头的文件和<code>sync_id</code>即我们自己的输出文件夹</li>
<li>尝试打开<code>sync_dir/sd_ent-&gt;d_name/queue</code></li>
<li>尝试打开<code>out_dir/.synced/sd_ent-&gt;d_name</code>，读取4个字节到min_accept中，设置<code>next_min_accept</code>为<code>min_accept</code>，这个值代表之前从这个文件夹里读取到的最后一个queue的id</li>
<li>设置stage_name为<code>sprintf(stage_tmp, "sync %u", ++sync_cnt);</code>，设置stage_cur为0，stage_max为0</li>
<li>循环读取<code>sync_dir/sd_ent-&gt;d_name/queue</code>文件夹里的目录和文件<ul>
<li>跳过<code>.</code>开头的文件和标识小于<code>min_accept</code>的文件，因为这些文件应该已经被sync过了</li>
<li>如果<code>syncing_case</code>标识大于等于<code>next_min_accept</code><ul>
<li><code>next_min_accept = syncing_case + 1</code></li>
</ul>
</li>
<li>打开<code>qd_path/qd_ent-&gt;d_name</code>这个路径<ul>
<li>如果文件大小不为0，且小于<code>MAX_FILE</code>，就不进行sync</li>
<li>否则mmap这个文件到内存mem里，通过<code>write_to_testcase</code>将mem写到<code>.cur_input</code>中</li>
<li><code>run_target</code>，运行对应文件，返回值赋值给fault</li>
<li>然后通过<code>save_if_interesting</code>来决定是否要导入这个文件到自己的queue里，如果发现了新的path，就导入<ul>
<li>syncing_party的值为<code>sd_ent-&gt;d_name</code></li>
<li>如果返回值为1，则<code>queued_imported</code>计数器+1</li>
</ul>
</li>
<li>stage_cur计数器加一，如果stage_cur是<code>stats_update_freq</code>的倍数，就刷新一次展示界面</li>
</ul>
</li>
<li>向当前id_fd中写入当前的<code>next_min_accept</code>值</li>
</ul>
</li>
<li>先读取有哪些fuzzer文件夹，然后读取其他fuzzer文件夹下的queue文件夹里的case，并依次执行，如果发现了新path，就保存到自己的queue文件夹里，而且将最后一个sync的case id写入到<code>.synced/其他fuzzer文件夹名</code>文件里，以避免重复运行</li>
</ul>
<h4 id="save-if-interesting"><a href="#save-if-interesting" class="headerlink" title="save_if_interesting"></a>save_if_interesting</h4><blockquote>
<p>这个case的执行结果是否是interesting的，决定是否保存或跳过</p>
</blockquote>
<p>设置keeping为0</p>
<p>如果fault为crash_mode</p>
<p><code>hnb = has_new_bits(virgin_bits)</code>，如果没有新的path发现或者path命中次数相同，就直接返回0</p>
<p>否则，将case保存到<code>fn = alloc_printf("%s/queue/id:%06u,%s", out_dir, queued_paths, describe_op(hnb))</code>文件里</p>
<p>利用add_to_queue将其添加到队列里</p>
<p>如果hnb的值是2，代表发现了新path，设置刚刚加入到队列里的queue的<code>has_new_cov</code>字段为1，即<code>queue_top-&gt;has_new_cov = 1</code>，然后<code>queued_with_cov</code>计数器加一</p>
<p>保存hash到其exec_cksum</p>
<p>评估这个queue</p>
<p>设置keeping值为1</p>
<p>根据fault结果进入不同的分支</p>
<ul>
<li>FAULT_TMOUT<ul>
<li>设置total_tmouts计数器加一</li>
<li>如果<code>unique_hangs</code>的个数超过能保存的最大数量<code>KEEP_UNIQUE_HANG</code>，就直接返回keeping的值</li>
<li>如果不是dumb mode，就<code>simplify_trace((u64 *) trace_bits)</code>进行规整</li>
<li>如果没有发现新的超时路径则返回keeping</li>
<li>否则，代表发现了新的超时路径，unique_tmouts计数器加一</li>
<li>如果<code>hang_tmout</code>大于<code>exec_tmout</code>，mem写入out_file，以<code>hang_tmout</code>为<code>timeout</code>，重新执行一次<code>runt_target</code><ul>
<li>如果结果不是<code>FAULT_TMOUT</code>，就返回keeping，否则就使<code>unique_hangs</code>计数器加一，然后更新last_hang_time的值，并保存到<code>alloc_printf("%s/hangs/id:%06llu,%s", out_dir, unique_hangs, describe_op(0))</code>文件</li>
</ul>
</li>
</ul>
</li>
<li>FAULT_CRASH<ul>
<li>Total_crashes计数器加一</li>
<li>如果unique_crashes大于能保存的最大数量<code>KEEP_UNIQUE_CRASH</code>即5000，就直接返回keeping的值</li>
<li>如果不是dumb_mode模式<ul>
<li>就<code>simplify_trace((u64 *) trace_bits)</code>进行规整</li>
</ul>
</li>
<li>如果没有发现新的路径，则返回keeping</li>
<li>如果发现了路径，则调用<code>write_crash_readme()</code>写<code>out_dir/crashes/README.txt</code></li>
<li>然后unique_crashes计数器加一，并将结果保存到<code>alloc_printf("%s/crashes/id:%06llu,sig:%02u,%s", out_dir,unique_crashes, kill_signal, describe_op(0))</code>文件</li>
<li>更新last_crash_time和last_crash_execs</li>
</ul>
</li>
</ul>
<h4 id="simplify-trace"><a href="#simplify-trace" class="headerlink" title="simplify_trace"></a>simplify_trace</h4><p>8字节一组读入，直到读取完mem</p>
<p>如果mem不为空</p>
<ul>
<li>i从0-7，<code>mem8[i] = simplify_lookup[mem8[i]]</code>，代表规整该路径的命中次数到指令值，这个路径如果没有命中，就设置为1，如果命中了，就设置为128，即二进制的<code>1000 0000</code></li>
<li>否则设置mem为<code>0x0101010101010101ULL</code>，即代表这8个字节代表的path都没有命中，每个字节的值被置为1</li>
</ul>
<h4 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one"></a>fuzz_one</h4><blockquote>
<p>从queue中取出entry进行fuzz，成功返回0，跳过或退出的话返回1</p>
</blockquote>
<p>如果<code>pending_favored</code>不为0，则对于queue_cur被fuzz过或者不是favored的，有99%的几率直接返回1</p>
<p>如果<code>pending_favored</code>为0，且不是dumb_mode模式，且本次case不是favored，且queue中的case数量大于10</p>
<ul>
<li><p>如果<code>queue_cycle</code>大于1并且没有被fuzz过的，75%的概率返回1</p>
</li>
<li><p>如果queue_cur被fuzz过，否则有95%的概率直接返回1</p>
</li>
</ul>
<p>打开testcase文件并设置len为<code>queue_cur-&gt;len</code></p>
<p>打开该case对应的文件，并通过mmap映射到内存里，地址赋值给<code>in_buf</code>和<code>orig_in</code></p>
<blockquote>
<p><strong>CALIBRATION阶段</strong></p>
</blockquote>
<p>假如当前项有校准错误，并且校准错误次数小于3次，那么就用calibrate_case再次校准。</p>
<blockquote>
<p><strong>TRIMMING阶段</strong></p>
</blockquote>
<p>测试用例有没有修剪过</p>
<p>如果不是dumb_mode模式，并且case没有经过修剪</p>
<p>调用函数<code>trim_case</code>进行修剪</p>
<p>设置queue_cur的trim_done为1，代表已经修剪</p>
<p>重新读取一次<code>queue_cur-&gt;len</code>到len中</p>
<p>将in_buf拷贝len个字节到out_buf中</p>
<blockquote>
<p><strong>PERFORMANCE SCORE阶段</strong></p>
</blockquote>
<p>是否已经经历过<code>deterministic</code>阶段，如果已经经历过，直接跳转至havoc阶段</p>
<p>调用<code>calculate_score</code>函数计算当前case的可取性得分</p>
<p>如果<code>skip_deterministic</code>为1，或者queue_cur被fuzz过，或者queue_cur的passed_det为1，则跳转去<code>havoc_stage</code>阶段</p>
<p>如果执行路径校验和将其置于此主实例的范围之外，则跳转至<code>havoc_stage</code></p>
<p>设置<code>doing_det</code>为1</p>
<blockquote>
<p><strong>SIMPLE BITFLIP (+dictionary construction)阶段</strong></p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLIP_BIT(_ar, _b) do { \</span></span><br><span class="line"><span class="meta">    u8* _arf = (u8*)(_ar); \</span></span><br><span class="line"><span class="meta">    u32 _bf = (_b); \</span></span><br><span class="line"><span class="meta">    _arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf) &amp; 7)); \</span></span><br><span class="line"><span class="meta">  } while (0)</span></span><br></pre></td></tr></tbody></table></figure>

<p>它的作用是将一个数组 <code>_ar</code> 中指定位置 <code>_b</code> 的二进制位（bit）进行翻转（0 变成 1，1 变成 0）将case中内容按位取反的变异过程</p>
<p>首先将 <code>_ar</code> 强制转换为一个 <code>u8</code> 指针，即无符号 8 位整型指针，举个例子，如果queue里面现在是abcdefg，那么第一组取值就为abcd</p>
<p><code>_ar的取值是out_buf,而_bf的取值在[0: len &lt;&lt; 3)</code>，所以用<code>_bf &amp; 7</code>能够得到<code>0,1,2...7 0,1,2...7</code>这样的取值一共len组</p>
<p>然后是<code>(128 &gt;&gt; ((_bf) &amp; 7))</code>也就是<code>128 &gt;&gt; 0 = 10000000, 128 &gt;&gt; 1 = 01000000....128 &gt;&gt; 7 = 00000001</code></p>
<p><code>_bf &gt;&gt; 3</code>就是8个全0+8个全1+8个全2+8个全3</p>
<p>最后是<code>_arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf) &amp; 7))</code>= <code>_arf[(_bf) &gt;&gt; 3] = _arf[(_bf) &gt;&gt; 3] ^ (128 &gt;&gt; ((_bf) &amp; 7))</code></p>
<p>_arf[0]为a，a的二进制为<code>97 = 01100001</code>，<code>_arf[0] = 01100001 ^ 10000000， _arf[0] = 01100001 ^ 01000000 .....</code></p>
<p>然后执行一次<code>common_fuzz_stuff</code>，然后再翻转回来</p>
<p>在进行bitflip 1/1变异时，对于每个byte的最低位(least significant bit)翻转还进行了额外的处理：如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致，那么就把这一段连续的bytes判断是一条token<br>比如对于SQL的<code>SELECT *</code>，如果<code>SELECT</code>被破坏，则肯定和正确的路径不一致，而被破坏之后的路径却肯定是一样的，比如<code>AELECT</code>和<code>SBLECT</code>，显然都是无意义的，而只有不破坏token，才有可能出现和原始执行路径一样的结果，所以AFL在这里就是在猜解关键字token</p>
<p>如果不是dumb_mode模式，并且<code>stage_cur &amp; 7 == 0</code></p>
<ul>
<li><code>stage_cur == 7、15...</code>，当翻转到每个字节最低有效位的时候进入分支</li>
<li>hash32运算，值记录在cksum中</li>
<li>如果循环到<code>stage_max - 1</code>，并且结果和上一次结果相同<ul>
<li>如果当前token数量小于32<ul>
<li>将当前字符作为token拼接到<code>a_collect[]</code>数组中</li>
</ul>
</li>
<li>如果token数量大于等于3，并且小于等于32<ul>
<li>调用<code>maybe_add_auto</code>将累计的<code>a_collect[]</code>数组中的内容添加到<code>a_extras[]</code>数组中</li>
</ul>
</li>
</ul>
</li>
<li>如果和上一次结果不相同<ul>
<li>如果token数量大于等于3，并且小于等于32<ul>
<li>调用<code>maybe_add_auto</code>将累计的<code>a_collect[]</code>数组中的内容添加到<code>a_extras[]</code>数组中</li>
</ul>
</li>
</ul>
</li>
<li>如果当前和原始路径不一样，则可能是因为token被破坏<ul>
<li>如果token数量小于32<ul>
<li>添加到a_collect数组中</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>stage_finds[STAGE_FLIP1]</code>的值加上在整个FLIP_BIT中新发现的路径和Crash总和</p>
<p><code>stage_cycles[STAGE_FLIP1]</code>的值加上在整个FLIP_BIT中执行的target次数<code>stage_max</code></p>
<p>设置<code>stage_name</code>为<code>bitflip 2/1</code>，这次是连续翻转相邻的两位，保存结果到<code>stage_finds[STAGE_FLIP2]和stage_cycles[STAGE_FLIP2]</code></p>
<p>设置stage_name为<code>bitflip 4/1</code>，翻转连续的四位并记录</p>
<p>在进行bitflip 8/8变异时，AFL还生成了一个非常重要的信息：<code>effector map</code>。这个<code>effector map</code>几乎贯穿了整个<code>deterministic fuzzing</code>的始终</p>
<p>具体地，在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在<code>effector map</code>中标记为1，即“有效”的，否则标记为0，即”无效的。</p>
<p>这样做的逻辑是：如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考<code>effectormap</code>，跳过那些”无效”的byte，从而节省了执行资源</p>
<p>由此，通过极小的开销（没有增加额外的执行次数），AFL又一次对文件格式进行了启发式的判断</p>
<p>不过，在某些情况下并不会检测有效字符。第一种情况就是dumb mode或者从fuzzer，此时文件所有的字符都有可能被变异</p>
<p>设置stage_name为<code>bitflip 8/8</code>，以字节为单位，直接通过和<code>0xff</code>亦或运算去翻转整个字节的位，然后执行一次，并记录</p>
<ul>
<li>调用<code>common_fuzz_stuff</code>对变异后数据进行测试，记录interesting</li>
<li>如果<code>eff_map[stage_cur&gt;&gt;3]</code>为0<ul>
<li>如果不是dumb_mode模式并且len大于等于128<ul>
<li>计算cksum</li>
</ul>
</li>
<li>否则如果是dumb_mode模式或len小于128<ul>
<li>cksum等于<code>~queue_cur-&gt;exec_cksum</code></li>
</ul>
</li>
<li>如果<code>cksum != queue_cur-&gt;exec_cksum</code><ul>
<li>则代表产生了新的路径，此时对应的eff_map中的项标记为1</li>
</ul>
</li>
<li>接着复位+记录</li>
</ul>
</li>
</ul>
<p>设置stage_name为<code>bitflip 16/8</code>，设置<code>stage_max</code>为<code>len - 1</code>，以字为单位和<code>0xffff</code>进行亦或运算，连续两byte翻转</p>
<ul>
<li>这里要注意在翻转之前会先检查eff_map里对应于这两个字节的标志是否为0，如果为0，则这两个字节是无效的数据，stage_max减一，然后开始变异下一个字</li>
<li>变异完成之后，还原</li>
</ul>
<p>设置stage_name为<code>bitflip 32/8</code>，然后设置<code>stage_max</code>为<code>len - 3</code>，以双字为单位，直接通过和<code>0xffffffff</code>亦或运算去相邻四个字节的位，连续四个byte翻转，然后执行一次，并记录</p>
<ul>
<li>在每次翻转之前会检查eff_map里对应于这四个字节的标志是否为0，如果是0，则这两个字节是无效的数据，stage_max减一，然后开始变异下一组双字</li>
</ul>
<blockquote>
<p>ARITHMETIC INC/DEC阶段</p>
</blockquote>
<p>加减变异，会对目标整数进行<code>+1、+2…+35，-1、-2…-35</code>，由于整数存在大端序和小端序两种表现形式，所以这个阶段会对两种端序进行变异</p>
<p>这个和上面的bitflip有相似的过程，目标大小的不同，也分为了多个子阶段</p>
<p>这个阶段有两个非常智能的做法，第一个是前面提到的<code>effector map</code>：如果一个整数的所有bytes都被判断为”无效”，那么就跳过对整数的变异。第二种情况是之前bitflip已经生成过的变异：如果加/减某个数后，其效果与之前的某种bitflip相同，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行</p>
<p>设置<code>stage_name</code>为<code>arith 8/8</code>，每次对8个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个byte进行整数加减变异</p>
<p>设置<code>stage_name</code>为<code>arith 16/8</code>，每次对16个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个word进行整数加减变异</p>
<p>设置<code>stage_name</code>为<code>arith 32/8</code>，每次对32个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个dword进行整数加减变异</p>
<blockquote>
<p>INTERESTING VALUES 阶段</p>
</blockquote>
<p>将out_buf中的字节替换成AFL内部预设的数值</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> s8 interesting_8[] = {INTERESTING_8};</span><br><span class="line"><span class="type">static</span> s16 interesting_16[] = {INTERESTING_8, INTERESTING_16};</span><br><span class="line"><span class="type">static</span> s32 interesting_32[] = {INTERESTING_8, INTERESTING_16, INTERESTING_32};</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>interest 8/8，每次对8个bit进替换，按照每8个bit的步长从头开始，即对文件的每个byte进行替换</li>
<li>interest 16/8，每次对16个bit进替换，按照每8个bit的步长从头开始，即对文件的每个word进行替换</li>
<li>interest 32/8，每次对32个bit进替换，按照每8个bit的步长从头开始，即对文件的每个dword进行替换</li>
</ul>
<p>这个变异同样很智能，<code>effector map</code>仍然会用于判断是否需要变异；此外，如果某个<code>interesting value</code>，是可以通过<code>bitflip</code>或者<code>arithmetic</code>变异达到，那么这样的重复性变异也是会跳过的</p>
<blockquote>
<p>DICTIONARY STUFF阶段</p>
</blockquote>
<p>用户提供的tokens，是在词典文件中设置并通过-x选项指定的，如果没有则跳过相应的子阶段</p>
<ul>
<li>user extras(over),从头开始,将用户提供的tokens依次替换到原文件中,stage_max为<code>extras_cnt * len</code></li>
<li>user extras(insert),从头开始,将用户提供的tokens依次插入到原文件中,stage_max为<code>extras_cnt * len</code></li>
<li>auto extras(over),从头开始,将自动检测的tokens依次替换到原文件中,stage_max为<code>MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len</code></li>
</ul>
<blockquote>
<p>RANDOM HAVOC阶段</p>
</blockquote>
<p>这个阶段就是dumb_mode和从fuzzer一开始就经历的阶段，充满各种随机性，对原文件进行大量变异</p>
<ul>
<li>随机选取某个bit进行翻转</li>
<li>随机选取某个byte，将其设置为随机的interesting value</li>
<li>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</li>
<li>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</li>
<li>随机选取某个byte，对其减去一个随机数</li>
<li>随机选取某个byte，对其加上一个随机数</li>
<li>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</li>
<li>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</li>
<li>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</li>
<li>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</li>
<li>随机选取某个byte，将其设置为随机数</li>
<li>随机删除一段bytes</li>
<li>随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</li>
<li>随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</li>
<li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</li>
<li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</li>
<li>怎么样，看完上面这么多的“随机”，有没有觉得晕？还没完，AFL会生成一个随机数，作为变异组合的数量，并根据这个数量，每次从上面那些方式中随机选取一个（可以参考高中数学的有放回摸球），依次作用到文件上。如此这般丧心病狂的变异，原文件就大概率面目全非了，而这么多的随机性，也就成了fuzzing过程中的不可控因素，即所谓的“看天吃饭”了。</li>
<li>splice</li>
<li>设置ret_val的值为0</li>
<li>如果queue_cur通过了评估，且was_fuzzed字段是0，就设置<code>queue_cur-&gt;was_fuzzed</code>为1，然后pending_not_fuzzed计数器减一</li>
<li>如果queue_cur是favored, pending_favored计数器减一</li>
</ul>
<blockquote>
<p>SPLICING 阶段</p>
</blockquote>
<p>RANDOM HAVOC阶段后没有什么效果，那么就会进入到SPLICING阶段，尝试拼接两个测试用例中的内容，拼接之后重新走一遍RANDOM HAVOC阶段</p>
<p>至此，第一轮变异完成，开始第二轮</p>
<h4 id="trim-case"><a href="#trim-case" class="headerlink" title="trim_case"></a>trim_case</h4><p>直接这个case的大小len小于5字节，就直接返回</p>
<p>设置<code>stage_name</code>的值为tmp，在<code>bytes_trim_in</code>的值里加上len，<code>bytes_trim_in</code>代表被trim过的字节数</p>
<p>len_p2，其值是大于等于q-&gt;len的第一个2的幂次</p>
<p>取<code>len_p2的1/16</code>为remove_len，这是起始步长</p>
<p>进入while循环，终止条件是remove_len小于终止步长<code>len_p2的1/1024</code>,<strong>每轮循环步长会除2</strong></p>
<ul>
<li><p>设置remove_pos的值为remove_len</p>
</li>
<li><p><code>stage_name = trim 512/512</code></p>
</li>
<li><p>设置stage_cur为0，stage_max为<code>q-&gt;len / remove_len</code></p>
</li>
<li><p><code>remove_pos &lt; q-&gt;len</code>,即每次前进remove_len个步长，直到整个文件都被遍历完为止</p>
<ul>
<li><p>由in_buf中<code>remove_pos</code>处开始，向后跳过<code>remove_len</code>个字节，写入到<code>.cur_input</code>里，然后运行一次<code>fault = run_target</code>，trim_execs计数器加一</p>
</li>
<li><p>如果主动中断，或返回值报错，直接跳转至<code>abort_trimming</code></p>
</li>
<li><p>由所得trace_bits计算出一个cksum，和<code>q-&gt;exec_cksum</code>比较</p>
<ul>
<li>如果相等<ul>
<li>从<code>q-&gt;len</code>中减去remove_len个字节，并由此重新计算出一个<code>len_p2</code>，这里注意一下<code>while (remove_len &gt;= MAX(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES))</code></li>
<li>将<code>in_buf+remove_pos+remove_len</code>到最后的字节，前移到<code>in_buf+remove_pos</code>处，等于删除了remove_pos向后的remove_len个字节</li>
<li>如果needs_write为0，则设置其为1，并保存当前trace_bits到clean_trace中</li>
</ul>
</li>
<li>如果不相等<ul>
<li>remove_pos加上remove_len，即前移remove_len个字节。<strong>注意，如果相等，就无需前移</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>注意trim过程可能比较慢，所以每执行<code>stats_update_freq</code>次，就刷新一次显示界面<code>show_stats</code></p>
</li>
<li><p>stage_cur加一</p>
</li>
</ul>
</li>
</ul>
<p>如果needs_write为1</p>
<ul>
<li>删除原来的q-&gt;fname，创建一个新的q-&gt;fname，将in_buf里的内容写入，然后用clean_trace恢复trace_bits的值。</li>
<li>进行一次<code>update_bitmap_score</code></li>
</ul>
<p>返回fault</p>
<h4 id="calculate-score"><a href="#calculate-score" class="headerlink" title="calculate_score"></a>calculate_score</h4><blockquote>
<p>根据queue entry的执行速度、覆盖到的path数和路径深度来评估出一个得分，这个得分perf_score在后面havoc的时候使用</p>
</blockquote>
<p>计算平均时间、bitmap大小、设置初始perf_score为100</p>
<ul>
<li>处理输入时<ul>
<li>在<code>read_testcases</code>的时候会调用<code>add_to_queue</code>，此时所有的<code>input case</code>的<code>queue depth</code>都会被设置为1`</li>
</ul>
</li>
<li>fuzz_one时<ul>
<li>然后在后面fuzz_one的时候，会先设置cur_depth为当前queue的depth，然后这个queue经过mutate之后调用<code>save_if_interesting</code>,如果是<code>interesting case</code>，就会被<code>add_to_queue</code>，此时就建立起了queue之间的关联关系，所以由当前queue变异加入的新queue，深度都在当前queue的基础上再增加</li>
</ul>
</li>
</ul>
<h4 id="common-fuzz-stuff"><a href="#common-fuzz-stuff" class="headerlink" title="common_fuzz_stuff"></a>common_fuzz_stuff</h4><blockquote>
<p>简单的说就是写入文件并执行，然后处理结果，如果出现错误，就返回1</p>
</blockquote>
<p>如果定义了<code>post_handler</code>,就通过<code>out_buf = post_handler(out_buf, &amp;len)</code>处理一下out_buf，如果out_buf或者len有一个为0，则直接返回0，<strong>对变异完的queue，最一层包装在写入的时候非常有用</strong></p>
<p><code>write_to_testcase</code>写入.cur_input</p>
<p><code>fault = run_target(argv, exec_tmout)</code></p>
<p>如果fault是<code>FAULT_TMOUT</code></p>
<ul>
<li>如果<code>subseq_tmouts++ &gt; TMOUT_LIMIT</code>（默认250），就将<code>cur_skipped_paths</code>加一，直接返回1</li>
<li><code>subseq_tmout</code>是连续超时数</li>
</ul>
<p>否则设置<code>subseq_tmout</code>为0</p>
<p>如果<code>skip_requested</code>为1</p>
<ul>
<li>设置<code>skip_requested</code>为0，然后将<code>cur_skipped_paths</code>加一，直接返回1</li>
</ul>
<p>如果发现了新的路径，<code>queued_discovered+1</code></p>
<p>如果<code>stage_cur</code>除以<code>stats_update_freq</code>余数是0，或者其加一等于<code>stage_max</code>，就更新展示界面show_stats</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AFL_fuzz核心代码都调试结束了，还有afl-clang-fast，后续如果有时间会继续</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://eternalsakura13.com/2020/08/23/afl/">https://eternalsakura13.com/2020/08/23/afl/</a></p>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/1732/#331-fuzz_one">https://paper.seebug.org/1732/#331-fuzz_one</a></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/z1r00?tab=repositories">Projects</a></li>
         
          <li><a href="/links/">links</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">AFL_fuzz源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-gcc"><span class="toc-number">1.1.</span> <span class="toc-text">afl-gcc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#find-as"><span class="toc-number">1.1.1.</span> <span class="toc-text">find_as</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#edit-params"><span class="toc-number">1.1.2.</span> <span class="toc-text">edit_params</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">1.1.3.</span> <span class="toc-text">final</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-as"><span class="toc-number">1.2.</span> <span class="toc-text">afl-as</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#edit-params-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">edit_params</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add-instrumentation"><span class="toc-number">1.2.2.</span> <span class="toc-text">add_instrumentation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-fuzz"><span class="toc-number">1.3.</span> <span class="toc-text">afl-fuzz</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.1.</span> <span class="toc-text">初始配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#setup-signal-handlers"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">setup_signal_handlers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#check-asan-opts"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">check_asan_opts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fix-up-sync"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">fix_up_sync</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#save-cmdline"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">save_cmdline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fix-up-banner"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">fix_up_banner</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#check-if-tty"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">check_if_tty</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-core-count"><span class="toc-number">1.3.1.7.</span> <span class="toc-text">get_core_count</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bind-to-free-cpu"><span class="toc-number">1.3.1.8.</span> <span class="toc-text">bind_to_free_cpu</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#check-crash-handling"><span class="toc-number">1.3.1.9.</span> <span class="toc-text">check_crash_handling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#check-cpu-governor"><span class="toc-number">1.3.1.10.</span> <span class="toc-text">check_cpu_governor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setup-post"><span class="toc-number">1.3.1.11.</span> <span class="toc-text">setup_post</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setup-shm"><span class="toc-number">1.3.1.12.</span> <span class="toc-text">setup_shm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init-count-class16"><span class="toc-number">1.3.1.13.</span> <span class="toc-text">init_count_class16</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setup-dirs-fds"><span class="toc-number">1.3.1.14.</span> <span class="toc-text">setup_dirs_fds</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#read-testcases"><span class="toc-number">1.3.1.15.</span> <span class="toc-text">read_testcases</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#add-to-queue"><span class="toc-number">1.3.1.16.</span> <span class="toc-text">add_to_queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#load-auto"><span class="toc-number">1.3.1.17.</span> <span class="toc-text">load_auto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pivot-inputs"><span class="toc-number">1.3.1.18.</span> <span class="toc-text">pivot_inputs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#load-extras"><span class="toc-number">1.3.1.19.</span> <span class="toc-text">load_extras</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find-timeout"><span class="toc-number">1.3.1.20.</span> <span class="toc-text">find_timeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#detect-file-args"><span class="toc-number">1.3.1.21.</span> <span class="toc-text">detect_file_args</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setup-stdio-file"><span class="toc-number">1.3.1.22.</span> <span class="toc-text">setup_stdio_file</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#check-binary"><span class="toc-number">1.3.1.23.</span> <span class="toc-text">check_binary</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-cur-time"><span class="toc-number">1.3.1.24.</span> <span class="toc-text">get_cur_time</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#perform-dry-run"><span class="toc-number">1.3.1.25.</span> <span class="toc-text">perform_dry_run</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#calibrate-case"><span class="toc-number">1.3.1.26.</span> <span class="toc-text">calibrate_case</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init-forkserver"><span class="toc-number">1.3.1.27.</span> <span class="toc-text">init_forkserver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#has-new-bits"><span class="toc-number">1.3.1.28.</span> <span class="toc-text">has_new_bits</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#run-target"><span class="toc-number">1.3.1.29.</span> <span class="toc-text">run_target</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#classify-counts"><span class="toc-number">1.3.1.30.</span> <span class="toc-text">classify_counts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#count-bytes"><span class="toc-number">1.3.1.31.</span> <span class="toc-text">count_bytes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update-bitmap-score"><span class="toc-number">1.3.1.32.</span> <span class="toc-text">update_bitmap_score</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#minimize-bits"><span class="toc-number">1.3.1.33.</span> <span class="toc-text">minimize_bits</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cull-queue"><span class="toc-number">1.3.1.34.</span> <span class="toc-text">cull_queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mark-as-redundant"><span class="toc-number">1.3.1.35.</span> <span class="toc-text">mark_as_redundant</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#show-init-stats"><span class="toc-number">1.3.1.36.</span> <span class="toc-text">show_init_stats</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find-start-position"><span class="toc-number">1.3.1.37.</span> <span class="toc-text">find_start_position</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#write-stats-file"><span class="toc-number">1.3.1.38.</span> <span class="toc-text">write_stats_file</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#save-auto"><span class="toc-number">1.3.1.39.</span> <span class="toc-text">save_auto</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fuzz%E4%B8%BB%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.2.</span> <span class="toc-text">Fuzz主循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-fuzzers"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">sync_fuzzers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#save-if-interesting"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">save_if_interesting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#simplify-trace"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">simplify_trace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fuzz-one"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">fuzz_one</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#trim-case"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">trim_case</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#calculate-score"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">calculate_score</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#common-fuzz-stuff"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">common_fuzz_stuff</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">1.5.</span> <span class="toc-text">Reference</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;text=AFL_fuzz源码分析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=AFL_fuzz源码分析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;is_video=false&amp;description=AFL_fuzz源码分析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=AFL_fuzz源码分析&amp;body=Check out this article: http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=AFL_fuzz源码分析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=AFL_fuzz源码分析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=AFL_fuzz源码分析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=AFL_fuzz源码分析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;name=AFL_fuzz源码分析&amp;description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;t=AFL_fuzz源码分析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright ©
    
    
    2021-2023
    z1r0
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/z1r00?tab=repositories">Projects</a></li><!--
     --><!--
       --><li><a href="/links/">links</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'">


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->



<script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>