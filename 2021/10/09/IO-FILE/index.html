<!DOCTYPE html><html lang="en"><head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    <meta name="description" content="io file这一部分的知识，因为发现之前接触的太浅了 这一次源码级调试一下，看一下各种各样的io结构的原理，笔者这里照着这个师傅调试的 本文章基本算是转载这位师傅的，转载！  IO FILE怎么源码级调试？这里笔者直接用的pwndbg里面的dir将glibc的源码带到了调试里。dir /glibc-2.23/libio/，需要注意的是启动gdb的时候需要这样：gdb 文件名，这样就可以愉快的调">
<meta property="og:type" content="article">
<meta property="og:title" content="IO_FILE">
<meta property="og:url" content="http://example.com/2021/10/09/IO-FILE/index.html">
<meta property="og:site_name" content="z1r0's blog">
<meta property="og:description" content="io file这一部分的知识，因为发现之前接触的太浅了 这一次源码级调试一下，看一下各种各样的io结构的原理，笔者这里照着这个师傅调试的 本文章基本算是转载这位师傅的，转载！  IO FILE怎么源码级调试？这里笔者直接用的pwndbg里面的dir将glibc的源码带到了调试里。dir /glibc-2.23/libio/，需要注意的是启动gdb的时候需要这样：gdb 文件名，这样就可以愉快的调">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/10/09/IO-FILE/18.png">
<meta property="article:published_time" content="2021-10-09T06:20:04.000Z">
<meta property="article:modified_time" content="2023-08-17T06:31:50.971Z">
<meta property="article:author" content="z1r0">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/10/09/IO-FILE/18.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>IO_FILE</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="z1r0's blog" type="application/atom+xml">
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.1.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/z1r00?tab=repositories">Projects</a></li><!--
     --><!--
       --><li><a href="/links/">links</a></li><!--
     -->
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2021/10/09/IO-FILE-2-23%E5%8A%AB%E6%8C%81vtable%E5%8F%8AFSOP/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2021/09/28/pwn%E9%A2%98%E6%9B%B4%E6%8D%A2%E9%A2%98%E7%9B%AElibc%E7%89%88%E6%9C%AC/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2021/10/09/IO-FILE/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2021/10/09/IO-FILE/&amp;text=IO_FILE"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2021/10/09/IO-FILE/&amp;title=IO_FILE"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2021/10/09/IO-FILE/&amp;is_video=false&amp;description=IO_FILE"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=IO_FILE&amp;body=Check out this article: http://example.com/2021/10/09/IO-FILE/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2021/10/09/IO-FILE/&amp;title=IO_FILE"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2021/10/09/IO-FILE/&amp;title=IO_FILE"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2021/10/09/IO-FILE/&amp;title=IO_FILE"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2021/10/09/IO-FILE/&amp;title=IO_FILE"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2021/10/09/IO-FILE/&amp;name=IO_FILE&amp;description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2021/10/09/IO-FILE/&amp;t=IO_FILE"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IO-FILE"><span class="toc-number">1.</span> <span class="toc-text">IO FILE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#fopen"><span class="toc-number">1.1.</span> <span class="toc-text">fopen</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.1.</span> <span class="toc-text">malloc分配内存空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-no-init%E5%AF%B9file%E7%BB%93%E6%9E%84%E4%BD%93%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.</span> <span class="toc-text">_IO_no_init对file结构体进行初始化操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-file-init%E5%B0%86%E7%BB%93%E6%9E%84%E4%BD%93%E9%93%BE%E6%8E%A5%E5%88%B0-IO-list-all"><span class="toc-number">1.1.3.</span> <span class="toc-text">_IO_file_init将结构体链接到_IO_list_all</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-file-fopen%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84"><span class="toc-number">1.1.4.</span> <span class="toc-text">_IO_file_fopen打开文件句柄</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fread"><span class="toc-number">1.2.</span> <span class="toc-text">fread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">初始化输入缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.2.</span> <span class="toc-text">拷贝输入缓冲区数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.3.</span> <span class="toc-text">执行系统调用读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">其他输入函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fwrite"><span class="toc-number">1.3.</span> <span class="toc-text">fwrite</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E7%9B%AE%E6%A0%87%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E8%87%B3%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.3.1.</span> <span class="toc-text">将目标输出数据拷贝至输出缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA%E6%88%96flush%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.3.2.</span> <span class="toc-text">建立输出缓冲区或flush输出缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%9D%97%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.3.</span> <span class="toc-text">以块为单位直接输出数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E7%9B%AE%E6%A0%87%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E6%94%BE%E5%85%A5%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD"><span class="toc-number">1.3.4.</span> <span class="toc-text">剩余目标输出数据放入输出缓冲区中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">其他输出函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">1.4.</span> <span class="toc-text">Reference</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope="" itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        IO_FILE
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <span itemprop="name">z1r0</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-10-09T06:20:04.000Z" itemprop="datePublished">2021-10-09</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/study/">study</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/pwn/" rel="tag">pwn</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <blockquote>
<p>io file这一部分的知识，因为发现之前接触的太浅了</p>
<p>这一次源码级调试一下，看一下各种各样的io结构的原理，笔者这里照着这个<a target="_blank" rel="noopener" href="https://ray-cp.github.io/">师傅</a>调试的</p>
<p>本文章基本算是转载这位<a target="_blank" rel="noopener" href="https://ray-cp.github.io/">师傅</a>的，转载！</p>
</blockquote>
<h1 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="IO FILE"></a>IO FILE</h1><p>怎么源码级调试？这里笔者直接用的pwndbg里面的dir将glibc的源码带到了调试里。<code>dir /glibc-2.23/libio/</code>，需要注意的是启动gdb的时候需要这样：<code>gdb 文件名</code>，这样就可以愉快的调试啦。</p>
<p>需要先理解一下什么是IO FILE。进程中的FILE结构会通过_chain域链接形成一个链表。链表头部用全局变量__IO_list_all表示。一个程序启动时有三个文件流是打开的：stderr，stdout，stdin。这三个文件流位于libc.so数据段，<code>__IO_FILE</code>结构外包裹着另一种结构<code>__IO_FILE_plus</code>。如下</p>
<p><img src="/2021/10/09/IO-FILE/18.png"></p>
<h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><p>一个简单的fopen程序2.23下的libc。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    FILE*fp = fopen(<span class="string">"test"</span>,<span class="string">"wb"</span>);</span><br><span class="line">    <span class="type">char</span> *ptr = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>gdb启动完成之后s进去就可以看到fopen实际上是<code>_IO_new_fopen</code>函数。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">94</span> _IO_FILE *</span><br><span class="line">   <span class="number">95</span> _IO_new_fopen (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span><br><span class="line">   <span class="number">96</span> {</span><br><span class="line">►  <span class="number">97</span>   <span class="keyword">return</span> __fopen_internal (filename, mode, <span class="number">1</span>);</span><br><span class="line">   <span class="number">98</span> }</span><br></pre></td></tr></tbody></table></figure>

<p>从上面的源码中可以很清楚的看到又调用了<code>__fopen_internal</code>函数。看一下源码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">__fopen_internal (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode, <span class="type">int</span> is32)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  } *new_f = (<span class="keyword">struct</span> locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_file_init (&amp;new_f-&gt;fp);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>  !_IO_UNIFIED_JUMPTABLES</span></span><br><span class="line">  new_f-&gt;fp.vtable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line">locked_FILE</span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><code>malloc</code>分配内存空间。</li>
<li><code>_IO_no_init</code> 对file结构体进行<code>null</code>初始化。</li>
<li><code>_IO_file_init</code>将结构体链接进<code>_IO_list_all</code>链表。</li>
<li><code>_IO_file_fopen</code>执行系统调用打开文件</li>
</ol>
<h3 id="malloc分配内存空间"><a href="#malloc分配内存空间" class="headerlink" title="malloc分配内存空间"></a>malloc分配内存空间</h3><p>首先malloc了一个<code>struct locked_FILE</code>大小的结构体，这个结构体内有<code>_IO_FILE_plus</code>、<code>_IO_lock_t</code>、<code>_IO_wide_data</code>这三个结构，其中<code>_IO_FILE_plus</code>为使用的<code>IO_FILE</code>结构体。malloc之后会发现都为0，很明显的可以看到这个结构体的大小为0x230。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p new_f</span><br><span class="line">$<span class="number">2</span> = (<span class="keyword">struct</span> locked_FILE *) <span class="number">0x55555555b010</span></span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x55555555b010</span> - <span class="number">0x10</span></span><br><span class="line"><span class="number">0x55555555b000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000231</span></span><br><span class="line"><span class="number">0x55555555b010</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55555555b020</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55555555b030</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55555555b040</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55555555b050</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55555555b060</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55555555b070</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55555555b080</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55555555b090</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="IO-no-init对file结构体进行初始化操作"><a href="#IO-no-init对file结构体进行初始化操作" class="headerlink" title="_IO_no_init对file结构体进行初始化操作"></a>_IO_no_init对file结构体进行初始化操作</h3><p>继续住下走会调用<code>_IO_no_init</code>这个函数对上面的结构体进行初始化操作，这个文件在<code>libio/genops.c</code>。跟着源码还可以看到的是还利用了<code>_IO_old_init</code>这个函数对flags这些进行初始化。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_no_init (_IO_FILE *fp, <span class="type">int</span> flags, <span class="type">int</span> orientation,</span><br><span class="line">	     <span class="keyword">struct</span> _IO_wide_data *wd, <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *jmp)</span><br><span class="line">{</span><br><span class="line">  _IO_old_init (fp, flags);</span><br><span class="line">  fp-&gt;_mode = orientation;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="keyword">if</span> (orientation &gt;= <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      fp-&gt;_wide_data = wd;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;</span><br><span class="line">    }</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* Cause predictable crash when a wide function is called on a byte</span></span><br><span class="line"><span class="comment">       stream.  */</span></span><br><span class="line">    fp-&gt;_wide_data = (<span class="keyword">struct</span> _IO_wide_data *) <span class="number">-1L</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  fp-&gt;_freeres_list = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_IO_old_init (_IO_FILE *fp, <span class="type">int</span> flags)</span><br><span class="line">{</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|flags;</span><br><span class="line">  fp-&gt;_flags2 = <span class="number">0</span>;</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_chain = <span class="literal">NULL</span>; <span class="comment">/* Not necessary. */</span></span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_markers = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_cur_column = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _IO_JUMPS_OFFSET</span></span><br><span class="line">  fp-&gt;_vtable_offset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_init (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>看一下最后的file结构被初始化成什么样子了。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p new_f-&gt;fp</span><br><span class="line">$<span class="number">4</span> = {</span><br><span class="line">  file = {</span><br><span class="line">    _flags = <span class="number">-72548352</span>,</span><br><span class="line">    _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_buf_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_buf_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line">    _markers = <span class="number">0x0</span>,</span><br><span class="line">    _chain = <span class="number">0x0</span>,</span><br><span class="line">    _fileno = <span class="number">0</span>,</span><br><span class="line">    _flags2 = <span class="number">0</span>,</span><br><span class="line">    _old_offset = <span class="number">0</span>,</span><br><span class="line">    _cur_column = <span class="number">0</span>,</span><br><span class="line">    _vtable_offset = <span class="number">0</span> <span class="string">'\000'</span>,</span><br><span class="line">    _shortbuf = <span class="string">""</span>,</span><br><span class="line">    _lock = <span class="number">0x55555555b0f0</span>,</span><br><span class="line">    _offset = <span class="number">0</span>,</span><br><span class="line">    _codecvt = <span class="number">0x0</span>,</span><br><span class="line">    _wide_data = <span class="number">0x55555555b100</span>,</span><br><span class="line">    _freeres_list = <span class="number">0x0</span>,</span><br><span class="line">    _freeres_buf = <span class="number">0x0</span>,</span><br><span class="line">    __pad5 = <span class="number">0</span>,</span><br><span class="line">    _mode = <span class="number">0</span>,</span><br><span class="line">    _unused2 = <span class="string">'\000'</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  },</span><br><span class="line">  vtable = <span class="number">0x0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="IO-file-init将结构体链接到-IO-list-all"><a href="#IO-file-init将结构体链接到-IO-list-all" class="headerlink" title="_IO_file_init将结构体链接到_IO_list_all"></a><code>_IO_file_init</code>将结构体链接到<code>_IO_list_all</code></h3><p>结束<code>_IO_no_init</code>之后我们可以看到回到了<code>__fopen_internal</code>并继续执行<code>_IO_file_init</code>这个函数，跟进看一下是干什么的，跟进之后是<code>/libio/fileops.c</code>这个文件里的<code>_IO_new_file_init</code>。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_init (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">{</span><br><span class="line">  <span class="comment">/* POSIX.1 allows another file handle to be used to change the position</span></span><br><span class="line"><span class="comment">     of our file descriptor.  Hence we actually don't know the actual</span></span><br><span class="line"><span class="comment">     position before we do the first fseek (and until a following fflush). */</span></span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._IO_file_flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  fp-&gt;file._fileno = <span class="number">-1</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>这个函数主要调用了<code>_IO_link_in</code>这个函数，继续跟进这个函数，<code>libio/genops.c</code>里面的<code>_IO_link_in</code>。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_link_in (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (_IO_FILE *) fp;</span><br><span class="line">      _IO_flockfile ((_IO_FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line">      ++_IO_list_all_stamp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((_IO_FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先这个if是判断flag的标志位是否是<code>_IO_LINKED</code>，这个有什么用呢？FILE结构体是通过<code>_IO_list_all</code>的单链表进行管理的，如果这个结构体没有<code>_IO_LINKED</code>就说明这个结构体没有链接进入<code>_IO_list_all</code>。后面把它链接进入<code>_IO_list_all</code>链表，同时设置FILE结构体的<code>_chain</code>字段为之前的链表的值，否则直接返回。所以<code>_IO_file_init</code>主要功能是将FILE结构体链接进入<code>_IO_list_all</code>链表。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p _IO_list_all</span><br><span class="line">$<span class="number">6</span> = (<span class="keyword">struct</span> _IO_FILE_plus *) <span class="number">0x7ffff7dd2540</span> &lt;_IO_2_1_stderr_&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>在没有执行下面的操作之前可以看到<code>_IO_list_all</code>链接的是<code>_IO_2_1_stderr_</code>，执行完之后<code>_IO_list_all</code>就指向的是申请出来的结构体。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p _IO_list_all</span><br><span class="line">$<span class="number">7</span> = (<span class="keyword">struct</span> _IO_FILE_plus *) <span class="number">0x55555555b010</span></span><br></pre></td></tr></tbody></table></figure>

<p>同时此时的<code>_chain</code>字段也指向了<code>_IO_2_1_stderr_</code>这里。</p>
<h3 id="IO-file-fopen打开文件句柄"><a href="#IO-file-fopen打开文件句柄" class="headerlink" title="_IO_file_fopen打开文件句柄"></a>_IO_file_fopen打开文件句柄</h3><p>设置好了<code>_IO_LINKED</code>这里东西之后又会回到<code>__fopen_internal</code>这里，接下来会执行<code>_IO_file_fopen</code>这个函数，跟进后发现位于<code>libio/fileops.c</code>这里面的<code>_IO_new_file_fopen</code>。这个<code>_IO_new_file_fopen</code>函数有点长，这里就放一部分比较重要的。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_new_file_fopen (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode,</span><br><span class="line">            <span class="type">int</span> is32not64)</span><br><span class="line">{</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  ## 检查文件是否已打开，打开则返回</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  ## 设置文件打开模式</span><br><span class="line">  <span class="keyword">switch</span> (*mode)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">      omode = O_RDONLY;</span><br><span class="line">      read_write = _IO_NO_WRITES;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      ...    </span><br><span class="line">     }</span><br><span class="line">  ...</span><br><span class="line">  ## 调用_IO_file_open函数</span><br><span class="line">  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line">              is32not64);</span><br><span class="line">  ...</span><br><span class="line">}</span><br><span class="line">libc_hidden_ver (_IO_new_file_fopen, _IO_file_fopen)</span><br></pre></td></tr></tbody></table></figure>

<p>会先检查文件是否打开，然后设置打开模式，最后调用了<code>_IO_file_open</code>这个函数跟进它。位于<code>libio/fileops.c</code>这个文件中的<code>_IO_file_open</code>。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_file_open (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> posix_mode, <span class="type">int</span> prot,</span><br><span class="line">	       <span class="type">int</span> read_write, <span class="type">int</span> is32not64)</span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> fdesc;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL))</span><br><span class="line">    fdesc = open_not_cancel (filename,</span><br><span class="line">			     posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fdesc = open (filename, posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  fdesc = open (filename, posix_mode, prot);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (fdesc &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_fileno = fdesc;</span><br><span class="line">  _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);</span><br><span class="line">  <span class="comment">/* For append mode, send the file offset to the end of the file.  Don't</span></span><br><span class="line"><span class="comment">     update the offset cache though, since the file handle is not active.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">      == (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">    {</span><br><span class="line">      _IO_off64_t new_pos = _IO_SYSSEEK (fp, <span class="number">0</span>, _IO_seek_end);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE)</span><br><span class="line">	{</span><br><span class="line">	  close_not_cancel (fdesc);</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line">    }</span><br><span class="line">  _IO_link_in ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个函数就是调用open系统调用打开文件，将文件描述符赋值给FILE结构体的<code>_fileno </code>字段，最后再次调用<code>_IO_link_in</code>函数，确保该结构体被链接进入<code>_IO_list_all</code>链表。查看<code>new_f-&gt;fp</code>就可以看到<code>_fileno</code>被设置为0x3。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p new_f-&gt;fp</span><br><span class="line">$<span class="number">9</span> = {</span><br><span class="line">  file = {</span><br><span class="line">    _flags = <span class="number">-72539004</span>,</span><br><span class="line">    _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_buf_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_buf_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line">    _markers = <span class="number">0x0</span>,</span><br><span class="line">    _chain = <span class="number">0x7ffff7dd2540</span> &lt;_IO_2_1_stderr_&gt;,</span><br><span class="line">    _fileno = <span class="number">3</span>,</span><br><span class="line">    _flags2 = <span class="number">0</span>,</span><br><span class="line">    _old_offset = <span class="number">0</span>,</span><br><span class="line">    _cur_column = <span class="number">0</span>,</span><br><span class="line">    _vtable_offset = <span class="number">0</span> <span class="string">'\000'</span>,</span><br><span class="line">    _shortbuf = <span class="string">""</span>,</span><br><span class="line">    _lock = <span class="number">0x55555555b0f0</span>,</span><br><span class="line">    _offset = <span class="number">-1</span>,</span><br><span class="line">    _codecvt = <span class="number">0x0</span>,</span><br><span class="line">    _wide_data = <span class="number">0x55555555b100</span>,</span><br><span class="line">    _freeres_list = <span class="number">0x0</span>,</span><br><span class="line">    _freeres_buf = <span class="number">0x0</span>,</span><br><span class="line">    __pad5 = <span class="number">0</span>,</span><br><span class="line">    _mode = <span class="number">0</span>,</span><br><span class="line">    _unused2 = <span class="string">'\000'</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  },</span><br><span class="line">  vtable = <span class="number">0x7ffff7dd06e0</span> &lt;_IO_file_jumps&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>执行完成之后返回FILE结构体指针。至此对fopen的调试结束。</p>
<h2 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h2><p>和fopen一样用个程序来，这里还是用那位师傅的程序，笔者只跟着动态调试。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">char</span> data[<span class="number">20</span>];</span><br><span class="line">    FILE *fp = fopen(<span class="string">"test"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    fread(data, <span class="number">1</span>, <span class="number">20</span>, fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>需要创建一个test文件并写入一些东西进去即可。gdb启动调试，断点下在fread这里就会看到调用了<code>_IO_fread</code>，看一下FILE结构体fp的内容。可以看到此时的<code>_IO_read_ptr</code>和<code>_IO_buf_base</code>等指针都还是空的</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *_IO_list_all</span><br><span class="line">$<span class="number">1</span> = {</span><br><span class="line">  file = {</span><br><span class="line">    _flags = <span class="number">-72539000</span>,</span><br><span class="line">    _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_buf_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_buf_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line">    _markers = <span class="number">0x0</span>,</span><br><span class="line">    _chain = <span class="number">0x7ffff7f995e0</span> &lt;_IO_2_1_stderr_&gt;,</span><br><span class="line">    _fileno = <span class="number">3</span>,</span><br><span class="line">    _flags2 = <span class="number">0</span>,</span><br><span class="line">    _old_offset = <span class="number">0</span>,</span><br><span class="line">    _cur_column = <span class="number">0</span>,</span><br><span class="line">    _vtable_offset = <span class="number">0</span> <span class="string">'\000'</span>,</span><br><span class="line">    _shortbuf = <span class="string">""</span>,</span><br><span class="line">    _lock = <span class="number">0x555555559380</span>,</span><br><span class="line">    _offset = <span class="number">-1</span>,</span><br><span class="line">    _codecvt = <span class="number">0x0</span>,</span><br><span class="line">    _wide_data = <span class="number">0x555555559390</span>,</span><br><span class="line">    _freeres_list = <span class="number">0x0</span>,</span><br><span class="line">    _freeres_buf = <span class="number">0x0</span>,</span><br><span class="line">    __pad5 = <span class="number">0</span>,</span><br><span class="line">    _mode = <span class="number">0</span>,</span><br><span class="line">    _unused2 = <span class="string">'\000'</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  },</span><br><span class="line">  vtable = <span class="number">0x7ffff7f9a4a0</span> &lt;_IO_file_jumps&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>vtable中的指针内容如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *_IO_list_all-&gt;vtable</span><br><span class="line">$<span class="number">2</span> = {</span><br><span class="line">  __dummy = <span class="number">0</span>,</span><br><span class="line">  __dummy2 = <span class="number">0</span>,</span><br><span class="line">  __finish = <span class="number">0x7ffff7e4a440</span> &lt;_IO_new_file_finish&gt;,</span><br><span class="line">  __overflow = <span class="number">0x7ffff7e4aea0</span> &lt;_IO_new_file_overflow&gt;,</span><br><span class="line">  __underflow = <span class="number">0x7ffff7e4ab50</span> &lt;_IO_new_file_underflow&gt;,</span><br><span class="line">  __uflow = <span class="number">0x7ffff7e4bf10</span> &lt;__GI__IO_default_uflow&gt;,</span><br><span class="line">  __pbackfail = <span class="number">0x7ffff7e4d2d0</span> &lt;__GI__IO_default_pbackfail&gt;,</span><br><span class="line">  __xsputn = <span class="number">0x7ffff7e4a030</span> &lt;_IO_new_file_xsputn&gt;,</span><br><span class="line">  __xsgetn = <span class="number">0x7ffff7e49c10</span> &lt;__GI__IO_file_xsgetn&gt;,</span><br><span class="line">  __seekoff = <span class="number">0x7ffff7e49470</span> &lt;_IO_new_file_seekoff&gt;,</span><br><span class="line">  __seekpos = <span class="number">0x7ffff7e4c2a0</span> &lt;_IO_default_seekpos&gt;,</span><br><span class="line">  __setbuf = <span class="number">0x7ffff7e48d30</span> &lt;_IO_new_file_setbuf&gt;,</span><br><span class="line">  __sync = <span class="number">0x7ffff7e48bc0</span> &lt;_IO_new_file_sync&gt;,</span><br><span class="line">  __doallocate = <span class="number">0x7ffff7e3d8d0</span> &lt;__GI__IO_file_doallocate&gt;,</span><br><span class="line">  __read = <span class="number">0x7ffff7e4a210</span> &lt;__GI__IO_file_read&gt;,</span><br><span class="line">  __write = <span class="number">0x7ffff7e49a70</span> &lt;_IO_new_file_write&gt;,</span><br><span class="line">  __seek = <span class="number">0x7ffff7e491a0</span> &lt;__GI__IO_file_seek&gt;,</span><br><span class="line">  __close = <span class="number">0x7ffff7e48d20</span> &lt;__GI__IO_file_close&gt;,</span><br><span class="line">  __stat = <span class="number">0x7ffff7e49a60</span> &lt;__GI__IO_file_stat&gt;,</span><br><span class="line">  __showmanyc = <span class="number">0x7ffff7e4d460</span> &lt;_IO_default_showmanyc&gt;,</span><br><span class="line">  __imbue = <span class="number">0x7ffff7e4d470</span> &lt;_IO_default_imbue&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>fread实际上是<code>_IO_fread</code>函数，文件目录为<code>/libio/iofread.c</code>。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_fread (<span class="type">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)</span><br><span class="line">{</span><br><span class="line">  _IO_size_t bytes_requested = size * count;</span><br><span class="line">  _IO_size_t bytes_read;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes_requested == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">     # 调用_IO_sgetn函数</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="type">char</span> *) buf, bytes_requested);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>源码中可以看到又调用了<code>_IO_sgetn</code>函数，跟进它。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">463</span> _IO_size_t</span><br><span class="line">  <span class="number">464</span> _IO_sgetn (_IO_FILE *fp, <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">  <span class="number">465</span> {</span><br><span class="line">  <span class="number">466</span>   <span class="comment">/* FIXME handle putback buffer here! */</span></span><br><span class="line">► <span class="number">467</span>   <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">  <span class="number">468</span> }</span><br></pre></td></tr></tbody></table></figure>

<p>又调用了<code>_IO_XSGETN</code>，<code>#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</code>，继续跟进就可以发现最终调用了<code>_IO_file_xsgetn</code>实际上就是FILE结构体中vtable的<code>__xsgetn</code>函数，位于<code>libio/fileops.c</code>。下面贴一下比较重要的部分</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_file_xsgetn (_IO_FILE *fp, <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">{</span><br><span class="line">  _IO_size_t want, have;</span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line">  <span class="type">char</span> *s = data;</span><br><span class="line"></span><br><span class="line">  want = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">      ...</span><br><span class="line">      # 第一部分，如果fp-&gt;_IO_buf_base为空的话则调用`_IO_doallocbuf`</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">    </span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      ## 第二部分，输入缓冲区里已经有足够的字符，则直接把缓冲区里的字符给目标buff</span><br><span class="line">      <span class="title function_">if</span> <span class="params">(want &lt;= have)</span>   </span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">    fp-&gt;_IO_read_ptr += want;</span><br><span class="line">    want = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">  {</span><br><span class="line">          # 第二部分，输入缓冲区里有部分字符，但是没有达到fread的size需求，先把已有的拷贝至目标buff</span><br><span class="line">    <span class="keyword">if</span> (have &gt; <span class="number">0</span>)  </span><br><span class="line">      {</span><br><span class="line">      ...</span><br><span class="line">        <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">        s += have;</span><br><span class="line">        </span><br><span class="line">        want -= have;</span><br><span class="line">        fp-&gt;_IO_read_ptr += have;</span><br><span class="line">      }</span><br><span class="line">    </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">        &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">      {</span><br><span class="line">        ## 第三部分，输入缓冲区里不能满足需求，调用__underflow读入数据</span><br><span class="line">        <span class="keyword">if</span> (__underflow (fp) == EOF)  </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">}</span><br><span class="line">libc_hidden_def (_IO_file_xsgetn)</span><br></pre></td></tr></tbody></table></figure>

<p><code>_IO_file_xsgetn</code>是处理<code>fread</code>读入数据的核心函数，分为三个部分：</p>
<ul>
<li>第一部分是<code>fp-&gt;_IO_buf_base</code>为空的情况，表明此时的FILE结构体中的指针未被初始化，输入缓冲区未建立，则调用<code>_IO_doallocbuf</code>去初始化指针，建立输入缓冲区。</li>
<li>第二部分是输入缓冲区里有输入，即<code>fp-&gt;_IO_read_ptr</code>小于<code>fp-&gt;_IO_read_end</code>，此时将缓冲区里的数据直接拷贝至目标buff。</li>
<li>第三部分是输入缓冲区里的数据为空或者是不能满足全部的需求，则调用<code>__underflow</code>调用系统调用读入数据。</li>
</ul>
<p>接下来对<code>_IO_file_xsgetn</code>这三部分进行跟进并分析。</p>
<h3 id="初始化输入缓冲区"><a href="#初始化输入缓冲区" class="headerlink" title="初始化输入缓冲区"></a>初始化输入缓冲区</h3><p>首先是第一部分，在<code>fp-&gt;_IO_buf_base</code>为空时，也就是输入缓冲区未建立时，代码调用<code>_IO_doallocbuf</code>函数去建立输入缓冲区。跟进<code>_IO_doallocbuf</code>函数，看下它是如何初始化输入缓冲区，为输入缓冲区分配空间的，文件在<code>/libio/genops.c</code>中：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_doallocbuf (_IO_FILE *fp)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base) # 如何输入缓冲区不为空，直接返回</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; <span class="number">0</span>) #检查标志位</span><br><span class="line">    <span class="keyword">if</span> (_IO_DOALLOCATE (fp) != EOF) ## 调用vtable函数</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line">libc_hidden_def (_IO_doallocbuf)</span><br></pre></td></tr></tbody></table></figure>

<p>函数先检查<code>fp-&gt;_IO_buf_base</code>是否为空，如果不为空的话表明该输入缓冲区已被初始化，直接返回。如果为空，则检查<code>fp-&gt;_flags</code>看它是不是<code>_IO_UNBUFFERED</code>或者<code>fp-&gt;_mode</code>大于0，如果满足条件调用FILE的vtable中的<code>_IO_file_doallocate</code>，跟进去该函数，在<code>/libio/filedoalloc.c</code>中：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">_IO_file_doallocate (_IO_FILE *fp)</span><br><span class="line">{</span><br><span class="line">  _IO_size_t size;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  size = _IO_BUFSIZ;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>) # 调用`_IO_SYSSTAT`获取FILE信息</span><br><span class="line">   {</span><br><span class="line">     ... </span><br><span class="line">     <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span>)</span><br><span class="line">     size = st.st_blksize;</span><br><span class="line">     ...</span><br><span class="line">   }</span><br><span class="line"> p = <span class="built_in">malloc</span> (size);</span><br><span class="line"> ...</span><br><span class="line"> _IO_setb (fp, p, p + size, <span class="number">1</span>); # 调用`_IO_setb`设置FILE缓冲区</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">libc_hidden_def (_IO_file_doallocate)</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到<code>_IO_file_doallocate</code>函数是分配输入缓冲区的实现函数，首先调用<code>_IO_SYSSTAT</code>去获取文件信息，<code>_IO_SYSSTAT</code>函数是vtable中的<code> __stat</code>函数，获取文件信息，修改相应需要申请的size。可以看到在执行完<code>_IO_SYSSTAT</code>函数后，st结构体的值为：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p st</span><br><span class="line">$<span class="number">4</span> = {</span><br><span class="line">  st_dev = <span class="number">64514</span>,</span><br><span class="line">  st_ino = <span class="number">2248406</span>,</span><br><span class="line">  st_nlink = <span class="number">1</span>,</span><br><span class="line">  st_mode = <span class="number">33204</span>,</span><br><span class="line">  st_uid = <span class="number">1000</span>,</span><br><span class="line">  st_gid = <span class="number">1000</span>,</span><br><span class="line">  __pad0 = <span class="number">0</span>,</span><br><span class="line">  st_rdev = <span class="number">0</span>,</span><br><span class="line">  st_size = <span class="number">7</span>,</span><br><span class="line">  st_blksize = <span class="number">4096</span>,</span><br><span class="line">  st_blocks = <span class="number">8</span>,</span><br><span class="line">  st_atim = {</span><br><span class="line">    tv_sec = <span class="number">1661346060</span>,</span><br><span class="line">    tv_nsec = <span class="number">403757781</span></span><br><span class="line">  },</span><br><span class="line">  st_mtim = {</span><br><span class="line">    tv_sec = <span class="number">1661346059</span>,</span><br><span class="line">    tv_nsec = <span class="number">331754338</span></span><br><span class="line">  },</span><br><span class="line">  st_ctim = {</span><br><span class="line">    tv_sec = <span class="number">1661346059</span>,</span><br><span class="line">    tv_nsec = <span class="number">331754338</span></span><br><span class="line">  },</span><br><span class="line">  __glibc_reserved = {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因此size被修改为<code>st.st_blksize</code>所对应的大小0x1000，接着调用malloc去申请内存，申请出来的堆块如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b000</span></span><br><span class="line">Size: <span class="number">0x231</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b230</span></span><br><span class="line">Size: <span class="number">0x1011</span></span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555c240</span></span><br><span class="line">Size: <span class="number">0x1fdc1</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x55555555b230</span></span><br><span class="line"><span class="number">0x55555555b230</span>:	<span class="number">0x00007ffff7dd0260</span>	<span class="number">0x0000000000001011</span></span><br><span class="line"><span class="number">0x55555555b240</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55555555b250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></tbody></table></figure>

<p>空间申请出来后，调用<code>_IO_setb</code>，跟进去看它干了些啥，文件在<code>/libio/genops.c</code>中：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (_IO_FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">{</span><br><span class="line">  ...</span><br><span class="line">  f-&gt;_IO_buf_base = b; # 设置_IO_buf_base </span><br><span class="line">  f-&gt;_IO_buf_end = eb; # 设置_IO_buf_end</span><br><span class="line">  ...</span><br><span class="line">}</span><br><span class="line">libc_hidden_def (_IO_setb)</span><br></pre></td></tr></tbody></table></figure>

<p>函数相对比较简单的就是设置了<code>_IO_buf_base</code>和<code>_IO_buf_end</code>，可以预料到<code>_IO_setb</code>函数执行完后，fp的这两个指针被赋上值了：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *_IO_list_all</span><br><span class="line">$<span class="number">5</span> = {</span><br><span class="line">  file = {</span><br><span class="line">    _flags = <span class="number">-72539000</span>,</span><br><span class="line">    _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_buf_base = <span class="number">0x55555555b240</span> <span class="string">""</span>,</span><br><span class="line">    _IO_buf_end = <span class="number">0x55555555c240</span> <span class="string">""</span>,</span><br><span class="line">    _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line">    _markers = <span class="number">0x0</span>,</span><br><span class="line">    _chain = <span class="number">0x7ffff7dd2540</span> &lt;_IO_2_1_stderr_&gt;,</span><br><span class="line">    _fileno = <span class="number">3</span>,</span><br><span class="line">    _flags2 = <span class="number">0</span>,</span><br><span class="line">    _old_offset = <span class="number">0</span>,</span><br><span class="line">    _cur_column = <span class="number">0</span>,</span><br><span class="line">    _vtable_offset = <span class="number">0</span> <span class="string">'\000'</span>,</span><br><span class="line">    _shortbuf = <span class="string">""</span>,</span><br><span class="line">    _lock = <span class="number">0x55555555b0f0</span>,</span><br><span class="line">    _offset = <span class="number">-1</span>,</span><br><span class="line">    _codecvt = <span class="number">0x0</span>,</span><br><span class="line">    _wide_data = <span class="number">0x55555555b100</span>,</span><br><span class="line">    _freeres_list = <span class="number">0x0</span>,</span><br><span class="line">    _freeres_buf = <span class="number">0x0</span>,</span><br><span class="line">    __pad5 = <span class="number">0</span>,</span><br><span class="line">    _mode = <span class="number">0</span>,</span><br><span class="line">    _unused2 = <span class="string">'\000'</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  },</span><br><span class="line">  vtable = <span class="number">0x7ffff7dd06e0</span> &lt;_IO_file_jumps&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>到此，初始化缓冲区就完成了，函数返回<code>_IO_file_doallocate</code>后，接着<code>_IO_file_doallocate</code>也返回，回到<code>_IO_file_xsgetn</code>函数中。</p>
<h3 id="拷贝输入缓冲区数据"><a href="#拷贝输入缓冲区数据" class="headerlink" title="拷贝输入缓冲区数据"></a>拷贝输入缓冲区数据</h3><p>初始化缓冲区完成之后，代码返回到<code>_IO_file_xsgetn</code>函数中，程序就进入到第二部分：拷贝输入缓冲区数据，如果输入缓冲区里存在已输入的数据，则把它直接拷贝到目标缓冲区里。</p>
<p>这部分比较简单，需要说明下的是从这里可以看出来<code>fp-&gt;_IO_read_ptr</code>指向的是输入缓冲区的起始地址，<code>fp-&gt;_IO_read_end</code>指向的是输入缓冲区的结束地址。</p>
<p>将<code>fp-&gt;_IO_read_end-fp-&gt;_IO_read_ptr</code>之间的数据通过<code>memcpy</code>拷贝到目标缓冲区里。</p>
<h3 id="执行系统调用读取数据"><a href="#执行系统调用读取数据" class="headerlink" title="执行系统调用读取数据"></a>执行系统调用读取数据</h3><p>在输入缓冲区为0或者是不能满足需求的时候则会执行最后一步<code>__underflow</code>去执行系统调用<code>read</code>读取数据，并放入到输入缓冲区里。</p>
<p>因为demo里第一次读取数据，此时的<code>fp-&gt;_IO_read_end</code>以及<code>fp-&gt;_IO_read_ptr</code>都是0，因此会进入到<code>__underflow</code>，跟进去细看，文件在<code>/libio/genops.c</code>中：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__underflow (_IO_FILE *fp)</span><br><span class="line">{</span><br><span class="line">  </span><br><span class="line">  # 额外的检查</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  ...</span><br><span class="line">  # 调用_IO_UNDERFLOW</span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">}</span><br><span class="line">libc_hidden_def (__underflow)</span><br></pre></td></tr></tbody></table></figure>

<p>函数稍微做一些检查就会调用<code>_IO_UNDERFLOW</code>函数，其中一个检查是如果<code>fp-&gt;_IO_read_ptr</code>小于<code>fp-&gt;_IO_read_end</code>则表明输入缓冲区里存在数据，可直接返回，否则则表示需要继续读入数据。</p>
<p>检查都通过的话就会调用<code>_IO_UNDERFLOW</code>函数，该函数是FILE结构体vtable里的<code>_IO_new_file_underflow</code>，跟进去看，文件在<code>/libio/fileops.c</code>里：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (_IO_FILE *fp)</span><br><span class="line">{</span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line">  ...</span><br><span class="line">  ## 如果存在_IO_NO_READS标志，则直接返回</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    {</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    }</span><br><span class="line">  ## 如果输入缓冲区里存在数据，则直接返回</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  ...</span><br><span class="line">  ## 如果没有输入缓冲区，则调用_IO_doallocbuf分配输入缓冲区</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">      ...</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    }</span><br><span class="line">  ...</span><br><span class="line">  ## 设置FILE结构体指针</span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line">  ##调用_IO_SYSREAD函数最终执行系统调用读取数据</span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">           fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">  ...</span><br><span class="line">  ## 设置结构体指针</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">}</span><br><span class="line">libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)</span><br></pre></td></tr></tbody></table></figure>

<p>这个<code>_IO_new_file_underflow</code>函数，是最终调用系统调用的地方，在最终执行系统调用之前，仍然有一些检查，整个流程为：</p>
<ol>
<li>检查FILE结构体的<code>_flag</code>标志位是否包含<code>_IO_NO_READS</code>，如果存在这个标志位则直接返回<code>EOF</code>，其中<code>_IO_NO_READS</code>标志位的定义是<code>#define _IO_NO_READS 4 /* Reading not allowed */</code>。</li>
<li>如果<code>fp-&gt;_IO_buf_base</code>位null，则调用<code>_IO_doallocbuf</code>分配输入缓冲区。</li>
<li>接着初始化设置FILE结构体指针，将他们都设置成<code>fp-&gt;_IO_buf_base</code></li>
<li>调用<code>_IO_SYSREAD</code>（vtable中的<code>_IO_file_read</code>函数），该函数最终执行系统调用read，读取文件数据，数据读入到<code>fp-&gt;_IO_buf_base</code>中，读入大小为输入缓冲区的大小<code>fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</code>。</li>
<li>设置输入缓冲区已有数据的size，即设置<code>fp-&gt;_IO_read_end</code>为<code>fp-&gt;_IO_read_end += count</code>。</li>
</ol>
<p>其中第二步里面的如果<code>fp-&gt;_IO_buf_base</code>位null，则调用<code>_IO_doallocbuf</code>分配输入缓冲区，似乎有点累赘，因为之前已经分配了，这个原因我在最后会说明。</p>
<p>其中第四步的<code>_IO_SYSREAD</code>（vtable中的<code>_IO_file_read</code>函数）的源码比较简单，就是执行系统调用函数read去读取文件数据，文件在<code>libio/fileops.c</code>，源码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_IO_ssize_t</span><br><span class="line">_IO_file_read (_IO_FILE *fp, <span class="type">void</span> *buf, _IO_ssize_t size)</span><br><span class="line">{</span><br><span class="line">   <span class="keyword">return</span> (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">           ? read_not_cancel (fp-&gt;_fileno, buf, size)</span><br><span class="line">           : read (fp-&gt;_fileno, buf, size));</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<p><code>_IO_file_underflow</code>函数执行完毕以后，FILE结构体中各个指针已被赋值，且文件数据已读入，输入缓冲区里已经有数据，结构体值如下，其中<code>fp-&gt;_IO_read_ptr</code>指向输入缓冲区数据的开始位置，<code>fp-&gt;_IO_read_end</code>指向输入缓冲区数据结束的位置：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *_IO_list_all</span><br><span class="line">$<span class="number">4</span> = {</span><br><span class="line">  file = {</span><br><span class="line">    _flags = <span class="number">-72539000</span>,</span><br><span class="line">    _IO_read_ptr = <span class="number">0x55555555b240</span> <span class="string">"111111\n"</span>,</span><br><span class="line">    _IO_read_end = <span class="number">0x55555555b247</span> <span class="string">""</span>,</span><br><span class="line">    _IO_read_base = <span class="number">0x55555555b240</span> <span class="string">"111111\n"</span>,</span><br><span class="line">    _IO_write_base = <span class="number">0x55555555b240</span> <span class="string">"111111\n"</span>,</span><br><span class="line">    _IO_write_ptr = <span class="number">0x55555555b240</span> <span class="string">"111111\n"</span>,</span><br><span class="line">    _IO_write_end = <span class="number">0x55555555b240</span> <span class="string">"111111\n"</span>,</span><br><span class="line">    _IO_buf_base = <span class="number">0x55555555b240</span> <span class="string">"111111\n"</span>,</span><br><span class="line">    _IO_buf_end = <span class="number">0x55555555c240</span> <span class="string">""</span>,</span><br><span class="line">    _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line">    _markers = <span class="number">0x0</span>,</span><br><span class="line">    _chain = <span class="number">0x7ffff7dd2540</span> &lt;_IO_2_1_stderr_&gt;,</span><br><span class="line">    _fileno = <span class="number">3</span>,</span><br><span class="line">    _flags2 = <span class="number">0</span>,</span><br><span class="line">    _old_offset = <span class="number">0</span>,</span><br><span class="line">    _cur_column = <span class="number">0</span>,</span><br><span class="line">    _vtable_offset = <span class="number">0</span> <span class="string">'\000'</span>,</span><br><span class="line">    _shortbuf = <span class="string">""</span>,</span><br><span class="line">    _lock = <span class="number">0x55555555b0f0</span>,</span><br><span class="line">    _offset = <span class="number">-1</span>,</span><br><span class="line">    _codecvt = <span class="number">0x0</span>,</span><br><span class="line">    _wide_data = <span class="number">0x55555555b100</span>,</span><br><span class="line">    _freeres_list = <span class="number">0x0</span>,</span><br><span class="line">    _freeres_buf = <span class="number">0x0</span>,</span><br><span class="line">    __pad5 = <span class="number">0</span>,</span><br><span class="line">    _mode = <span class="number">-1</span>,</span><br><span class="line">    _unused2 = <span class="string">'\000'</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  },</span><br><span class="line">  vtable = <span class="number">0x7ffff7dd06e0</span> &lt;_IO_file_jumps&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>函数执行完后，返回到<code>_IO_file_xsgetn</code>函数中，由于<code>while</code>循环的存在，重新执行第二部分，此时将输入缓冲区拷贝至目标缓冲区，最终返回。</p>
<p>至此，对于fread的源码分析结束。</p>
<h3 id="其他输入函数"><a href="#其他输入函数" class="headerlink" title="其他输入函数"></a>其他输入函数</h3><p>完整分析了fread函数之后，还想知道其他一些函数（scanf、gets）等函数时如何通过stdin实现输入的，我编写了源码，并将断点下在了read函数之前，看他们时如何调用去的。</p>
<p>首先是scanf，其最终调用read函数时栈回溯如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read</span><br><span class="line">_IO_new_file_underflow at fileops.c</span><br><span class="line">__GI__IO_default_uflow at genops.c</span><br><span class="line">_IO_vfscanf_internal at vfscanf.c</span><br><span class="line">__isoc99_scanf at  at isoc99_scanf.c</span><br><span class="line"><span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">__libc_start_main</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到scanf最终也是调用stdin的vtable中的<code>_IO_new_file_underflow</code>去调用read的。不过它并不是使用<code>_IO_file_xsgetn</code>，而是使用vtable中的<code>__uflow</code>，源码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_default_uflow (_IO_FILE *fp)</span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> ch = _IO_UNDERFLOW (fp);</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr++;</span><br><span class="line">}</span><br><span class="line">libc_hidden_def (_IO_default_uflow)</span><br></pre></td></tr></tbody></table></figure>

<p><code>__uflow</code>函数基本上啥都没干直接就调用了<code>_IO_new_file_underflow</code>因此最终也是<code>_IO_new_file_underflow</code>实现的输入。</p>
<p>再看看<code>gets</code>函数，函数调用栈如下，与scanf基本一致：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read</span><br><span class="line">__GI__IO_file_underflow</span><br><span class="line">__GI__IO_default_uflow</span><br><span class="line">gets</span><br><span class="line">main</span><br><span class="line"> __libc_start_main+<span class="number">240</span></span><br></pre></td></tr></tbody></table></figure>

<p>再试了试fscanf等，仍然是一样的，仍然是最终通过<code>_IO_new_file_underflow</code>实现的输入。虽然不能说全部的io输入都是通过<code>_IO_new_file_underflow</code>函数最终实现的输入，但是应该也可以说大部分是使用<code>_IO_new_file_underflow</code>函数实现的。</p>
<p>但是仍然有一个问题，由于<code>__uflow</code>直接就调用了<code>_IO_new_file_underflow</code>函数，那么输入缓冲区是在哪里建立的呢，为了找到这个问题的答案，我在程序进入到fscanf函数后又在<code>malloc</code>函数下了个断点，然后栈回溯：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span></span><br><span class="line">__GI__IO_file_doallocate</span><br><span class="line">__GI__IO_doallocbuf</span><br><span class="line">__GI__IO_file_underflow</span><br><span class="line">__GI__IO_default_uflow</span><br><span class="line">__GI__IO_vfscanf</span><br><span class="line">__isoc99_fscanf</span><br><span class="line">main</span><br><span class="line">__libc_start_main</span><br></pre></td></tr></tbody></table></figure>

<p>原来是在<code>__GI__IO_file_underflow</code>分配的空间，回到上面看该函数的源码，确实有一段判断输入缓冲区如果为空则调用<code>__GI__IO_doallocbuf</code>函数建立输入缓冲区的代码，这就解释了<code>__GI__IO_file_underflow</code>第二步中为啥还会有个输入缓冲区判断的原因了，不得不感慨，代码写的真巧妙。</p>
<p>在结束之前我想总结下<code>fread</code>在执行系统调用read前对vtable里的哪些函数进行了调用，具体如下：</p>
<ul>
<li><code>_IO_sgetn</code>函数调用了vtable的<code>_IO_file_xsgetn</code>。</li>
<li><code>_IO_doallocbuf</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li>
<li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li>
<li><code>__underflow</code>函数调用了vtable中的<code>_IO_new_file_underflow</code>实现文件数据读取。</li>
<li>vtable中的<code>_IO_new_file_underflow</code>调用了vtable<code>__GI__IO_file_read</code>最终去执行系统调用read。</li>
</ul>
<p>先提一下，后续如果想通过IO FILE实现任意读的话，最关键的函数应是<code>_IO_new_file_underflow</code>，它里面有个标志位的判断，是后面构造利用需要注意的一个比较重要条件：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## 如果存在_IO_NO_READS标志，则直接返回</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">  {</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">    __set_errno (EBADF);</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h2><p>调试程序如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">char</span> *data=<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    FILE*fp=fopen(<span class="string">"test"</span>,<span class="string">"wb"</span>);</span><br><span class="line">    </span><br><span class="line">    fwrite(data,<span class="number">1</span>,<span class="number">0x30</span>,fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先使用进行初步的跟踪，在<code>fwrite</code>下断点。看到程序首先断在<code>_IO_fwrite</code>函数中，在开始调试之前，仍然是先把传入的IO FILE <code>fp</code>值看一看：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *_IO_list_all</span><br><span class="line">$<span class="number">1</span> = {</span><br><span class="line">  file = {</span><br><span class="line">    _flags = <span class="number">-72540026</span>,</span><br><span class="line">    _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_buf_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_buf_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line">    _markers = <span class="number">0x0</span>,</span><br><span class="line">    _chain = <span class="number">0x7ffff7fb76a0</span> &lt;_IO_2_1_stdout_&gt;,</span><br><span class="line">    _fileno = <span class="number">2</span>,</span><br><span class="line">    _flags2 = <span class="number">0</span>,</span><br><span class="line">    _old_offset = <span class="number">-1</span>,</span><br><span class="line">    _cur_column = <span class="number">0</span>,</span><br><span class="line">    _vtable_offset = <span class="number">0</span> <span class="string">'\000'</span>,</span><br><span class="line">    _shortbuf = <span class="string">""</span>,</span><br><span class="line">    _lock = <span class="number">0x7ffff7fb87d0</span> &lt;_IO_stdfile_2_lock&gt;,</span><br><span class="line">    _offset = <span class="number">-1</span>,</span><br><span class="line">    _codecvt = <span class="number">0x0</span>,</span><br><span class="line">    _wide_data = <span class="number">0x7ffff7fb6780</span> &lt;_IO_wide_data_2&gt;,</span><br><span class="line">    _freeres_list = <span class="number">0x0</span>,</span><br><span class="line">    _freeres_buf = <span class="number">0x0</span>,</span><br><span class="line">    __pad5 = <span class="number">0</span>,</span><br><span class="line">    _mode = <span class="number">0</span>,</span><br><span class="line">    _unused2 = <span class="string">'\000'</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  },</span><br><span class="line">  vtable = <span class="number">0x7ffff7fb34a0</span> &lt;_IO_file_jumps&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以及此时的vtable中的内容：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *_IO_list_all-&gt;vtable</span><br><span class="line">$<span class="number">2</span> = {</span><br><span class="line">  __dummy = <span class="number">0</span>,</span><br><span class="line">  __dummy2 = <span class="number">0</span>,</span><br><span class="line">  __finish = <span class="number">0x7ffff7e59f50</span> &lt;_IO_new_file_finish&gt;,</span><br><span class="line">  __overflow = <span class="number">0x7ffff7e5ad80</span> &lt;_IO_new_file_overflow&gt;,</span><br><span class="line">  __underflow = <span class="number">0x7ffff7e5aa20</span> &lt;_IO_new_file_underflow&gt;,</span><br><span class="line">  __uflow = <span class="number">0x7ffff7e5bf50</span> &lt;__GI__IO_default_uflow&gt;,</span><br><span class="line">  __pbackfail = <span class="number">0x7ffff7e5d680</span> &lt;__GI__IO_default_pbackfail&gt;,</span><br><span class="line">  __xsputn = <span class="number">0x7ffff7e595d0</span> &lt;_IO_new_file_xsputn&gt;,</span><br><span class="line">  __xsgetn = <span class="number">0x7ffff7e59240</span> &lt;__GI__IO_file_xsgetn&gt;,</span><br><span class="line">  __seekoff = <span class="number">0x7ffff7e58860</span> &lt;_IO_new_file_seekoff&gt;,</span><br><span class="line">  __seekpos = <span class="number">0x7ffff7e5c600</span> &lt;_IO_default_seekpos&gt;,</span><br><span class="line">  __setbuf = <span class="number">0x7ffff7e58530</span> &lt;_IO_new_file_setbuf&gt;,</span><br><span class="line">  __sync = <span class="number">0x7ffff7e583c0</span> &lt;_IO_new_file_sync&gt;,</span><br><span class="line">  __doallocate = <span class="number">0x7ffff7e4bc70</span> &lt;__GI__IO_file_doallocate&gt;,</span><br><span class="line">  __read = <span class="number">0x7ffff7e595a0</span> &lt;__GI__IO_file_read&gt;,</span><br><span class="line">  __write = <span class="number">0x7ffff7e58e60</span> &lt;_IO_new_file_write&gt;,</span><br><span class="line">  __seek = <span class="number">0x7ffff7e58600</span> &lt;__GI__IO_file_seek&gt;,</span><br><span class="line">  __close = <span class="number">0x7ffff7e58520</span> &lt;__GI__IO_file_close&gt;,</span><br><span class="line">  __stat = <span class="number">0x7ffff7e58e40</span> &lt;__GI__IO_file_stat&gt;,</span><br><span class="line">  __showmanyc = <span class="number">0x7ffff7e5d810</span> &lt;_IO_default_showmanyc&gt;,</span><br><span class="line">  __imbue = <span class="number">0x7ffff7e5d820</span> &lt;_IO_default_imbue&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从图里也看到由于刚经过<code>fopen</code>初始化，输入输出缓冲区没有建立，此时的所有指针都为空。</p>
<p><code>_IO_fwrite</code>函数在文件<code>/libio/iofwrite.c</code>中：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)</span><br><span class="line">{</span><br><span class="line">  _IO_size_t request = size * count;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);</span><br><span class="line">  ...</span><br><span class="line">}</span><br><span class="line">libc_hidden_def (_IO_fwrite)</span><br></pre></td></tr></tbody></table></figure>

<p>没有做过多的操作就调用了<code>_IO_sputn</code>函数，该函数是<code>vtable</code>中的<code>__xsputn</code> （<code>_IO_new_file_xsputn</code>）在文件/libio/fileops.c中，这里就不一次性把函数的所有源码都贴在这里，而是按部分贴在下面每个部分的开始的地方，不然感觉有些冗余。</p>
<p>如流程所示，源码分析分四个部分进行，与流程相对应，其中下面每部分刚开始的代码都是<code>_IO_new_file_xsputn</code>函数中的源码。</p>
<h3 id="将目标输出数据拷贝至输出缓冲区"><a href="#将目标输出数据拷贝至输出缓冲区" class="headerlink" title="将目标输出数据拷贝至输出缓冲区"></a>将目标输出数据拷贝至输出缓冲区</h3><p>第一部分所包含的代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_new_file_xsputn (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">{ </span><br><span class="line"></span><br><span class="line">    _IO_size_t count = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">    ## 判断输出缓冲区还有多少空间</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  ## 如果输出缓冲区有空间，则先把数据拷贝至输出缓冲区</span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">  count = to_do;</span><br><span class="line">  ...</span><br><span class="line">      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      f-&gt;_IO_write_ptr += count;</span><br><span class="line">    ## 计算是否还有目标输出数据剩余</span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br></pre></td></tr></tbody></table></figure>

<p>主要功能就是判断输出缓冲区还有多少空间，其中像<code>demo</code>中的程序所示的<code>f-&gt;_IO_write_end</code>以及<code>f-&gt;_IO_write_ptr</code>均为0，此时的输出缓冲区为0。</p>
<p>另一部分则是如果输出缓冲区如果仍有剩余空间的话，则将目标输出数据拷贝至输出缓冲区，并计算在输出缓冲区填满后，是否仍然剩余目标输出数据。</p>
<h3 id="建立输出缓冲区或flush输出缓冲区"><a href="#建立输出缓冲区或flush输出缓冲区" class="headerlink" title="建立输出缓冲区或flush输出缓冲区"></a>建立输出缓冲区或flush输出缓冲区</h3><p>第二部分代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">## 如果还有目标数据剩余，此时则表明输出缓冲区未建立或输出缓冲区已经满了</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      _IO_size_t block_size, do_write;</span><br><span class="line">      ## 函数实现清空输出缓冲区或建立缓冲区的功能</span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      ## 检查输出数据是否是大块</span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>经过了上一步骤后，如果还有目标输出数据，表明输出缓冲区未建立或输出缓冲区已经满了，此时调用<code>_IO_OVERFLOW</code>函数，该函数功能主要是实现刷新输出缓冲区或建立缓冲区的功能，该函数是vtable函数中的<code>__overflow</code>（<code>_IO_new_file_overflow</code>），文件在<code>/libio/fileops.c</code>中：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, <span class="type">int</span> ch)</span><br><span class="line">{</span><br><span class="line">  ## 判断标志位是否包含_IO_NO_WRITES</span><br><span class="line">  <span class="title function_">if</span> <span class="params">(f-&gt;_flags &amp; _IO_NO_WRITES)</span> <span class="comment">/* SET ERROR */</span></span><br><span class="line">    {</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">  ## 判断输出缓冲区是否为空</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">  {</span><br><span class="line">    ## 分配输出缓冲区</span><br><span class="line">    _IO_doallocbuf (f);</span><br><span class="line">    _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">  }</span><br><span class="line">     </span><br><span class="line">     ## 初始化指针</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">  f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">  f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">  ## 输出输出缓冲区 </span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">       f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF) #<span class="meta"># </span></span><br><span class="line"><span class="meta">      return EOF;</span></span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">'\n'</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">          f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">}</span><br><span class="line">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br></pre></td></tr></tbody></table></figure>

<p><code>__overflow</code>函数首先检测IO FILE的<code>_flags</code>是否包含<code>_IO_NO_WRITES</code>标志位，如果包含的话则直接返回。</p>
<p>接着判断<code>f-&gt;_IO_write_base</code>是否为空，如果为空的话表明输出缓冲区尚未建立，就调用<code>_IO_doallocbuf</code>函数去分配输出缓冲区，<code>_IO_doallocbuf</code>函数源码在上一篇<code>fread</code>中已经分析过了就不跟过去了，它的功能是分配输入输出缓冲区并将指针<code>_IO_buf_base</code>和<code>_IO_buf_end</code>赋值。在执行完<code>_IO_doallocbuf</code>分配空间后调用<code>_IO_setg</code>宏，该宏的定义为如下，它将输入相关的缓冲区指针赋值为<code>_IO_buf_base</code>指针：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),\</span></span><br><span class="line"><span class="meta">  (fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))</span></span><br></pre></td></tr></tbody></table></figure>

<p>经过上面这些步骤，此时IO FILE的指针如下图所示，可以看到，<code>_IO_buf_base</code>和<code>_IO_buf_end</code>被赋值，且输入缓冲区相关指针被赋值为<code>_IO_buf_base</code>：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *_IO_list_all</span><br><span class="line">$<span class="number">3</span> = {</span><br><span class="line">  file = {</span><br><span class="line">    _flags = <span class="number">-72539004</span>,</span><br><span class="line">    _IO_read_ptr = <span class="number">0x55555555c250</span> <span class="string">""</span>,</span><br><span class="line">    _IO_read_end = <span class="number">0x55555555c250</span> <span class="string">""</span>,</span><br><span class="line">    _IO_read_base = <span class="number">0x55555555c250</span> <span class="string">""</span>,</span><br><span class="line">    _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_buf_base = <span class="number">0x55555555c250</span> <span class="string">""</span>,</span><br><span class="line">    _IO_buf_end = <span class="number">0x55555555d250</span> <span class="string">""</span>,</span><br><span class="line">    _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line">    _markers = <span class="number">0x0</span>,</span><br><span class="line">    _chain = <span class="number">0x7ffff7dd2540</span> &lt;_IO_2_1_stderr_&gt;,</span><br><span class="line">    _fileno = <span class="number">3</span>,</span><br><span class="line">    _flags2 = <span class="number">0</span>,</span><br><span class="line">    _old_offset = <span class="number">0</span>,</span><br><span class="line">    _cur_column = <span class="number">0</span>,</span><br><span class="line">    _vtable_offset = <span class="number">0</span> <span class="string">'\000'</span>,</span><br><span class="line">    _shortbuf = <span class="string">""</span>,</span><br><span class="line">    _lock = <span class="number">0x55555555c100</span>,</span><br><span class="line">    _offset = <span class="number">-1</span>,</span><br><span class="line">    _codecvt = <span class="number">0x0</span>,</span><br><span class="line">    _wide_data = <span class="number">0x55555555c110</span>,</span><br><span class="line">    _freeres_list = <span class="number">0x0</span>,</span><br><span class="line">    _freeres_buf = <span class="number">0x0</span>,</span><br><span class="line">    __pad5 = <span class="number">0</span>,</span><br><span class="line">    _mode = <span class="number">-1</span>,</span><br><span class="line">    _unused2 = <span class="string">'\000'</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  },</span><br><span class="line">  vtable = <span class="number">0x7ffff7dd06e0</span> &lt;_IO_file_jumps&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后代码初始化其他相关指针，最主要的就是将<code>f-&gt;_IO_write_base</code>以及将<code>f-&gt;_IO_write_ptr</code>设置成<code>f-&gt;_IO_read_ptr</code>指针；将<code>f-&gt;_IO_write_end</code>赋值为<code>f-&gt;_IO_buf_end</code>指针。</p>
<p>接着就执行<code>_IO_do_write</code>来调用系统调用<code>write</code>输出输出缓冲区，输出的内容为<code>f-&gt;_IO_write_ptr</code>到<code>f-&gt;_IO_write_base</code>之间的内容。跟进去该函数，函数在<code>/libio/fileops.c</code>中：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">    || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">}</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br></pre></td></tr></tbody></table></figure>

<p>该函数调用了<code>new_do_write</code>，跟进去，函数在<code>/libio/fileops.c</code>中：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span></span><br><span class="line">_IO_size_t</span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span></span><br><span class="line">{</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  ...</span><br><span class="line">  ## 额外判断</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    {</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">  = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    }</span><br><span class="line">  ## 调用函数输出输出缓冲区</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  ...</span><br><span class="line">  ## 刷新设置缓冲区指针</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">           &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">           ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>终于到了调用<code>_IO_SYSWRITE</code>的地方，进行一个判断，判断<code>fp-&gt;_IO_read_end</code>是否等于<code>fp-&gt;_IO_write_base</code>，如果不等的话，调用<code>_IO_SYSSEEK</code>去调整文件偏移，这个函数就不跟进去了，正常执行流程不会过去这里。</p>
<p>接着就调用<code>_IO_SYSWRITE</code>函数，该函数是vtable中的<code>__write</code>（<code>_IO_new_file_write</code>）函数，也是最终执行系统调用的地方，跟进去看，文件在<code>/libio/fileops.c</code>中：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_IO_ssize_t</span><br><span class="line">_IO_new_file_write (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_ssize_t n)</span><br><span class="line">{</span><br><span class="line">  _IO_ssize_t to_do = n;</span><br><span class="line">  <span class="keyword">while</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">    ## 系统调用write输出</span><br><span class="line">      _IO_ssize_t count = (__builtin_expect (f-&gt;_flags2</span><br><span class="line">               &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">         ? write_not_cancel (f-&gt;_fileno, data, to_do)</span><br><span class="line">         : write (f-&gt;_fileno, data, to_do));</span><br><span class="line">  ...   </span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>执行完<code>_IO_SYSWRITE</code>函数后，回到<code>new_do_write</code>函数，刷新设置缓冲区指针并返回。</p>
<h3 id="以块为单位直接输出数据"><a href="#以块为单位直接输出数据" class="headerlink" title="以块为单位直接输出数据"></a>以块为单位直接输出数据</h3><p>经历了缓冲区建立以及刷新缓冲区，程序返回到<code>_IO_new_file_xsputn</code>函数中，进入到如下代码功能块：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">## 检查输出数据是否是大块</span><br><span class="line">     block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">     do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (do_write)</span><br><span class="line"> {</span><br><span class="line">   ## 如果是大块的话则不使用输出缓冲区而直接输出。</span><br><span class="line">   count = new_do_write (f, s, do_write);</span><br><span class="line">   to_do -= count;</span><br><span class="line">   <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">     <span class="keyword">return</span> n - to_do;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<p>运行到此处，此时已经经过了<code>_IO_OVERFLOW</code>函数（对输出缓冲区进行了初始化或者刷新），也就是说此时的IO FILE缓冲区指针的状态是处于刷新的初始化状态，输出缓冲区中也没有数据。</p>
<p>上面这部分代码检查剩余目标输出数据大小，如果超过输入缓冲区<code>f-&gt;_IO_buf_end - f-&gt;_IO_buf_base</code>的大小，则为了提高效率，不再使用输出缓冲区，而是以块为基本单位直接将缓冲区调用<code>new_do_write</code>输出。<code>new_do_write</code>函数在上面已经跟过了就是输出，并刷新指针设置。</p>
<p>由于demo程序只输出0x60大小的数据，而它的输出缓冲区大小为0x1000，因此不会进入该部分代码。</p>
<h3 id="剩余目标输出数据放入输出缓冲区中"><a href="#剩余目标输出数据放入输出缓冲区中" class="headerlink" title="剩余目标输出数据放入输出缓冲区中"></a>剩余目标输出数据放入输出缓冲区中</h3><p>在以大块为基本单位把数据直接输出后可能还剩余小块数据，IO采用的策略则是将剩余目标输出数据放入到输出缓冲区里面，相关源码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 剩余的数据拷贝至输出缓冲区</span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">  to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br></pre></td></tr></tbody></table></figure>

<p>程序调用<code>_IO_default_xsputn</code>函数对剩下的<code>s+do_write</code>数据进行操作，跟进去该函数，在<code>/libio/genops.c</code>中：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_default_xsputn (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">{</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  _IO_size_t more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    {</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">  {</span><br><span class="line">    _IO_size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">      count = more;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">      {</span><br><span class="line">        ## 输出长度大于<span class="number">20</span>，则调用<span class="built_in">memcpy</span>拷贝</span><br><span class="line">        <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">        f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        s += count;</span><br><span class="line">      }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">      {</span><br><span class="line">        ## 小于<span class="number">20</span>则直接赋值</span><br><span class="line">        <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">        _IO_ssize_t i;</span><br><span class="line">        <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">    *p++ = *s++;</span><br><span class="line">        f-&gt;_IO_write_ptr = p;</span><br><span class="line">      }</span><br><span class="line">    more -= count;</span><br><span class="line">  }</span><br><span class="line">  ## 如果输出缓冲区为空，则调用`_IO_OVERFLOW`直接输出。</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    }</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">}</span><br><span class="line">libc_hidden_def (_IO_default_xsputn)</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到函数最主要的作用就是将剩余的目标输出数据拷贝到输出缓冲区里。为了性能优化，当长度大于20时，使用memcpy拷贝，当长度小于20时，使用for循环赋值拷贝。如果输出缓冲区为空，则调用<code>_IO_OVERFLOW</code>进行输出。</p>
<p>根据源码我们也知道，demo程序中，最终会进入到<code>_IO_default_xsputn</code>中，并且把数据拷贝至输出缓冲区里，执行完成后，看到IO 结构体的数据如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *_IO_list_all</span><br><span class="line">$<span class="number">1</span> = {</span><br><span class="line">  file = {</span><br><span class="line">    _flags = <span class="number">-72536956</span>,</span><br><span class="line">    _IO_read_ptr = <span class="number">0x55555555c250</span> <span class="string">""</span>,</span><br><span class="line">    _IO_read_end = <span class="number">0x55555555c250</span> <span class="string">""</span>,</span><br><span class="line">    _IO_read_base = <span class="number">0x55555555c250</span> <span class="string">""</span>,</span><br><span class="line">    _IO_write_base = <span class="number">0x55555555c250</span> <span class="string">""</span>,</span><br><span class="line">    _IO_write_ptr = <span class="number">0x55555555c280</span> <span class="string">""</span>,</span><br><span class="line">    _IO_write_end = <span class="number">0x55555555d250</span> <span class="string">""</span>,</span><br><span class="line">    _IO_buf_base = <span class="number">0x55555555c250</span> <span class="string">""</span>,</span><br><span class="line">    _IO_buf_end = <span class="number">0x55555555d250</span> <span class="string">""</span>,</span><br><span class="line">    _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line">    _markers = <span class="number">0x0</span>,</span><br><span class="line">    _chain = <span class="number">0x7ffff7dd2540</span> &lt;_IO_2_1_stderr_&gt;,</span><br><span class="line">    _fileno = <span class="number">3</span>,</span><br><span class="line">    _flags2 = <span class="number">0</span>,</span><br><span class="line">    _old_offset = <span class="number">0</span>,</span><br><span class="line">    _cur_column = <span class="number">0</span>,</span><br><span class="line">    _vtable_offset = <span class="number">0</span> <span class="string">'\000'</span>,</span><br><span class="line">    _shortbuf = <span class="string">""</span>,</span><br><span class="line">    _lock = <span class="number">0x55555555c100</span>,</span><br><span class="line">    _offset = <span class="number">-1</span>,</span><br><span class="line">    _codecvt = <span class="number">0x0</span>,</span><br><span class="line">    _wide_data = <span class="number">0x55555555c110</span>,</span><br><span class="line">    _freeres_list = <span class="number">0x0</span>,</span><br><span class="line">    _freeres_buf = <span class="number">0x0</span>,</span><br><span class="line">    __pad5 = <span class="number">0</span>,</span><br><span class="line">    _mode = <span class="number">-1</span>,</span><br><span class="line">    _unused2 = <span class="string">'\000'</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  },</span><br><span class="line">  vtable = <span class="number">0x7ffff7dd06e0</span> &lt;_IO_file_jumps&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到此时的<code>_IO_write_base</code>为<code>0x55555555c250</code>，而<code>_IO_write_ptr </code>为<code>0x55555555c280</code>，大小正好是0x30 。</p>
<p>至此源码分析结束。</p>
<h3 id="其他输出函数"><a href="#其他输出函数" class="headerlink" title="其他输出函数"></a>其他输出函数</h3><p><code>fwrite</code>分析完了，知道它最主要的就是通过vtable函数里面的<code>_IO_new_file_xsputn</code>实现功能，且最终的建立以及刷新输出缓冲区是在<code>_IO_new_file_overflow</code>函数里面，最终执行系统调用write对数据进行输出是在<code>new_do_write</code>函数中。</p>
<p>下面来看一下其他输出函数的栈回溯的情况，应该也都差不多，对于下面的函数，断点下在<code>write</code>函数，然后查看栈回溯。</p>
<p>首先是printf函数，它的栈回溯为：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">write</span><br><span class="line">_IO_new_file_write</span><br><span class="line">new_do_write+<span class="number">51</span></span><br><span class="line">__GI__IO_do_write</span><br><span class="line">__GI__IO_file_xsputn</span><br><span class="line"><span class="built_in">vfprintf</span></span><br><span class="line"><span class="built_in">printf</span></span><br><span class="line">main</span><br><span class="line">__libc_start_main</span><br></pre></td></tr></tbody></table></figure>

<p>也是调用<code>_IO_new_file_overflow</code>函数进行的实现。但是<code>printf</code>函数里面情况其实也还挺复杂的，篇幅的限制，就不细说了，其他的输出函数应该也差不多。</p>
<p>结束之前仍然总结下<code>fwrite</code>在执行系统调用write前对vtable里的哪些函数进行了调用，具体如下：</p>
<ul>
<li><code>_IO_fwrite</code>函数调用了vtable的<code>_IO_new_file_xsputn</code>。</li>
<li><code>_IO_new_file_xsputn</code>函数调用了vtable中的<code>_IO_new_file_overflow</code>实现缓冲区的建立以及刷新缓冲区。</li>
<li>vtable中的<code>_IO_new_file_overflow</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li>
<li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li>
<li><code>new_do_write</code>中的<code>_IO_SYSWRITE</code>调用了vtable<code>_IO_new_file_write</code>最终去执行系统调用write。</li>
</ul>
<p>同时，后续如果想通过IO FILE输出缓冲区实现任意读写的话，最关键的函数应是<code>_IO_new_file_overflow</code>，它里面有个标志位的判断，是后面构造利用需要注意的一个比较重要条件：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## 判断标志位是否包含_IO_NO_WRITES</span><br><span class="line"><span class="title function_">if</span> <span class="params">(f-&gt;_flags &amp; _IO_NO_WRITES)</span> <span class="comment">/* SET ERROR */</span></span><br><span class="line">  {</span><br><span class="line">    f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">    __set_errno (EBADF);</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://ray-cp.github.io/page6/">https://ray-cp.github.io/page6/</a></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/z1r00?tab=repositories">Projects</a></li>
         
          <li><a href="/links/">links</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IO-FILE"><span class="toc-number">1.</span> <span class="toc-text">IO FILE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#fopen"><span class="toc-number">1.1.</span> <span class="toc-text">fopen</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.1.</span> <span class="toc-text">malloc分配内存空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-no-init%E5%AF%B9file%E7%BB%93%E6%9E%84%E4%BD%93%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.</span> <span class="toc-text">_IO_no_init对file结构体进行初始化操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-file-init%E5%B0%86%E7%BB%93%E6%9E%84%E4%BD%93%E9%93%BE%E6%8E%A5%E5%88%B0-IO-list-all"><span class="toc-number">1.1.3.</span> <span class="toc-text">_IO_file_init将结构体链接到_IO_list_all</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-file-fopen%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84"><span class="toc-number">1.1.4.</span> <span class="toc-text">_IO_file_fopen打开文件句柄</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fread"><span class="toc-number">1.2.</span> <span class="toc-text">fread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">初始化输入缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.2.</span> <span class="toc-text">拷贝输入缓冲区数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.3.</span> <span class="toc-text">执行系统调用读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">其他输入函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fwrite"><span class="toc-number">1.3.</span> <span class="toc-text">fwrite</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E7%9B%AE%E6%A0%87%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E8%87%B3%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.3.1.</span> <span class="toc-text">将目标输出数据拷贝至输出缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA%E6%88%96flush%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.3.2.</span> <span class="toc-text">建立输出缓冲区或flush输出缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%9D%97%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.3.</span> <span class="toc-text">以块为单位直接输出数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E7%9B%AE%E6%A0%87%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E6%94%BE%E5%85%A5%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD"><span class="toc-number">1.3.4.</span> <span class="toc-text">剩余目标输出数据放入输出缓冲区中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">其他输出函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">1.4.</span> <span class="toc-text">Reference</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2021/10/09/IO-FILE/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2021/10/09/IO-FILE/&amp;text=IO_FILE"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2021/10/09/IO-FILE/&amp;title=IO_FILE"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2021/10/09/IO-FILE/&amp;is_video=false&amp;description=IO_FILE"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=IO_FILE&amp;body=Check out this article: http://example.com/2021/10/09/IO-FILE/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2021/10/09/IO-FILE/&amp;title=IO_FILE"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2021/10/09/IO-FILE/&amp;title=IO_FILE"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2021/10/09/IO-FILE/&amp;title=IO_FILE"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2021/10/09/IO-FILE/&amp;title=IO_FILE"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2021/10/09/IO-FILE/&amp;name=IO_FILE&amp;description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2021/10/09/IO-FILE/&amp;t=IO_FILE"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright ©
    
    
    2021-2024
    z1r0
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/z1r00?tab=repositories">Projects</a></li><!--
     --><!--
       --><li><a href="/links/">links</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'">


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->



<script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>