<!DOCTYPE html><html lang="en"><head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    <meta name="description" content="12月忙着期末考试（T_T），其余时间都在打buu的题目，解题都放在了https://blog.csdn.net/zzq487782568?spm=1000.2115.3001.5343 放假了，准备花几天时间写一下glibc的源码分析。2.23下没有tcache，主要对_int_malloc和_int_free这两个部分进行分析 笔者在后期再回过头看的时候发现有些地方写得并不是很好，故修改一下">
<meta property="og:type" content="article">
<meta property="og:title" content="glibc-2.23 malloc源码分析">
<meta property="og:url" content="http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="z1r0's blog">
<meta property="og:description" content="12月忙着期末考试（T_T），其余时间都在打buu的题目，解题都放在了https://blog.csdn.net/zzq487782568?spm=1000.2115.3001.5343 放假了，准备花几天时间写一下glibc的源码分析。2.23下没有tcache，主要对_int_malloc和_int_free这两个部分进行分析 笔者在后期再回过头看的时候发现有些地方写得并不是很好，故修改一下">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png">
<meta property="og:image" content="http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png">
<meta property="og:image" content="http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/3.png">
<meta property="og:image" content="http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/4.png">
<meta property="og:image" content="http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/5.png">
<meta property="og:image" content="http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/6.png">
<meta property="og:image" content="http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/7.png">
<meta property="og:image" content="http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/8.png">
<meta property="og:image" content="http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/9.png">
<meta property="og:image" content="http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/10.png">
<meta property="og:image" content="http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/11.png">
<meta property="og:image" content="http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/13.png">
<meta property="article:published_time" content="2022-01-08T12:29:30.000Z">
<meta property="article:modified_time" content="2022-09-07T02:05:10.471Z">
<meta property="article:author" content="z1r0">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>glibc-2.23 malloc源码分析</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.1.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/z1r00?tab=repositories">Projects</a></li><!--
     --><!--
       --><li><a href="/links/">links</a></li><!--
     -->
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2022/01/09/changanzhanyi/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2021/11/25/kernel-pwn%EF%BC%88%E5%9B%9B%EF%BC%89%E6%94%BB%E5%87%BB%E6%89%8B%E6%B3%95/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;text=glibc-2.23 malloc源码分析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=glibc-2.23 malloc源码分析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;is_video=false&amp;description=glibc-2.23 malloc源码分析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=glibc-2.23 malloc源码分析&amp;body=Check out this article: http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=glibc-2.23 malloc源码分析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=glibc-2.23 malloc源码分析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=glibc-2.23 malloc源码分析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=glibc-2.23 malloc源码分析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;name=glibc-2.23 malloc源码分析&amp;description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;t=glibc-2.23 malloc源码分析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#malloc%E9%83%A8%E5%88%86"><span class="toc-number">1.</span> <span class="toc-text">malloc部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-malloc-chunk"><span class="toc-number">1.1.</span> <span class="toc-text">struct_malloc_chunk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chunk-%E5%AE%8F"><span class="toc-number">1.2.</span> <span class="toc-text">chunk 宏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Size-and-alignment-checks-and-conversions"><span class="toc-number">1.2.1.</span> <span class="toc-text">Size and alignment checks and conversions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#request-size"><span class="toc-number">1.2.2.</span> <span class="toc-text">request size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Physical-chunk-operations"><span class="toc-number">1.2.3.</span> <span class="toc-text">Physical chunk operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bits-to-mask-off-when-extracting-size"><span class="toc-number">1.2.4.</span> <span class="toc-text">Bits to mask off when extracting size</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bins"><span class="toc-number">1.3.</span> <span class="toc-text">Bins</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unstorted-bin"><span class="toc-number">1.3.1.</span> <span class="toc-text">unstorted bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#small-bin"><span class="toc-number">1.3.2.</span> <span class="toc-text">small bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#large-bin"><span class="toc-number">1.3.3.</span> <span class="toc-text">large bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unlink"><span class="toc-number">1.3.4.</span> <span class="toc-text">unlink</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binmap"><span class="toc-number">1.3.5.</span> <span class="toc-text">binmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin"><span class="toc-number">1.3.6.</span> <span class="toc-text">fastbin</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#int-malloc"><span class="toc-number">1.4.</span> <span class="toc-text">__int_malloc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E5%88%86%E9%85%8D"><span class="toc-number">1.4.2.</span> <span class="toc-text">开始分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fast-bin"><span class="toc-number">1.4.3.</span> <span class="toc-text">fast bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#small-bin-1"><span class="toc-number">1.4.4.</span> <span class="toc-text">small bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#large-bin-1"><span class="toc-number">1.4.5.</span> <span class="toc-text">large bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binmap-1"><span class="toc-number">1.4.6.</span> <span class="toc-text">binmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#top-chunk"><span class="toc-number">1.4.7.</span> <span class="toc-text">top chunk</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#free-%E9%83%A8%E5%88%86%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7-int-free"><span class="toc-number">2.</span> <span class="toc-text">free 部分············_int_free</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F-1"><span class="toc-number">2.1.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%A7%8Bfree"><span class="toc-number">2.2.</span> <span class="toc-text">开始free</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fast-bins"><span class="toc-number">2.3.</span> <span class="toc-text">fast bins</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unsorted-bins"><span class="toc-number">2.4.</span> <span class="toc-text">unsorted bins</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mmap"><span class="toc-number">2.5.</span> <span class="toc-text">mmap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#summary"><span class="toc-number">3.</span> <span class="toc-text">summary</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-number">4.</span> <span class="toc-text">Reference</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope="" itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        glibc-2.23 malloc源码分析
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <span itemprop="name">z1r0</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-01-08T12:29:30.000Z" itemprop="datePublished">2022-01-08</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/study/">study</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/pwn/" rel="tag">pwn</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <blockquote>
<p>12月忙着期末考试（T_T），其余时间都在打buu的题目，解题都放在了<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzq487782568?spm=1000.2115.3001.5343">https://blog.csdn.net/zzq487782568?spm=1000.2115.3001.5343</a></p>
<p>放假了，准备花几天时间写一下glibc的源码分析。2.23下没有tcache，主要对<code>_int_malloc</code>和<code>_int_free</code>这两个部分进行分析</p>
<p>笔者在后期再回过头看的时候发现有些地方写得并不是很好，故修改一下</p>
</blockquote>
<font size="3">

<h1 id="malloc部分"><a href="#malloc部分" class="headerlink" title="malloc部分"></a>malloc部分</h1><blockquote>
<p>一步一步来，先看一下malloc部分的吧。</p>
</blockquote>
<h2 id="struct-malloc-chunk"><a href="#struct-malloc-chunk" class="headerlink" title="struct_malloc_chunk"></a>struct_malloc_chunk</h2><p><img src="/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png"></p>
<p>有pwn堆基础的应该会知道上面定义的是什么吧。其实就是堆的最最基本的组成形式。</p>
<blockquote>
<p>prev_size：前一个chunk为free时会被调用，这个位置在size前</p>
<p>size：堆的大小。其包含<code>NON_MAIN_ARENA 是否是主线程</code>, <code>IS_MAPPED 是否是mmap分配</code>, <code>PREV_INUSE 是否被释放</code>。</p>
<p>fd，bk：当chunk被free后就会出现，将被释放后同大小的chunk形成一个链表（根据size来）</p>
<p>fd_nextsize，bk_nextsize：主要是大的堆块用(large bin)</p>
</blockquote>
<p><img src="/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png"></p>
<p>这样看的话堆的结构就很明确，这里还少了些，prev_size就在size的前面，fd_nextsize就在bk的后面，bk_nextsize就在fd_nextsize的后面</p>
<h2 id="chunk-宏"><a href="#chunk-宏" class="headerlink" title="chunk 宏"></a>chunk 宏</h2><h3 id="Size-and-alignment-checks-and-conversions"><a href="#Size-and-alignment-checks-and-conversions" class="headerlink" title="Size and alignment checks and conversions"></a>Size and alignment checks and conversions</h3><p><img src="/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/3.png"></p>
<p>这里大致就是尺寸和对齐的检查和转换。malloc头到用户指针的转换，可分配最小的chunk和size等功能</p>
<blockquote>
<p>chunk2mem：将指向chunk header移到fd，<code>SIZE_SZ = sizeof(size_t) = 8，2 * 8 = 16</code>所以就是头到fd，而fd是user_data的头所以正如上面注释所说<code>conversion from malloc headers to user pointers</code></p>
<p>mem2chunk：与上面相反</p>
<p>MIN_CHUNK_SIZE：最小的chunk的size，到fd_nextsize的偏移，也就是最小需要包含bk进去</p>
<p>offestof：为了方便计算出某个成员的偏移</p>
<p>MINSIZE：目前来说和MIN_CHUNK_SIZE是一致的</p>
<p>aligned_ok：检查是否与malloc_alignment对齐，不对齐则为0，<code>MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</code></p>
<p>misaligned_chunk：chunk是否对齐，没有对齐则返回未对齐的字节数。</p>
</blockquote>
<h3 id="request-size"><a href="#request-size" class="headerlink" title="request size"></a>request size</h3><p><img src="/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/4.png"></p>
<blockquote>
<p>REQUEST_OUT_OF_RANGE：传给 malloc 的值在负数范围内，不得大于 -2 * MINSIZE</p>
<p>request2size：将用户请求的内存大小转换为内存对齐的大小。</p>
<p>checked_request2size：很明显，为request2size加上了size的检查</p>
</blockquote>
<h3 id="Physical-chunk-operations"><a href="#Physical-chunk-operations" class="headerlink" title="Physical chunk operations"></a>Physical chunk operations</h3><p><img src="/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/5.png"></p>
<blockquote>
<p>PREV_INUSE：物理相邻的上一个chunk是否处于被分配状态</p>
<p>IS_MMAPPED：是否由mmap()进行分配得到</p>
<p>NON_MAIN_ARENA：是否是一个不属于main_arena的chunk</p>
</blockquote>
<h3 id="Bits-to-mask-off-when-extracting-size"><a href="#Bits-to-mask-off-when-extracting-size" class="headerlink" title="Bits to mask off when extracting size"></a>Bits to mask off when extracting size</h3><blockquote>
<p>Note: IS_MMAPPED is intentionally not masked off from size field in macros for which mmapped chunks should never be seen. This should cause helpful core dumps to occur if it is tried by accident by people extending or adapting this malloc.</p>
</blockquote>
<p>这里不需要太多解释了，重点看unstortedbin smallbin largebin，和<code>_int_malloc</code> 、<code>_int_free</code>这两部分的代码</p>
<h2 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h2><p>当chunk被释放后会以size大小来组成一个数组，用以存放闲置chunk的数组，按照size来存放在不同的下标的bin中。一共有128个bin，bin中的chunk链表采取FIFO机制，bins一共可以有三类：unstorted bin、small bin、large bin。</p>
<h3 id="unstorted-bin"><a href="#unstorted-bin" class="headerlink" title="unstorted bin"></a>unstorted bin</h3><blockquote>
<p>pwn的堆题的话，许多都是unstorted bin来泄露libc。什么是unstroted bin呢？</p>
</blockquote>
<p><img src="/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/6.png"></p>
<p>可以看到unstorted bin宏调用了bin_at这个宏</p>
<p><img src="/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/7.png"></p>
<blockquote>
<p>bin_at：取出位于下标i的bin chunk，这里获得的指针为原始存在bin中的指针再减去了chunk header的大小所得到的值，这是由于在bins数组中存放的为fd/bk，需要减去chunk header的大小才能获得一个指向chunk的指针而不是指向mem的指针，从这里我们也可以看出一个bin占据bins数组两格的空间。</p>
<p>next_bin：获取下一个bin</p>
<p>first &amp;&amp; last：获得bin chunk的fd/bk</p>
</blockquote>
<p>在chunk分割过程中所剩余的chunk、以及所有回归闲置的chunk都会首先被存放在unstortedbin中。当再次malloc时其中的chunk会被放到正常的bins中，如fastbin。</p>
<p>这里对存放unstortedbin的size没有做限制。bin 0不存在，bin 1放的是unstorted bin。</p>
<h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p>bin 2开始放small bin。</p>
<p><img src="/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/8.png"></p>
<p>最大的small bin的size在32位下为为504，64是1008，small bins的数量为62</p>
<h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span></span><br><span class="line"><span class="meta">   : largebin_index_32 (sz))</span></span><br></pre></td></tr></tbody></table></figure>

<p>获取index的过程有点复杂。<code>largebin_index_32(sz)  </code>这个宏是32位下获取large bin chunk在bin中的index。一共有63个large bin。</p>
<h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p><img src="/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/9.png"></p>
<p>在一些pwn中有时会用的unlink这个操作来进行堆块重叠。</p>
<blockquote>
<ul>
<li><p>p是被unlink的chunk。</p>
</li>
<li><p>从源码的第一行可以看到FD是p-&gt;fd，BK则是p-&gt;bk。</p>
</li>
<li><p>然后会进行检查，检查FD-&gt;bk和BK-&gt;fd是否都为P，若是的话则将FD-&gt;bk=BK，BK-&gt;fd=FD</p>
</li>
<li><p>假如size是在small bin的范围内，则unlink结束。若不在则还需要将它从nextsize链表中进行unlink</p>
</li>
<li><p>检查P-&gt;fd_nextsize-&gt;bk_nextsize和P-&gt;bk_nextsize-&gt;fd_nextsize是否都指向P</p>
</li>
<li><p>FD-&gt;fd_nextsize不为NULL时，将P从所处nextsize链表中unlink，为NULL时，若P-&gt;fd_nextsize指向P则将FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD都 指向FD，否则使用FD替换掉P所在的nextsize链表中的位置</p>
</li>
</ul>
</blockquote>
<p>具体的unlink的实战在我blog的其他文章下专门写了。</p>
<h3 id="binmap"><a href="#binmap" class="headerlink" title="binmap"></a>binmap</h3><p><img src="/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/10.png"></p>
<blockquote>
<p> To help compensate for the large number of bins, a one-level index structure is used for bin-by-bin searching.  binmap’ is a bitvector recording whether bins are definitely empty so they can be skipped over during during traversals.  The bits are NOT always cleared as soon as bins are empty, but instead only when they are noticed to be empty during traversal in malloc.</p>
</blockquote>
<p>其实就是因为bins的数量多，binmap使用位向量来标记bins数组中的每一个bin，以便于能够快速遍历bins。</p>
<h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><p><img src="/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/11.png"></p>
<p>定义上的最大的fastbin chunk的size—–&gt;MAX_FAST_SIZE。超过这个size的chunk都将会被放进unsorted bin中。</p>
<h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="__int_malloc"></a>__int_malloc</h2><p>malloc中最重要的部分来了。对它进行慢慢地分析吧。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="type">size_t</span> bytes)<span class="comment">//参数为指针av，申请空间bytes，其函数声明</span></span><br><span class="line">{</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span> 	<span class="comment">//对齐后所需内存大小</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* associated bin index */</span>		<span class="comment">//保存chunk在bins中的下标</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span>			<span class="comment">//保存bin</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span>	<span class="comment">//保存候选chunk</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span>					<span class="comment">//chunk的size</span></span><br><span class="line">  <span class="type">int</span> victim_index;                 <span class="comment">/* its bin index */</span>				<span class="comment">//候选chunk的index</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span>	<span class="comment">//从候选chunk分配内在后剩余的内存指针</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* its size */</span>					<span class="comment">//剩余部分内存大小</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span>			</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>开头定义了一些局部变量在<code>_int_malloc</code>中。一些变量的意思写在了注释里</p>
<h3 id="开始分配"><a href="#开始分配" class="headerlink" title="开始分配"></a>开始分配</h3><p><img src="/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/13.png"></p>
<p>这里其实就是取得对齐后的size值，假如没有可用的arena，则随机分配一块内存并返回</p>
<h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//如果一个size在fast bins中的范围内，则从fast bins中分配，第一次调用malloc时，max_fat为0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">    {</span><br><span class="line">      idx = fastbin_index (nb);						<span class="comment">//大小在fast bins中的下标</span></span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);			<span class="comment">//从对应下标中取出堆块指针</span></span><br><span class="line">      mchunkptr pp = *fb;</span><br><span class="line">      <span class="comment">//若存在可用bin，将bin从链表中取出。取出当前bin的fd放入链表尾，fd的值不能和当前bin相同</span></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">          victim = pp;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">      <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">             != victim);</span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)		<span class="comment">//这里前面定义了，候选chunk，如果候选chunk存在，则对其进行利用</span></span><br><span class="line">        {</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))		<span class="comment">//检查size!!!!</span></span><br><span class="line">            {</span><br><span class="line">              errstr = <span class="string">"malloc(): memory corruption (fast)"</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            }</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);		<span class="comment">//再进行更多的检测，堆块大小，是否对齐</span></span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);					<span class="comment">//返回chunk地址</span></span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>注意这里会检测size，z1r0在初学堆时，2.23下进行利用，申请堆块到malloc发现会出错<code>malloc(): memory corruption (fast)</code>原因是malloc_hook那里的size不一样才导致malloc失败，这时就要找有没有符合size的地址，在malloc_hook - 0x23那里存在0x7f的大小，将地址申请在那里即可。（同时在bins中的大小也要符合size！！！）</p>
<h3 id="small-bin-1"><a href="#small-bin-1" class="headerlink" title="small bin"></a>small bin</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If a small request, check regular bin.  Since these "smallbins"</span></span><br><span class="line"><span class="comment">    hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">    (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">    processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">    anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//如果大小在small bins范围内，则在small bins中分配</span></span><br><span class="line"> <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">   { </span><br><span class="line">     idx = smallbin_index (nb);				<span class="comment">//所需大小对应的下标</span></span><br><span class="line">     bin = bin_at (av, idx);					<span class="comment">//从arena获取下标对应的bin</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ((victim = last (bin)) != bin)			<span class="comment">//如果候选chunk等于表头，表示该链表为空</span></span><br><span class="line">       {</span><br><span class="line">         <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span><span class="comment">//如果候选chunk为0,表示还没有创建双向循环链表</span></span><br><span class="line">           malloc_consolidate (av);				<span class="comment">//第一次malloc时会调用这个函数合并所有的fast bin</span></span><br><span class="line">         <span class="keyword">else</span>										<span class="comment">//候选chunk不为0,尝试将候选chunk从small bin中取出</span></span><br><span class="line">           {</span><br><span class="line">             bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">               {</span><br><span class="line">                 errstr = <span class="string">"malloc(): smallbin double linked list corrupted"</span>;</span><br><span class="line">                 <span class="keyword">goto</span> errout;</span><br><span class="line">               }</span><br><span class="line">             set_inuse_bit_at_offset (victim, nb);		<span class="comment">//设置候选chunk的inuse标志，该标志位于下一个chunk size位的第0个bit</span></span><br><span class="line">             bin-&gt;bk = bck;							<span class="comment">//将bin从链表中取出，相当于unlink。</span></span><br><span class="line">             bck-&gt;fd = bin;							<span class="comment">////最后一个chunk中的fd为main_arena+xxx</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (av != &amp;main_arena)					</span><br><span class="line">               victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             check_malloced_chunk (av, victim, nb);		<span class="comment">//进行检测</span></span><br><span class="line">             <span class="type">void</span> *p = chunk2mem (victim);					<span class="comment">//返回chunk</span></span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到上面有一个相当于unlink的功能，其实small bin也有对应的small bin attack，需要伪造 一个heap地址来绕过<code>bck-&gt;fd != victim</code>，可以看到<code>最后一个chunk中的fd为main_arena+xxx</code>因为在伪造chunk时还需要libc地址，没什么利用价值，但是在高版本中比如glibc2.27和glibc2.29中malloc small bin操作不一样，可以任意地址写入libc地址。这个笔者在写后面的高版本glibc源码分析再看一下。</p>
<h3 id="large-bin-1"><a href="#large-bin-1" class="headerlink" title="large bin"></a>large bin</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="comment">//大小不属于small bins，则位于large bin中。在malloc源码中，把非small bin的部分定义为large bin</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      idx = largebin_index (nb);		<span class="comment">//计算所需大小对应large bins的下标</span></span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))			<span class="comment">//判断是否存在属于fast bins的空闲chunk</span></span><br><span class="line">        malloc_consolidate (av);		<span class="comment">//合并所有的fast bin</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">     it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">     the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">     bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">     chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">     near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">     do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">     otherwise need to expand memory to service a "small" request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;; )			</span><br><span class="line">    {</span><br><span class="line">      <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))	<span class="comment">//反向遍历unsorted bins双向循环链表，直到候选chunk指向头节点</span></span><br><span class="line">        {</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)			<span class="comment">//判断size是否合法</span></span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">"malloc(): memory corruption"</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);				<span class="comment">//若合法则取出size位。</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">		<span class="comment">//如果这个chunk大小属于small bins，且unsorted bins中只有一个chunk，且这个chunk为last remainder chunk，且这个chunk的大小大于所需要的size + MINSIZE</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">            {</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span>		<span class="comment">//从这个remainder中取出所需要的部分，也表头形成双向循环链表</span></span><br><span class="line">              remainder_size = size - nb;				<span class="comment">//取出剩余部分</span></span><br><span class="line">              remainder = chunk_at_offset (victim, nb);	<span class="comment">//获得chunk指针</span></span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;	<span class="comment">///arena指向remainder</span></span><br><span class="line">              av-&gt;last_remainder = remainder;		<span class="comment">//设置新的remainder</span></span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);				<span class="comment">//remainder指向arena</span></span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))				<span class="comment">//如果剩余部分不为small bins，则只能是large bins</span></span><br><span class="line">                  													<span class="comment">//因此需要将fd_nextsize和bk的那个清空，unsorted bin无需这两个</span></span><br><span class="line">                {</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                }</span><br><span class="line">          </span><br><span class="line">              set_head (victim, nb | PREV_INUSE |					<span class="comment">//设置chunk的相关信息</span></span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);							<span class="comment">//获得用户部分可用的内存指针</span></span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span>							<span class="comment">//将bin从unsortedbin中取出</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span>			<span class="comment">//若size位等于所需要大小，则设置标志位，将bin取出并返回用户指针</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            {</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line">		<span class="comment">//若size属于small bin,则将chunk加入到bck和fwd之间，作为small bins的第一个chunk</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            {</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            }</span><br><span class="line">          <span class="keyword">else</span>		<span class="comment">//如果不属于small bin，则是largebin，将chunk加入到bck和fwd之间，作为large bins的第一个chunk</span></span><br><span class="line">            {</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)	<span class="comment">//fwd不等于bck，说明large bins中存在空闲chunk</span></span><br><span class="line">                {</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="comment">//如果当前size比最后一个chunk size还要小，则将当前size的chunk加入到chunk size链表尾，然后将所有大小的链表取出首个chunk到一起</span></span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                    {</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    }</span><br><span class="line">                  <span class="keyword">else</span>		<span class="comment">//否则需要循环判断插入位置</span></span><br><span class="line">                    {</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)	<span class="comment">//正向遍历chunk size链表，找到第一个chunk大小小于等于当前大小的chunk</span></span><br><span class="line">                        {</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);<span class="comment">//chunk是否位于main_arena中。</span></span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)<span class="comment">//如果相等</span></span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span><span class="comment">//插入第二个位置</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span><span class="comment">//否则将伸出一个大小等于当前size的chunk链表，将该链表加入到chunk size链表的尾部</span></span><br><span class="line">                        {</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        }</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">              <span class="keyword">else</span><span class="comment">//当链表中只有一个chunk时</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            }</span><br><span class="line">	<span class="comment">//将当前chunk加入large bins的空闲链表中</span></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">//如果请求过大，扫描中的当前bin块按顺序排序以找到适合的最小值。为此使用跳过列表</span></span><br><span class="line">      <span class="comment">//当处理完unsorted bins后，使用最佳匹配法匹配chunk</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (nb))<span class="comment">//不存在于small bin中，那就是是否位于large bins中</span></span><br><span class="line">        {</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="comment">//判断large bins是否为空，以及链表中最大size是否满足所需大小</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">            {</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))<span class="comment">//循环寻找合适的chunk</span></span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="comment">//为了尽量不破坏链表结构，尝试取出victim-&gt;fd作为候选chunk</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)<span class="comment">//判断是否前一个结点的size与申请空间相等</span></span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink (av, victim, bck, fwd);<span class="comment">//进行unlink。</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="comment">//如果小于MINSIZE,将整个chunk分配给应用层。</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                {</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);<span class="comment">//设置inuse标记位</span></span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)<span class="comment">//是否位于main_arena</span></span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                }</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  <span class="comment">//将剩余部分作为新chunk加入到unsorted bins中。</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<span class="comment">//是否完整</span></span><br><span class="line">                    {</span><br><span class="line">                      errstr = <span class="string">"malloc(): corrupted unsorted chunks"</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    }</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))<span class="comment">//若在large bin的范围内，将fd_nextsize和bk_nextsize设置为0。</span></span><br><span class="line">                    {</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    }</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |<span class="comment">//设置信息</span></span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                }</span><br><span class="line">              check_malloced_chunk (av, victim, nb);<span class="comment">//检测chunk</span></span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//转换为用户chunk</span></span><br><span class="line">              alloc_perturb (p, bytes);<span class="comment">//初始化chunk</span></span><br><span class="line">              <span class="keyword">return</span> p;<span class="comment">//返回指针给应用层</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>large bin attack的话其实就是在插入的过程中伪造large bin的bk_nextsize以及bk，即可实现任意地址写堆地址</p>
</blockquote>
<h3 id="binmap-1"><a href="#binmap-1" class="headerlink" title="binmap"></a>binmap</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">        bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">        (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">        that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">        The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">        when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="comment">//在small bins和large bins中都没有找到大小合适的chunk，尝试从大小比所需大小更大的空闲chunk中寻找合适的</span></span><br><span class="line">  ++idx;</span><br><span class="line">     bin = bin_at (av, idx);</span><br><span class="line">     block = idx2block (idx);</span><br><span class="line">     <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">     bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (;; )</span><br><span class="line">       {</span><br><span class="line">         <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">         <span class="comment">//如果该块中没有更多的设置位，则跳过该块的其余部分</span></span><br><span class="line">         <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">           {</span><br><span class="line">             <span class="keyword">do</span></span><br><span class="line">               {</span><br><span class="line">                 <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span><span class="comment">//没有合适的chunk，尝试使用top chunk分配</span></span><br><span class="line">                   <span class="keyword">goto</span> use_top;</span><br><span class="line">               }</span><br><span class="line">             <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line">			<span class="comment">//bin指向block的第一个bit对应的bin</span></span><br><span class="line">             bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">             bit = <span class="number">1</span>;</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">         <span class="comment">//在block中遍历对应的bin，直到找到一个不为0的bit</span></span><br><span class="line">         <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">           {</span><br><span class="line">             bin = next_bin (bin);</span><br><span class="line">             bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">             assert (bit != <span class="number">0</span>);</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">         <span class="comment">//将chunk加入链表尾</span></span><br><span class="line">         victim = last (bin);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">         <span class="comment">//若victim与bin链表头指针相同，表示该bin中没有空闲chunk</span></span><br><span class="line">         <span class="keyword">if</span> (victim == bin)</span><br><span class="line">           {</span><br><span class="line">             av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">             bin = next_bin (bin);</span><br><span class="line">             bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           {</span><br><span class="line">             size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">             <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">             <span class="comment">//chunk大小是否满足</span></span><br><span class="line">             assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">             remainder_size = size - nb;	<span class="comment">//计算分配后的剩余大小</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">/* unlink */</span></span><br><span class="line">             unlink (av, victim, bck, fwd);	<span class="comment">//进行unlink</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">/* Exhaust */</span></span><br><span class="line">             <span class="comment">//剩余在小小于minsize，则将整个chunk分配给用户</span></span><br><span class="line">             <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">               {</span><br><span class="line">                 set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                 <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                   victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">               }</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* Split */</span></span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               {</span><br><span class="line">                 remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                 <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                    have to perform a complete insert here.  */</span></span><br><span class="line">                 <span class="comment">//剩余部分作为新chunk加入到unsorted bins中</span></span><br><span class="line">                 bck = unsorted_chunks (av);</span><br><span class="line">                 fwd = bck-&gt;fd;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                   {</span><br><span class="line">                     errstr = <span class="string">"malloc(): corrupted unsorted chunks 2"</span>;</span><br><span class="line">                     <span class="keyword">goto</span> errout;</span><br><span class="line">                   }</span><br><span class="line">                 remainder-&gt;bk = bck;</span><br><span class="line">                 remainder-&gt;fd = fwd;</span><br><span class="line">                 bck-&gt;fd = remainder;</span><br><span class="line">                 fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">                 <span class="comment">//若分配大小属于small bin，将last_remainder设置为剩余部分构成的chunk</span></span><br><span class="line">                 <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                   av-&gt;last_remainder = remainder;</span><br><span class="line">                 <span class="keyword">if</span> (!in_smallbin_range (remainder_size))<span class="comment">//属于large bin将fd_nextsize和bk_nextsize给设置为0</span></span><br><span class="line">                   {</span><br><span class="line">                     remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                     remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   }</span><br><span class="line">                 set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                           (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                 set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                 set_foot (remainder, remainder_size);</span><br><span class="line">               }</span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;<span class="comment">//返回指针</span></span><br><span class="line">           }</span><br><span class="line">       }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">	  use_top:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">		<span class="comment">//获得top chunk指针与大小</span></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line">	<span class="comment">//满足size &gt; nb + minsize才能分配</span></span><br><span class="line"><span class="comment">//这里的size为unsigned long当size为-1时，size会变得特别大，会符合条件，再控制下面的指针就可以任意地址写</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">        {</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;<span class="comment">//返回指针</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line"><span class="comment">//topchunk也无法满足要求则检查fast bins中是否存在空闲的chunk</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        {</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="comment">//从small bin和large bins获取下标</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        {<span class="comment">//所有方法不可行，最后的解决方案是向系统申请一块新的内存</span></span><br><span class="line">          <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>top chunk的漏洞利用手段:house of force，篡改top chunk的size字段，申请任意大小的堆内存</p>
</blockquote>
<h1 id="free-部分············-int-free"><a href="#free-部分············-int-free" class="headerlink" title="free 部分············_int_free"></a>free 部分············_int_free</h1><h2 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">{</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span>								<span class="comment">//存储size字段值</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span>						<span class="comment">//存储fast bin堆块指针</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span>					<span class="comment">//下一个chunk的指针</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span>								<span class="comment">//下一个chunk size</span></span><br><span class="line">  <span class="type">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span>				<span class="comment">//下一个chunk的使用情况</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span>		<span class="comment">//距离上一个堆块距离</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* misc temp for linking */</span>					<span class="comment">//临时，bk指针指向的堆块</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span>					<span class="comment">//临时，fd指针指向的堆块</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> locked = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="开始free"><a href="#开始free" class="headerlink" title="开始free"></a>开始free</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  size = chunksize (p);<span class="comment">//获得目标chunk的size字段的值</span></span><br><span class="line">  <span class="comment">/* Little security check which won't hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by "design" from some intruder.  */</span></span><br><span class="line"><span class="comment">//安全检查，检查chunk指针合法性，是否对齐等，不会影响性能</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    {</span><br><span class="line">      errstr = <span class="string">"free(): invalid pointer"</span>;</span><br><span class="line">    errout:</span><br><span class="line">      <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">        (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line"><span class="comment">//size是否小于chunk的最小size，以及是否对齐</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    {</span><br><span class="line">      errstr = <span class="string">"free(): invalid size"</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//chunk是否在空闲状态（检查下一个chunk的p位）</span></span><br><span class="line">  check_inuse_chunk(av, p);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">    and used quickly in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//因为是fastbin，所以这里判断了一下size是否小于0x80</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	If TRIM_FASTBINS set, don't place chunks</span></span><br><span class="line"><span class="comment">	bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="comment">//如果设置了TRIM_FASTBINS，就不能将与top chunk相邻的chunk放入fast bins</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      ) {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">	|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">			     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      {</span><br><span class="line">	<span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">	   of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">	   after getting the lock.  */</span></span><br><span class="line">	<span class="keyword">if</span> (have_lock	</span><br><span class="line">	    || ({ assert (locked == <span class="number">0</span>);</span><br><span class="line">		  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">		  locked = <span class="number">1</span>;</span><br><span class="line">		  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">		    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">	      }))</span><br><span class="line">	  {</span><br><span class="line">	    errstr = <span class="string">"free(): invalid next size (fast)"</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  }</span><br><span class="line">	<span class="keyword">if</span> (! have_lock)</span><br><span class="line">	  {</span><br><span class="line">	    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">	    locked = <span class="number">0</span>;</span><br><span class="line">	  }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">	<span class="comment">//将chunk放入fast bins中</span></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      {<span class="comment">//检测double free,这里可以被绕过，free(1)free(2)free(1)</span></span><br><span class="line">	<span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">	   (i.e., double free).  */</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	  {</span><br><span class="line">	    errstr = <span class="string">"double free or corruption (fasttop)"</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  }</span><br><span class="line">	<span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">	   size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">	   only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">	   deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">	<span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">	  old_idx = fastbin_index(chunksize(old));</span><br><span class="line">	p-&gt;fd = old2 = old;</span><br><span class="line">      }</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">      {</span><br><span class="line">	errstr = <span class="string">"invalid fastbin entry (free)"</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>fast bins这里的话就是double free的利用。检查只会检查头部的chunk，而free(1)free(2)free(1)这样即可绕过。</p>
</blockquote>
<h2 id="unsorted-bins"><a href="#unsorted-bins" class="headerlink" title="unsorted bins"></a>unsorted bins</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//如果chunk不过通过mmap映射的，则chunk进入unsorted bins</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) {</span><br><span class="line">    <span class="keyword">if</span> (! have_lock) {</span><br><span class="line">      (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">//下一个chunk的位置</span></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">      <span class="comment">//如果释放的堆块为top则触发异常</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">      {</span><br><span class="line">	errstr = <span class="string">"double free or corruption (top)"</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">      }</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">      <span class="comment">//下一个堆 块地址是否超过top chunk地址，超过则异常</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">			  &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">			  &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">      {</span><br><span class="line">	errstr = <span class="string">"double free or corruption (out)"</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">      }</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">      <span class="comment">//chunk已经被free，触发异常</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">      {</span><br><span class="line">	errstr = <span class="string">"double free or corruption (!prev)"</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">      }</span><br><span class="line"><span class="comment">//size是否合法与对齐的情况</span></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">	|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      {</span><br><span class="line">	errstr = <span class="string">"free(): invalid next size (normal)"</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">      <span class="comment">//若下一个chunk的p位也为1的话则进行unlink，向上合并</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) {</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//下一个chunk不是top chunk的话，获得p标记位</span></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) {</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">        <span class="comment">//下一个chunk已经空闲，则unlink向下合并</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) {</span><br><span class="line">	unlink(av, nextchunk, bck, fwd);</span><br><span class="line">	size += nextsize;</span><br><span class="line">      } <span class="keyword">else</span></span><br><span class="line">	clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">	not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">	been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="comment">//得到arena中的bins指针</span></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;<span class="comment">//指向最后一个进入unsorted bins的指针</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<span class="comment">//最后一个堆块bk不指向bins的话，触发异常</span></span><br><span class="line">	{</span><br><span class="line">	  errstr = <span class="string">"free(): corrupted unsorted chunks"</span>;</span><br><span class="line">	  <span class="keyword">goto</span> errout;</span><br><span class="line">	}<span class="comment">//chunk进入unsorted bins</span></span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))<span class="comment">//chunk为large bins，将fd_nextsize和bk_nextsize设置为null</span></span><br><span class="line">	{</span><br><span class="line">	  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don't know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don't want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//如果size大于FASTBIN_CONSOLIDATION_THRESHOLD，则合并堆中所有空闲的fast bin</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) {</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">	malloc_consolidate(av);</span><br><span class="line"><span class="comment">//如果为main_arena，且top chunk超过阈值，则切割arena</span></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) {</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">	    (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))</span><br><span class="line">	  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">	<span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">	   large, because the corresponding heap might go away.  */</span></span><br><span class="line">	heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">	assert(heap-&gt;ar_ptr == av);</span><br><span class="line">	heap_trim(heap, mp_.top_pad);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//解除互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (! have_lock) {</span><br><span class="line">      assert (locked);</span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>free掉超过fast bin时，进unsorted bin，这时fd和bk指向main_arena+offest。此时如果有uaf，则可以直接输出main_arena+offest</p>
</blockquote>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk was allocated via mmap, release via munmap().</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>不符合以上的所有情况，则直接解除内存映射</p>
<h1 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h1><p>看了<code>_int_malloc</code>和<code>_int_free</code>这两部分源码，可以发现有很多地方并没有太过严格的检查。2.23下可以用fast bin double free，house全家桶等攻击手法<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/introduction/%E4%B8%8A%E8%AE%B2%E5%BE%97%E5%BE%88%E5%85%A8%E9%9D%A2%EF%BC%8C%E7%AC%94%E8%80%85%E5%9C%A8%E4%B9%8B%E5%89%8D%E7%9A%84%E6%96%87%E7%AB%A0%E4%B8%8A%E5%87%BA%E5%86%99%E4%BA%86%E5%BE%88%E5%A4%9A%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E4%BB%85%E4%BB%85%E7%94%A8%E6%9D%A5%E5%AD%A6%E4%B9%A0libc-2.23%E7%9A%84%E6%BA%90%E7%A0%81%E3%80%82">https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/introduction/上讲得很全面，笔者在之前的文章上出写了很多利用手法，这篇文章仅仅用来学习libc-2.23的源码。</a></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41988448/article/details/121859213">https://blog.csdn.net/qq_41988448/article/details/121859213</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/njh18790816639/article/details/121846347">https://blog.csdn.net/njh18790816639/article/details/121846347</a><br><a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/01/15/NOTE-0X00-MALLOC-2.23-PART-I/#%E5%9B%9B%E3%80%81Fastbins%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%AD%98%E5%8F%96chunk%E7%9A%84%E6%95%B0%E7%BB%84">https://arttnba3.cn/2021/01/15/NOTE-0X00-MALLOC-2.23-PART-I/#%E5%9B%9B%E3%80%81Fastbins%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%AD%98%E5%8F%96chunk%E7%9A%84%E6%95%B0%E7%BB%84</a><br><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/introduction/">https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/introduction/</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41988448/article/details/121590288">https://blog.csdn.net/qq_41988448/article/details/121590288</a></p>
</font>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/z1r00?tab=repositories">Projects</a></li>
         
          <li><a href="/links/">links</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#malloc%E9%83%A8%E5%88%86"><span class="toc-number">1.</span> <span class="toc-text">malloc部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-malloc-chunk"><span class="toc-number">1.1.</span> <span class="toc-text">struct_malloc_chunk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chunk-%E5%AE%8F"><span class="toc-number">1.2.</span> <span class="toc-text">chunk 宏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Size-and-alignment-checks-and-conversions"><span class="toc-number">1.2.1.</span> <span class="toc-text">Size and alignment checks and conversions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#request-size"><span class="toc-number">1.2.2.</span> <span class="toc-text">request size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Physical-chunk-operations"><span class="toc-number">1.2.3.</span> <span class="toc-text">Physical chunk operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bits-to-mask-off-when-extracting-size"><span class="toc-number">1.2.4.</span> <span class="toc-text">Bits to mask off when extracting size</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bins"><span class="toc-number">1.3.</span> <span class="toc-text">Bins</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unstorted-bin"><span class="toc-number">1.3.1.</span> <span class="toc-text">unstorted bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#small-bin"><span class="toc-number">1.3.2.</span> <span class="toc-text">small bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#large-bin"><span class="toc-number">1.3.3.</span> <span class="toc-text">large bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unlink"><span class="toc-number">1.3.4.</span> <span class="toc-text">unlink</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binmap"><span class="toc-number">1.3.5.</span> <span class="toc-text">binmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin"><span class="toc-number">1.3.6.</span> <span class="toc-text">fastbin</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#int-malloc"><span class="toc-number">1.4.</span> <span class="toc-text">__int_malloc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E5%88%86%E9%85%8D"><span class="toc-number">1.4.2.</span> <span class="toc-text">开始分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fast-bin"><span class="toc-number">1.4.3.</span> <span class="toc-text">fast bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#small-bin-1"><span class="toc-number">1.4.4.</span> <span class="toc-text">small bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#large-bin-1"><span class="toc-number">1.4.5.</span> <span class="toc-text">large bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binmap-1"><span class="toc-number">1.4.6.</span> <span class="toc-text">binmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#top-chunk"><span class="toc-number">1.4.7.</span> <span class="toc-text">top chunk</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#free-%E9%83%A8%E5%88%86%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7-int-free"><span class="toc-number">2.</span> <span class="toc-text">free 部分············_int_free</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F-1"><span class="toc-number">2.1.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%A7%8Bfree"><span class="toc-number">2.2.</span> <span class="toc-text">开始free</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fast-bins"><span class="toc-number">2.3.</span> <span class="toc-text">fast bins</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unsorted-bins"><span class="toc-number">2.4.</span> <span class="toc-text">unsorted bins</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mmap"><span class="toc-number">2.5.</span> <span class="toc-text">mmap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#summary"><span class="toc-number">3.</span> <span class="toc-text">summary</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-number">4.</span> <span class="toc-text">Reference</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;text=glibc-2.23 malloc源码分析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=glibc-2.23 malloc源码分析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;is_video=false&amp;description=glibc-2.23 malloc源码分析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=glibc-2.23 malloc源码分析&amp;body=Check out this article: http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=glibc-2.23 malloc源码分析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=glibc-2.23 malloc源码分析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=glibc-2.23 malloc源码分析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;title=glibc-2.23 malloc源码分析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;name=glibc-2.23 malloc源码分析&amp;description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/01/08/glibc-2-23%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;t=glibc-2.23 malloc源码分析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright ©
    
    
    2021-2023
    z1r0
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/z1r00?tab=repositories">Projects</a></li><!--
     --><!--
       --><li><a href="/links/">links</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'">


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->



<script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>